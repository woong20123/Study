# 참조 사이트 : https://ko.javascript.info/
## setTimeout과 setInterval을 이용한 호출 스케줄링
### setTimeout 수행
* setTimeOut을 이용해 일정 시간이 지난 후에 함수를 실행하는 방법
* setInterval을 이용해 일정 시간 간격을 두고 함수를 실행하는 방법
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
### clearTimeout으로 스케줄링 취소하기 
```js
let timerId = setTimeout( () => alert("아무런 일도 일어나지 않습니다."), 1000);
alert(timerId); // 타이머 식별자

clearTimeout(timerId);
```

## 중첩 setTimeout
* 일정 간격을 두고 반복실행하는 방법은 2가지가 있음
  * `setInterval`을 이용하는 방법
  * 중첩 `setTimeout`을 이용하는 방법
```js
let timerId = setTimeout(function tick(){
    alert('째깍');
    timerId = setTimeout(tick, 2000);
}, 2000);
```
* 중첩 setTimeout을 이용하는 방법이 setInterval을 사용하는 방법보다 유연합니다. 
* 결과에 따라서 시간을 조절해서 스케줄링할 수 있습니다. 
* `setInterval`은 지연간격을 보장하지 않습니다. 
  * 즉 함수 실행 시간을 빼고서 측정합니다 .
* `setTimeout`은 함수 실행한 이후의 시간을 기준으로 타이머를 설정합니다. 

## 대기 시간이 0인 setTimeout
* 브라우저는 HTML5 표준에서 정한 중첩 타이머 실행 간격제약을 준수
  * 다섯 번째 중첩 타이머 이후에는 최소 4밀리초 이상으로 강제함
* 서버측에는 제약이 없음

## call/apply와 데코레이터, 포워딩
* 자바스크립트에서 함수를 어떻게 포워딩하는지 어떻게 데코레이팅 하는지 알아봅니다. 
### 코드 변경 없이 캐싱 기능 추가하기
* CPU 연산 시간을 많이 걸리지만 안정적인 함수 slow가 있을때 해당 결과를 캐싱하는 방법을 공유합니다. 
* 코드를 추가하는 대신에 레퍼 함수를 통해서 캐싱 기능을 추가합니다. 
* `cachingDecorator`와 같이 함수의 행동을 변경시켜주는 함수를 데코레이터라고 합니다. 
* 데코레이터를 사용하게되면 실행코드와 캐싱 관련 코드를 분리할 수 있습니다. 
```js
function slow(x){
    alert(`slow(${x})를 호출`);
    return x;
}

function cachingDecorator(func){
    let cache = new Map();

    return function(x){
        if (cache.has(x)){
            return cache.get(x);
        }

        let result = func(x);
        
        cache.set(x, result);
        return result;
    };
}

slow = cachingDecorator(slow);

alert( slow(1) );
alert( "다시 호출: " + slow(1));

alert( slow(2) );
alert( "다시 호출: " + slow(2));
```

### `func.call`를 사용하여 컨텍스트 지정하기 

```js
let worker = {
    someMethod() {
        return 1;
    },

    slow(x) {
        // CPU 집약적 작업
        alert(`slow`);
        return x * this.someMethod();
    }
};

function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)){
            return cache.get(x);
        }
        let result = func(x);
        cache.set(x, result);
        return result;
    }
}


alert( worker.slow(1) ); // 기존 메서드는 잘 동작합니다.

worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용

alert( worker.slow(2) ); // 에러 발생!, Error: Cannot read property 'someMethod' of undefined
```
* 객체를 통해서 데코레이터를 사용할때는 this가 사라지기 때문에 문제가 발생합니다.
* func.call을 사용하면 this를 고정시켜줄 수 있습니다.
```js 
// 사용 방식
func.call(context, arg1, arg2, ...)

function sayHi(){
    alert(this.name);
}

let user = { name: "John" };
let admin = { name: "Admin" };

sayHi.call( user );
sayHi.call( admin );
```

### func.apply
* func.apply는 유사객체 배열로 인자를 전달 받을 수 있습니다. 
```js
// func.call(this, ...arguments) => func.apply(this, arguments)
func.apply(context, args)
```
* 인수가 이터러블 형태면 call을 유사 배열 형태라면 apply를 사용하면 됩니다. 
* apply를 사용하는게 더 빠릅니다. 
* 콜 포워딩의 예제
```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```
### 메서드 빌리기
```js
function hash() {
  alert( arguments.join() ); // Error: arguments.join is not a function
}

function hash() {
    // [] 배열에서 메서드를 빌려와서 사용합니다.
    alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
```
## 데코레이터와 함수 프로퍼티
* 데코레이터에서는  함수의 프로퍼티를 사용할 수 없습니다. 

## 함수 바인딩
* 객체의 메서드를 콜백으로 전달 `this`가 사라지는 문제가 생깁니다. 
### 사라진 `this`
```js
let user = {
    firstname: "John",
    sayHi() {
        alert(`Hello, ${this.firstName}~`);
    }
}

setTimeout(user,sayHi, 1000); // 'Hello undefine'

/// 해당 상황과 동일함
let f = user.sayHi;
setTimeout(f, 1000); // user 컨텍스트를 잃어버림
```
### 해결방법 레퍼
* 간단한 해결책은 레퍼 함수를 사용하는 방법
```js
let user = //...생략

setTimeout( function(){
    user.sayHi();
}, 1000);

setTimeout( () => user.sayHi(), 1000);
```
* 위의 코드가 동작하는 이유는 렉시컬 환경에서 user를 전달받아서 호출하기 때문입니다. 

## 부분 적용
* this 뿐만 아니라 인수도 바인딩 할 수 있습니다. 
* 아래 예제는 첫번째 인수만 고정시켜서 부분적용 한 예입니다. 
```js
function mul(a, b){
    return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) );
alert( double(4) );
alert( double(5) );
```

## 컨텍스트 없는 부분 적용
* 인수 일부는 고정하고 컨텍스트 this는 고정하고 싶지 않다면 어떻게 할까요?
* bind는 컨텍스트를 생략할 수 없습니다. 인수만 바인딩 해주는 partial 함수를 구현합니다. 
```js
function partial(func, ...argsBound){
    return function(...args){
        return func.call(this, ...argsBound, args)
    }
}
// 사용법
let user = {
    firstName: "John",
    say(time, phrase){
        alert(`[${time}] ${time.firstName}: ${phrase}!`);
    }
}

user.sayNow = partial(user.say, new Date().getHours() + ':' + new Data().getMinutes() );
```

### 화살표 함수 다시 살펴보기
* 화살표 함수를 사용하면 현재의 컨텍스트를 잃지 않습니다. 
* 화살표 함수에서 this에 접근하면 외부에서 값을 가져옵니다. 
* this가 없기 때문에 화살표 함수는 new와 함께 실행 할 수 없습니다. 
* 화살표 함수는 모든 인수에 접근할 수 있는 유사 배열 객체인 arguments를 지원하지 않습니다. 
### 화살표 함수 vs bind
* bind는 함수의 한정된 버전을 만듭니다. 
* 화살표 함수는 어떤것도 바인딩 시키지 않습니다. 
