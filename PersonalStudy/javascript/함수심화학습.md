# 나머지 매개변수와 전개 문법 
## 나머지 매개변수
* 인자로 나머지 매개변수를 받을 수 있습니다. 
```js
function sumAll(...args){
    let sum = 0;
    for (let arg of args) sum += arg;
    return sum;
}

alert( sum(1,2,3,4,5))

function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Julius Caesar

  // 나머지 인수들은 배열 titles의 요소가 됩니다.
  // titles = ["Consul", "Imperator"]
  alert( titles[0] ); // Consul
  alert( titles[1] ); // Imperator
  alert( titles.length ); // 2
}

showName("Julius", "Caesar", "Consul", "Imperator");
```

## arguments 변수
* arguments라는 특별한 유사 배열 객체를 이용하면 인덱스를 사용해서 모든 인수에 접근 할 수 있음
* 예전에는 나머지 매개변수가 지원되지 않았기 때문에 사용되었음 
```js
function showName(){
    alert( arguments.length );
    alert( arguments[0] );
    alert( arguments[1] );

    // arguments는 이터러블 객체이기 때문에
    // for(let arg of arguments) alert(arg); 를 사용해 인수를 나열할 수 있습니다.
}

showName("Julius", "Caesar");
```

## spread 문법
* 배열을 통째로 매개변수에 넘겨주는 방식 
```js
let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (전개 문법이 배열을 인수 목록으로 바꿔주었습니다.)
```
* 배열을 합칠 때 사용함
```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15 (0, arr, 2, arr2 순서로 합쳐집니다.)

let str = "Hello";

alert( [...str] ); // H,e,l,l,o
```

# 변수의 유효범위와 클로저
* 자바 스크립트는 함수 지향 언어이고 함수의 외 내부에서 생성된 변수의 유효범위를 알아봅니다. 
## 코드블록
* 코드 블록 {...} 안에서 선언번 변수는 블록 안에서만 사용 할 수 있습니다. 
* for, while, if 안에서도 블록안에서만 접근 가능합니다. 
```js
{
  // 지역 변수에 몇 가지 조작을 하면, 그 결과를 밖에선 볼 수 없습니다.

  let message = "Hello"; // 블록 내에서만 변숫값을 얻을 수 있습니다.

  alert(message); // Hello
}

alert(message); // ReferenceError: message is not defined
```
## 중첩함수
* 자바 스크립트에서는 쉽게 중첩 함수를 만들 수 있음
```js
function sayHiBye(firstName, lastName){
    // 헬퍼 중첩 함수
    function getFullName(){
        return firstName + " " + lastName;
    }

    alert( "Hello " + getFullName() );
    alert( "Bye, " + getFullName() );
}

```

## 렉시컬 환경
* https://ko.javascript.info/closure 
* 자바 스크립트에서 실행중인 함수, 코드블록, 스크립트 전체는 lexical Environment 라고 불리는 내부 숨긴 연관객체를 갖습니다.
* 렉시컬 환경 객체
  * 환경 레코드 - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체, this값과 같은 기타 정보도 여기에 저장됨 
  * 외브 렉시컬 환경에 대한 참조 - 외부 코드와 연관됨
### 변수
* 실제적으로 `변수`는 특수 내부 객체인 환경 레코드의 프로퍼티입니다. 
* 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있습니다. 
* 변수를 변경하면 환경 레코드의 프로퍼티가 변경됩니다. 
* 렉시컬 환경은 명시적으로 접근할 수 잇는 방안은 없습니다. 

### 함수 선언문
* 함수는 변수아 마찬가지로 값으로 저장됩니다. 
* 함수 선언문으로 선언한 함수는 일반 변수와 달리 초기화 된다는 점이 차이가 있습니다. 

### 내부와 외부 렉시컬 환경
* 함수를 호출해서 실행하면 새로운 렉시컬 환경이 자동으로 만들어 집니다.
* 새로운 렉시컬 환경에서 넘겨받은 매개변수와 함수의 지역변수가 저장 됩니다.
* 새로운 렉시컬 환경은 외부(전역) 렉시컬 환경의 참조를 가집니다. 
* 코드에서 변수에 접근할 때는 내부 렉시컬 환경부터 검색후에 외부 렉시컬 환경을 검색합니다. 
### 반환함수
* 아래의 예제에서 중첩 함수가 호출될 때 count가 function()에 없기 때문에 외부에서 count를 찾아서 적용합니다.
* 그래서 호출하면 호출 할 수록 count가 증가됩니다. 
* 예제
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

### 클로져
* 클로져는 외부 변수를 기억하고 외부 변수에 접근할 수 있는 함수를 의미함

### 최적화 프로세스
* V8 엔진에서는 최적화로 인해서 제거된 변수를 사용할 수 없는 부작용이 발생하기도 합니다. 

## 객체로서의 함수와 기명 함수 표현식
* 자바 스크립트에서는 함수를 호출이 가능한 객체로 취급합니다. 
* 함수에도 프로퍼티를 추가하거나 삭제할 수 있습니다. 
### `name` 프로퍼티
* `name` 프로퍼티를 사용하면 함수 이름을 가져올 수 있습니다. 
* `length` 함수의 매개 변수의 갯수를 반환함
  * 나머지 매개변수는 포함되지 않습니다. 
```js
function many(a, b, ...more) {}
alert(many.name; // many
alert(many.length); // 2
```
* length를 사용해서 핸들러 구축
```js
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// 사용자가 OK를 클릭한 경우, 핸들러 두 개를 모두 호출함
// 사용자가 Cancel을 클릭한 경우, 두 번째 핸들러만 호출함
ask("질문 있으신가요?", () => alert('OK를 선택하셨습니다.'), result => alert(result));
```
## 커스텀 프로퍼티
* 함수에 임의 프로퍼티를 추가해서 사용 할 수 있습니다. 

## 기명 함수 표현식 
* 기명 함수 표현식이란 이름이 있는 함수 표현식을 말함
* 내부에서 자기 자신을 호출 할 수 있음
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // func를 사용해서 자신을 호출합니다.
  }
};
```
* 만약에 기명 함수 표현식을 사용하지 않고 내부에서 함수를 재호출한다면
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // TypeError: sayHi is not a function
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // 중첩 sayHi 호출은 더 이상 불가능합니다!
```