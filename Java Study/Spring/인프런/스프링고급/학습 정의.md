## 스레드 로컬 주의 사항
* 쓰레드 로컬의 값을 사용 후에 제거하지 않고 그냥 두면 WAS(톰캣)처럼 스레드 풀을 사용하는 경우에는 심각한 문제가 발생 할 수 있습니다.
* 쓰레드가 재사용 될 때 이전에 사용한 값에 접근 할 수도 있습니다. 
  
## 좋은 설계란?
* 변경이 일어날 때 자연스럽게 드러납니다. 
* 기능을 모듈화하고 분리하여서 변경에 유연하게 대처합니다. 

## 단일 책임 원칙(SRP)
* 변경 지점을 한 곳을 모아서 변경에 쉽게 대처할 수 있는 구조로 만듭니다. 

## 프록시 패턴 vs 데코레이터 패턴
* 두 패턴의 기본 구현의 거의 동일 합니다. 그렇기에 의도에 따라서 구분하는 것이 좋습니다.
* 프록시 패턴의 의도는 `접근 제어`를 하기 위해서 대리자 제공
* 데코레이터 패턴의 의도는 객체에 추가 책임 기능을 동적으로 추가하는 작업 

## 리플렉션
* 리플렉션은 클래스나 메서드의 메타 정보를 사용해서 동적으로 호출하는 메서드를 변경 할 수 있습니다. 
```java
 @SneakyThrows
@Test
void reflection2(){
    // 클래스 정보
    var classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");
    Hello target = new Hello();
    dynamicCall(classHello.getMethod("callA"), target);

    dynamicCall(classHello.getMethod("callB"), target);

}

private void dynamicCall(Method m, Object target) throws InvocationTargetException, IllegalAccessException {
    log.info("start");
    Object result = m.invoke(target);
    log.info("result={}", result);
}
```

## 동적 프록시
* JDK 동적 프록시를 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 됩니다.
* 런타임에 자동을 생성됩니다. 
```java
// InvocationHandler 인터페이스를 구현합니다. 
// Object target은 동적 프록시가 호출 할 대상
// method.invoke(target, args) : 리플렉션을 사용해서 `target`인스턴스의 메서드를 실행합니다. 
@Slf4j
public class TimeInvocationHandler implements InvocationHandler {

    private final Object target;
    public TimeInvocationHandler(Object target){
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("TimeProxy 종료 resultTime={}", resultTime);
        return result;
    }
}

void dynamicA() {
    AInterface target = new AImpl();

    // 동적 프로시에 적용할 핸들러 로직입니다. 
    TimeInvocationHandler handler = new TimeInvocationHandler(target);

    // 동적 프록시는 java.lang.reflect.Proxy를 통해서 생성 할 수 있습니다.
    AInterface proxy = (AInterface)Proxy.newProxyInstance(AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler);
    proxy.call();
    log.info("targetClass={}", target.getClass());
    log.info("proxyClass={}", proxy.getClass());
}
```

## CGLIB(Code Generator Library)
* CGLIB는 바이트 코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리
* CGLIB를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들 수 있습니다. 
* CGLIB는 외부 라이브러리인데 스프링 프레임 워크에서 내부 소스 코드에 추가하였습니다. 
```java
@Slf4j
public class TimeMethodInterceptor implements MethodInterceptor {
    private final Object target;

    public TimeMethodInterceptor(Object target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();

        Object result = methodProxy.invoke(target, args);

        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("TimeProxy 종료 resultTime={}", resultTime);
        return result;
    }
}

// 사용 예제
 @Test
void cglib() {
    ConcreateService target = new ConcreateService();
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(ConcreateService.class);
    enhancer.setCallback(new TimeMethodInterceptor(target));
    var proxy = (ConcreateService)enhancer.create();
    log.info("targetClass={}", target.getClass());
    log.info("proxyClass={}", proxy.getClass());
    proxy.call();
}
```
### CGLIB 제약 사항
* 클래스 기반 프록시는 상속을 사용하기 때문에 다음과 같은 제약 사항을 가집니다.
  * 부모 클래스의 생성자를 체크 해야합니다. 
  * 클래스에 `final`이 붙으면 상속이 불가능합니다. 
  * 메서드에 `final`이 붙으면 해당 메서드를 오버라이딩 할 수 없습니다.

### 프록시 팩토리
* 스프링은 유사한 구체적인 기술들이 있을 때 통합해서 일관성있게 접근할 수있는 추상화된 기술을 제공합니다. 
* 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리라는 기능을 제공합니다. 
* 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 구체 클래스만 있다면 CGLIB를 사용합니다. 
  * 두 기능을 통합한 `Advice`라는 개념을 사용해서 `InvocationHandler`나 `MethodInterceptor`를 통합니다. 
```java
// Advice 클래스 객체
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

@Slf4j
public class TimeAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();
        // target 클래스를 호출 하고 그 결과를 받습니다.
        Object result = invocation.proceed();
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("TimeProxy 종료 resultTime={}", resultTime);
        return result;
    }
}

// 사용 예제
ServiceInterface target = new ServiceImpl();
ProxyFactory proxyFactory = new ProxyFactory(target);
proxyFactory.addAdvice(new TimeAdvice());
ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();
```