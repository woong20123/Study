## 스레드 로컬 주의 사항
* 쓰레드 로컬의 값을 사용 후에 제거하지 않고 그냥 두면 WAS(톰캣)처럼 스레드 풀을 사용하는 경우에는 심각한 문제가 발생 할 수 있습니다.
* 쓰레드가 재사용 될 때 이전에 사용한 값에 접근 할 수도 있습니다. 
  
## 좋은 설계란?
* 변경이 일어날 때 자연스럽게 드러납니다. 
* 기능을 모듈화하고 분리하여서 변경에 유연하게 대처합니다. 

## 단일 책임 원칙(SRP)
* 변경 지점을 한 곳을 모아서 변경에 쉽게 대처할 수 있는 구조로 만듭니다. 

## 프록시 패턴 vs 데코레이터 패턴
* 두 패턴의 기본 구현의 거의 동일 합니다. 그렇기에 의도에 따라서 구분하는 것이 좋습니다.
* 프록시 패턴의 의도는 `접근 제어`를 하기 위해서 대리자 제공
* 데코레이터 패턴의 의도는 객체에 추가 책임 기능을 동적으로 추가하는 작업 

## 리플렉션
* 리플렉션은 클래스나 메서드의 메타 정보를 사용해서 동적으로 호출하는 메서드를 변경 할 수 있습니다. 
```java
 @SneakyThrows
@Test
void reflection2(){
    // 클래스 정보
    var classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");
    Hello target = new Hello();
    dynamicCall(classHello.getMethod("callA"), target);

    dynamicCall(classHello.getMethod("callB"), target);

}

private void dynamicCall(Method m, Object target) throws InvocationTargetException, IllegalAccessException {
    log.info("start");
    Object result = m.invoke(target);
    log.info("result={}", result);
}
```

## 동적 프록시
* JDK 동적 프록시를 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 됩니다.
* 런타임에 자동을 생성됩니다. 
```java
// InvocationHandler 인터페이스를 구현합니다. 
// Object target은 동적 프록시가 호출 할 대상
// method.invoke(target, args) : 리플렉션을 사용해서 `target`인스턴스의 메서드를 실행합니다. 
@Slf4j
public class TimeInvocationHandler implements InvocationHandler {

    private final Object target;
    public TimeInvocationHandler(Object target){
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("TimeProxy 종료 resultTime={}", resultTime);
        return result;
    }
}

void dynamicA() {
    AInterface target = new AImpl();

    // 동적 프로시에 적용할 핸들러 로직입니다. 
    TimeInvocationHandler handler = new TimeInvocationHandler(target);

    // 동적 프록시는 java.lang.reflect.Proxy를 통해서 생성 할 수 있습니다.
    AInterface proxy = (AInterface)Proxy.newProxyInstance(AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler);
    proxy.call();
    log.info("targetClass={}", target.getClass());
    log.info("proxyClass={}", proxy.getClass());
}
```