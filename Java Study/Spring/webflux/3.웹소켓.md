## 웹소켓 소개
웹소켓 프로토콜 RFC 6455은 단일 연결을 통해서 클라이언트와 서버간의 전이중 양방향 통신 채널을 설정하는 표준화된 방법을 제공합니다.  
HTTP 프로토콜과 다른 TCP 프로토콜이지만 포트 80 및 433을 사용하고 기본 방화벽 규칙을 재사용할 수 있도록 HTTP 통해서 작동 할 수 있도록 합니다.  
웹 소켓의 interaction은 HTTP 업그레이드 헤더를 사용해서 웹 소켓 프로토콜로 전환하는 HTTP 요청으로 시작됩니다.  
```yaml
# 업그레이드 헤더 사용하는 요청
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket      # updrage 헤더 사용
Connection: Upgrade     # 업그레이드 연결 사용
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080

일반적인 200상태 코드 대신 WebSocket을 지원하는 서버는 다음과 유사한 출력을 반환합니다.

# 서버 응답
```yaml
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```
핸드 쉐이크 후에 HTTP 업그레이드 요청의 기반이 되는 TCP 소켓은 클라이언트와 서버 모두 계속해서 메시지를 보내고 받을 수 있도록 열려 있습니다.  
WebSocket의 작동 방식에 대한 완전한 소개는 이 문서의 범위를 벗어납니다. RFC 6455, HTML5의 WebSocket 장 또는 웹에 있는 많은 소개 및 자습서를 참조하십시오.  
참고로 WebSocket 서버가 웹 서버 뒤에서 실행 중인 경우 WebSocket 업그레이드 요청을 WebSocket 서버에 전달 하도록 구성 할 수 있습니다.  
마찬가지로 애플리케이션이 클라우드 환경에서 실행되는 경우 WebSocket 지원과 관련된 클라우드 제공자의 지침을 확인 하십시오

### HTTP Vs WebSocket
WebSocket이 HTTP와 호환되도록 설계되고 HTTP 요청으로 시작하더라도 두 프로토콜이 매우 다른 아키텍처와 애플리케이션 프로그래밍 모델로 이어진다는 점을 이해하는 것이 중요합니다.  
HTTP 및 REST에서 애플리케이션은 많은 URL로 만들어 집니다. 애플리케이션과 상호 작용하기 위해 클라이언트는 요청-응답 스타일의 해당 URL을 엑세스 합니다.  
서버는 HTTP URL, 메소드 및 헤더를 기반으로 적절한 헨들러로 요청을 라우팅 합니다.  
대조적으로 WebSocket에는 일반덕으로 초기 연결을 위한 URL이 하나만 있습니다. 
모든 애플리케이션 메시지는 동일한 TCP 연결에서 흐릅니다. 이것은 완전히 다른 비동기식 이벤트 기반 메시징 아키텍처를 나타냅니다.  
웹 소켓은 HTTP와 달리 메시지 내용에 의미 체께를 규정하지 않는 저수준 전송 프로토콜이기도 합니다.  
즉 클라이언트와 서버가 메시지 의미 체꼐에 동의하지 않는한 메시지를 라우팅하거나 처리할 방법이 없습니다.  
웹 소켓 클라이언트와 서버는 HTTP 핸드 쉐이크 요청의 Sec-WebSocket-Protocol 헤더를 통해 더 높은 수준의 메시징 프로토콜 사용을 협상할 수 있습니다. 이것이 없다면 자신만의 규칙을 만들어야 합니다.  

### 웹 소켓을 사용해야 하는 경우
웹 소켓은 웹 페이지를 동적이고 대화식으로 만들 수 있습니다. 그러나 많은 경우 Ajax와 HTTP 스트리밍 또는 긴 폴링 조합이 간단하고 효과적인 솔루션을 제공할 수 있습니다.  
예를 들어서 뉴스, 메일 소셜 피드는 동적으로 업데이트 되어야 하지만 몇 분마다 업데이트 하는 것이 괜찮을 수 있습니다. 
반면에 협업, 게임 및 금융 앱은 실시간에 훨씬 더 가까워야 합니다.  
대기 시간 만이 유일한 결정 요인이 아닙니다. 메시지 양이 비교적 적은 경우 HTTP 스트리밍 또는 폴링은 효과적인 솔루션을 제공할 수 있습니다. 
웹 소켓을 사용하는 가장 좋은 사례는 낮은 대기 시간, 높은 빈도 및 높은 볼륨의 조합입니다.  
인터넷을 제어할 수 없는 제한 적인 프록시는 웹소켓의 연결을 방해 할 수 있습니다. 
이는 방화벽 내에서 내부 응용 프로그램에 웹 소켓을 사용하는 것이 공개 응용 프로그램에 사용 하는 것보다 더 간단한 결정임을 의미합니다. 

## WebSocket API
Spring 프레임워크는 웹 소켓 메시지를 처리하는 클라이언트 및 서버 측 애플리케이션을 작성하는데 사용 할 수 있는 웹 소켓 API를 제공합니다.  

### 서버
웹 소켓 서버를 생성하려면 먼저 WebSocketHandler를 생성할 수 있습니다.
```java
import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketSession;

public class MyWebSocketHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        // ...
    }
}
```
그런 다음에 URL에 매핑 할 수 있습니다.  
```java
@Configuration
class WebConfig {

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> map = new HashMap<>();
        map.put("/path", new MyWebSocketHandler());
        int order = -1; // before annotated controllers

        return new SimpleUrlHandlerMapping(map, order);
    }
}
```
웹 플럭스를 사용하는 경우 더이상 할 일이 없습니다.
웹 플럭스 구성을 사용하지 않는 경우에는 아래와 같이 선언 해야 합니다.  
```java
@Configuration
class WebConfig {

    // ...

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}
```

### WebSocketHandler