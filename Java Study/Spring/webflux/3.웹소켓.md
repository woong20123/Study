## 원본 문서

## 웹소켓 소개
웹소켓 프로토콜 RFC 6455은 단일 연결을 통해서 클라이언트와 서버간의 전이중 양방향 통신 채널을 설정하는 표준화된 방법을 제공합니다.  
HTTP 프로토콜과 다른 TCP 프로토콜이지만 포트 80 및 433을 사용하고 기본 방화벽 규칙을 재사용할 수 있도록 HTTP 통해서 작동 할 수 있도록 합니다.  
웹 소켓의 interaction은 HTTP 업그레이드 헤더를 사용해서 웹 소켓 프로토콜로 전환하는 HTTP 요청으로 시작됩니다.  
```yaml
# 업그레이드 헤더 사용하는 요청
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket      # updrage 헤더 사용
Connection: Upgrade     # 업그레이드 연결 사용
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080

일반적인 200상태 코드 대신 WebSocket을 지원하는 서버는 다음과 유사한 출력을 반환합니다.

# 서버 응답
```yaml
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```
핸드 쉐이크 후에 HTTP 업그레이드 요청의 기반이 되는 TCP 소켓은 클라이언트와 서버 모두 계속해서 메시지를 보내고 받을 수 있도록 열려 있습니다.  
WebSocket의 작동 방식에 대한 완전한 소개는 이 문서의 범위를 벗어납니다. RFC 6455, HTML5의 WebSocket 장 또는 웹에 있는 많은 소개 및 자습서를 참조하십시오.  
참고로 WebSocket 서버가 웹 서버 뒤에서 실행 중인 경우 WebSocket 업그레이드 요청을 WebSocket 서버에 전달 하도록 구성 할 수 있습니다.  
마찬가지로 애플리케이션이 클라우드 환경에서 실행되는 경우 WebSocket 지원과 관련된 클라우드 제공자의 지침을 확인 하십시오

### HTTP Vs WebSocket
WebSocket이 HTTP와 호환되도록 설계되고 HTTP 요청으로 시작하더라도 두 프로토콜이 매우 다른 아키텍처와 애플리케이션 프로그래밍 모델로 이어진다는 점을 이해하는 것이 중요합니다.  
HTTP 및 REST에서 애플리케이션은 많은 URL로 만들어 집니다. 애플리케이션과 상호 작용하기 위해 클라이언트는 요청-응답 스타일의 해당 URL을 엑세스 합니다.  
서버는 HTTP URL, 메소드 및 헤더를 기반으로 적절한 헨들러로 요청을 라우팅 합니다.  
대조적으로 WebSocket에는 일반덕으로 초기 연결을 위한 URL이 하나만 있습니다. 
모든 애플리케이션 메시지는 동일한 TCP 연결에서 흐릅니다. 이것은 완전히 다른 비동기식 이벤트 기반 메시징 아키텍처를 나타냅니다.  
웹 소켓은 HTTP와 달리 메시지 내용에 의미 체께를 규정하지 않는 저수준 전송 프로토콜이기도 합니다.  
즉 클라이언트와 서버가 메시지 의미 체꼐에 동의하지 않는한 메시지를 라우팅하거나 처리할 방법이 없습니다.  
웹 소켓 클라이언트와 서버는 HTTP 핸드 쉐이크 요청의 Sec-WebSocket-Protocol 헤더를 통해 더 높은 수준의 메시징 프로토콜 사용을 협상할 수 있습니다. 이것이 없다면 자신만의 규칙을 만들어야 합니다.  

### 웹 소켓을 사용해야 하는 경우
웹 소켓은 웹 페이지를 동적이고 대화식으로 만들 수 있습니다. 그러나 많은 경우 Ajax와 HTTP 스트리밍 또는 긴 폴링 조합이 간단하고 효과적인 솔루션을 제공할 수 있습니다.  
예를 들어서 뉴스, 메일 소셜 피드는 동적으로 업데이트 되어야 하지만 몇 분마다 업데이트 하는 것이 괜찮을 수 있습니다. 
반면에 협업, 게임 및 금융 앱은 실시간에 훨씬 더 가까워야 합니다.  
대기 시간 만이 유일한 결정 요인이 아닙니다. 메시지 양이 비교적 적은 경우 HTTP 스트리밍 또는 폴링은 효과적인 솔루션을 제공할 수 있습니다. 
웹 소켓을 사용하는 가장 좋은 사례는 낮은 대기 시간, 높은 빈도 및 높은 볼륨의 조합입니다.  
인터넷을 제어할 수 없는 제한 적인 프록시는 웹소켓의 연결을 방해 할 수 있습니다. 
이는 방화벽 내에서 내부 응용 프로그램에 웹 소켓을 사용하는 것이 공개 응용 프로그램에 사용 하는 것보다 더 간단한 결정임을 의미합니다. 

## WebSocket API
Spring 프레임워크는 웹 소켓 메시지를 처리하는 클라이언트 및 서버 측 애플리케이션을 작성하는데 사용 할 수 있는 웹 소켓 API를 제공합니다.  

### 서버
웹 소켓 서버를 생성하려면 먼저 WebSocketHandler를 생성할 수 있습니다.
```java
import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketSession;

public class MyWebSocketHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        // ...
    }
}
```
그런 다음에 URL에 매핑 할 수 있습니다.  
```java
@Configuration
class WebConfig {

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> map = new HashMap<>();
        map.put("/path", new MyWebSocketHandler());
        int order = -1; // before annotated controllers

        return new SimpleUrlHandlerMapping(map, order);
    }
}
```
웹 플럭스를 사용하는 경우 더이상 할 일이 없습니다.
웹 플럭스 구성을 사용하지 않는 경우에는 아래와 같이 선언 해야 합니다.  
```java
@Configuration
class WebConfig {

    // ...

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}
```

### WebSocketHandler
WebSocketHandler의 핸들 메서드는 WebSocketSession을 취하고 세션의 어플리케이션 처리가 완료 되었을 때 Mono<Void>를 반환합니다.  
Session은 인바운드 및 아웃 바운드에 대한 두가지 스트림을 통해서 처리됩니다.

|WebSocketSession method|설명|
|:--|:--|
|Flux<WebSocketMessage> receive()|인바운드 메시지 스트림에 대한 접근을 제공하고 연결이 닫힐 떄 완료 됩니다. |
|Mono<Void> send(Publisher<WebSocketMessage>)|아웃 바운드 메시지에 대한 소스를 가져오고 메시지를 작성하고 소스가 완료되면 Mono<Void>를 반환합니다.|
WebSocketHandler는 인바운드 및 아웃 바운드 스트림을 통합 흐름으로 구성하고 해당 흐름의 완료를 반영하는 Mono<Void>를 반환 해야 합니다.  
애플리케이션 요구 사항에 따라 다음과 같은 경우 통합 흐름이 완료됩니다.   
* 인바운드 또는 아웃 바운드 메시지 스트림이 완료 됩니다. 
* 인바운드 스트림은 완료되지만( 연결이 닫힘) 그 동안 아웃 바운드 스트림은 무한합니다. 
* 특정 지점에서 WebSocketSession의 close 메서드를 호출 합니다. 
인바운드 및 아웃 바운드 메시지 스트림이 함꼐 구성되면 Reactive Streams이 활동 종료 신호를 보내기 때문에 연결 확인을 할 필요가 없습니다.  
인바운드 스트림은 완료 또는 오류 신호를 수신하고 아웃 바운드 스트림은 취소 신호를 수신합니다.  
핸들러의 가장 기본적은 구현은 인바운드 스트림을 처리하는 것입니다 다음 예제는 그러한 구현을 보여줍니다.
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        return session.receive()        // 이곳에서 인바운드 스트림을 접근합니다.            
                .doOnNext(message -> {  
                    // ...              // 전달 받은 메시지로 무언가 처리를 진행합니다. 
                })
                .concatMap(message -> {
                    // ...              // 메시지 콘텐츠를 사용하는 중첩된 비동기 작업을 수행합니다. 
                })
                .then();                // 수신이 완료되면 완료되는 Mono<Void>를 반환합니다. 
    }
}
```
중첩된 비공기 작업의 경우 풀링된 데이터 버퍼를 사용하는 서버(예 네티)에서 message.retain()을 호출해야 할 수 있습니다.  
그렇지 않으면 데이터를 읽을 기회가 있기 전에 데이터 버퍼가 해제 될 수 있습니다.  
자세한 배경 정보는 데이터 버퍼 및 코덱을 참조하세요.  

다음 구현은 인바운드 및 아웃바운드 스트림을 결합합니다.  
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {

        Flux<WebSocketMessage> output = session.receive()  // 인바운드 메시지 스트림을 처리합니다.
                .doOnNext(message -> {
                    // ...
                })
                .concatMap(message -> {
                    // ...
                })
                .map(value -> session.textMessage("Echo " + value));  // combined flow을 생성하는 아웃바문드 메시지를 

        return session.send(output);  // receive 받는 동안 완료되지 않은 Mono<Void>를 반환 합니다.
    }
}
```
인바운드 및 아웃 바운드 스트림은 다음 예와 같이 독립적이며 완료를 위해서만 결합 될 수 있습니다.
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {

        Mono<Void> input = session.receive()  // 인바운드 메시지 스트림을 처리합니다.
                .doOnNext(message -> {
                    // ...
                })
                .concatMap(message -> {
                    // ...
                })
                .then();

        Flux<String> source = ... ; 
        Mono<Void> output = session.send(source.map(session::textMessage));  //  전달할 메시지를 전송합니다.

        return Mono.zip(input, output).then();  // 스트림에 참여하고 스트림이 끝날 때 완료 되는 Mono<Void>를 반환합니다. 
    }
}
```

### DataBuffer
DataBuffer는 웹플럭스의 바이버 버퍼를 나타냅니다.  
Spring Core의 레퍼런스에는 데이터 버퍼 및 코덱에 대한 자세한 내용이 있습니다.  
* https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers  

### Handshake


## 참고 사이트
spring boot와 코틀린, RSocket
* https://spring.io/guides/tutorials/spring-webflux-kotlin-rsocket/