## 원본 문서
https://docs.spring.io/spring-framework/docs/current/reference/html/


## 웹소켓 소개
웹소켓 프로토콜 RFC 6455은 단일 연결을 통해서 클라이언트와 서버간의 전이중 양방향 통신 채널을 설정하는 표준화된 방법을 제공합니다.  
HTTP 프로토콜과 다른 TCP 프로토콜이지만 포트 80 및 433을 사용하고 기본 방화벽 규칙을 재사용할 수 있도록 HTTP 통해서 작동 할 수 있도록 합니다.  
웹 소켓의 interaction은 HTTP 업그레이드 헤더를 사용해서 웹 소켓 프로토콜로 전환하는 HTTP 요청으로 시작됩니다.  
```yaml
# 업그레이드 헤더 사용하는 요청
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket      # updrage 헤더 사용
Connection: Upgrade     # 업그레이드 연결 사용
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080

일반적인 200상태 코드 대신 WebSocket을 지원하는 서버는 다음과 유사한 출력을 반환합니다.

# 서버 응답
```yaml
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```
핸드 쉐이크 후에 HTTP 업그레이드 요청의 기반이 되는 TCP 소켓은 클라이언트와 서버 모두 계속해서 메시지를 보내고 받을 수 있도록 열려 있습니다.  
WebSocket의 작동 방식에 대한 완전한 소개는 이 문서의 범위를 벗어납니다. RFC 6455, HTML5의 WebSocket 장 또는 웹에 있는 많은 소개 및 자습서를 참조하십시오.  
참고로 WebSocket 서버가 웹 서버 뒤에서 실행 중인 경우 WebSocket 업그레이드 요청을 WebSocket 서버에 전달 하도록 구성 할 수 있습니다.  
마찬가지로 애플리케이션이 클라우드 환경에서 실행되는 경우 WebSocket 지원과 관련된 클라우드 제공자의 지침을 확인 하십시오

### HTTP Vs WebSocket
WebSocket이 HTTP와 호환되도록 설계되고 HTTP 요청으로 시작하더라도 두 프로토콜이 매우 다른 아키텍처와 애플리케이션 프로그래밍 모델로 이어진다는 점을 이해하는 것이 중요합니다.  
HTTP 및 REST에서 애플리케이션은 많은 URL로 만들어 집니다. 애플리케이션과 상호 작용하기 위해 클라이언트는 요청-응답 스타일의 해당 URL을 엑세스 합니다.  
서버는 HTTP URL, 메소드 및 헤더를 기반으로 적절한 헨들러로 요청을 라우팅 합니다.  
대조적으로 WebSocket에는 일반덕으로 초기 연결을 위한 URL이 하나만 있습니다. 
모든 애플리케이션 메시지는 동일한 TCP 연결에서 흐릅니다. 이것은 완전히 다른 비동기식 이벤트 기반 메시징 아키텍처를 나타냅니다.  
웹 소켓은 HTTP와 달리 메시지 내용에 의미 체께를 규정하지 않는 저수준 전송 프로토콜이기도 합니다.  
즉 클라이언트와 서버가 메시지 의미 체꼐에 동의하지 않는한 메시지를 라우팅하거나 처리할 방법이 없습니다.  
웹 소켓 클라이언트와 서버는 HTTP 핸드 쉐이크 요청의 Sec-WebSocket-Protocol 헤더를 통해 더 높은 수준의 메시징 프로토콜 사용을 협상할 수 있습니다. 이것이 없다면 자신만의 규칙을 만들어야 합니다.  

### 웹 소켓을 사용해야 하는 경우
웹 소켓은 웹 페이지를 동적이고 대화식으로 만들 수 있습니다. 그러나 많은 경우 Ajax와 HTTP 스트리밍 또는 긴 폴링 조합이 간단하고 효과적인 솔루션을 제공할 수 있습니다.  
예를 들어서 뉴스, 메일 소셜 피드는 동적으로 업데이트 되어야 하지만 몇 분마다 업데이트 하는 것이 괜찮을 수 있습니다. 
반면에 협업, 게임 및 금융 앱은 실시간에 훨씬 더 가까워야 합니다.  
대기 시간 만이 유일한 결정 요인이 아닙니다. 메시지 양이 비교적 적은 경우 HTTP 스트리밍 또는 폴링은 효과적인 솔루션을 제공할 수 있습니다. 
웹 소켓을 사용하는 가장 좋은 사례는 낮은 대기 시간, 높은 빈도 및 높은 볼륨의 조합입니다.  
인터넷을 제어할 수 없는 제한 적인 프록시는 웹소켓의 연결을 방해 할 수 있습니다. 
이는 방화벽 내에서 내부 응용 프로그램에 웹 소켓을 사용하는 것이 공개 응용 프로그램에 사용 하는 것보다 더 간단한 결정임을 의미합니다. 

## WebSocket API
Spring 프레임워크는 웹 소켓 메시지를 처리하는 클라이언트 및 서버 측 애플리케이션을 작성하는데 사용 할 수 있는 웹 소켓 API를 제공합니다.  

### 서버
웹 소켓 서버를 생성하려면 먼저 WebSocketHandler를 생성할 수 있습니다.
```java
import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketSession;

public class MyWebSocketHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        // ...
    }
}
```
그런 다음에 URL에 매핑 할 수 있습니다.  
```java
@Configuration
class WebConfig {

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> map = new HashMap<>();
        map.put("/path", new MyWebSocketHandler());
        int order = -1; // before annotated controllers

        return new SimpleUrlHandlerMapping(map, order);
    }
}
```
웹 플럭스를 사용하는 경우 더이상 할 일이 없습니다.
웹 플럭스 구성을 사용하지 않는 경우에는 아래와 같이 선언 해야 합니다.  
```java
@Configuration
class WebConfig {

    // ...

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}
```

### WebSocketHandler
WebSocketHandler의 핸들 메서드는 WebSocketSession을 취하고 세션의 어플리케이션 처리가 완료 되었을 때 Mono<Void>를 반환합니다.  
Session은 인바운드 및 아웃 바운드에 대한 두가지 스트림을 통해서 처리됩니다.

|WebSocketSession method|설명|
|:--|:--|
|Flux<WebSocketMessage> receive()|인바운드 메시지 스트림에 대한 접근을 제공하고 연결이 닫힐 떄 완료 됩니다. |
|Mono<Void> send(Publisher<WebSocketMessage>)|아웃 바운드 메시지에 대한 소스를 가져오고 메시지를 작성하고 소스가 완료되면 Mono<Void>를 반환합니다.|
WebSocketHandler는 인바운드 및 아웃 바운드 스트림을 통합 흐름으로 구성하고 해당 흐름의 완료를 반영하는 Mono<Void>를 반환 해야 합니다.  
애플리케이션 요구 사항에 따라 다음과 같은 경우 통합 흐름이 완료됩니다.   
* 인바운드 또는 아웃 바운드 메시지 스트림이 완료 됩니다. 
* 인바운드 스트림은 완료되지만( 연결이 닫힘) 그 동안 아웃 바운드 스트림은 무한합니다. 
* 특정 지점에서 WebSocketSession의 close 메서드를 호출 합니다. 
인바운드 및 아웃 바운드 메시지 스트림이 함꼐 구성되면 Reactive Streams이 활동 종료 신호를 보내기 때문에 연결 확인을 할 필요가 없습니다.  
인바운드 스트림은 완료 또는 오류 신호를 수신하고 아웃 바운드 스트림은 취소 신호를 수신합니다.  
핸들러의 가장 기본적은 구현은 인바운드 스트림을 처리하는 것입니다 다음 예제는 그러한 구현을 보여줍니다.
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        return session.receive()        // 이곳에서 인바운드 스트림을 접근합니다.            
                .doOnNext(message -> {  
                    // ...              // 전달 받은 메시지로 무언가 처리를 진행합니다. 
                })
                .concatMap(message -> {
                    // ...              // 메시지 콘텐츠를 사용하는 중첩된 비동기 작업을 수행합니다. 
                })
                .then();                // 수신이 완료되면 완료되는 Mono<Void>를 반환합니다. 
    }
}
```
중첩된 비공기 작업의 경우 풀링된 데이터 버퍼를 사용하는 서버(예 네티)에서 message.retain()을 호출해야 할 수 있습니다.  
그렇지 않으면 데이터를 읽을 기회가 있기 전에 데이터 버퍼가 해제 될 수 있습니다.  
자세한 배경 정보는 데이터 버퍼 및 코덱을 참조하세요.  

다음 구현은 인바운드 및 아웃바운드 스트림을 결합합니다.  
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {

        Flux<WebSocketMessage> output = session.receive()  // 인바운드 메시지 스트림을 처리합니다.
                .doOnNext(message -> {
                    // ...
                })
                .concatMap(message -> {
                    // ...
                })
                .map(value -> session.textMessage("Echo " + value));  // combined flow을 생성하는 아웃바문드 메시지를 

        return session.send(output);  // receive 받는 동안 완료되지 않은 Mono<Void>를 반환 합니다.
    }
}
```
인바운드 및 아웃 바운드 스트림은 다음 예와 같이 독립적이며 완료를 위해서만 결합 될 수 있습니다.
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {

        Mono<Void> input = session.receive()  // 인바운드 메시지 스트림을 처리합니다.
                .doOnNext(message -> {
                    // ...
                })
                .concatMap(message -> {
                    // ...
                })
                .then();

        Flux<String> source = ... ; 
        Mono<Void> output = session.send(source.map(session::textMessage));  //  전달할 메시지를 전송합니다.

        return Mono.zip(input, output).then();  // 스트림에 참여하고 스트림이 끝날 때 완료 되는 Mono<Void>를 반환합니다. 
    }
}
```

### DataBuffer
DataBuffer는 웹플럭스의 바이트 버퍼를 나타냅니다.  
Spring Core의 레퍼런스에는 데이터 버퍼 및 코덱에 대한 자세한 내용이 있습니다.  
* https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers  
이해해야 할 중요 내용은 Netty같은 일부 서버에서 바이트 버퍼가 풀링 되고 참조 카운트되며 메모리 릭을 방지하기 위해서 사용 후에 해제되어야 한다는 점입니다.  
Netty에서 실행 할 때 애플리케이션은 해제 되지 않도록 입력 데이터 버퍼를 유지하는 경우 `DataBufferUtils.retain(dataBuffer)`를 사용해야 하고  
이후 버퍼를 사용한 후에 `DataBufferUtils.release(dataBuffer)`를 사용해야 합니다.

### Handshake
WebSocketHandlerAdapter는 WebSocketService에 위임합니다. 일반적으로 HandshakeWebSocketService은 WebSocket에 대한 기본 검사를 수행한 다음 사용중인 서버에 대해 `RequestUpgradeStrategy`을 수행하는 HandshakeWebSocketService의 인스턴스입니다.  
현재 Reactor Netty, Tomcat, Jetty, Undertow에 대한 기본 제공 지원이 있습니다.  
`HandshakeWebSocketService`는 `WebSocketSession`의 속성을 삽입 할 수 있도록 `Predicate<String>`을 설정할 수 있는 `sessionAttributePredicate`를 노출합니다.  

### Server Configation
각 서버에 대한 RequestUpgradeStrategy는 기본 웹 소켓 서버 엔진에 특정한 구성을 노출합니다.  
WebFlux Java구성을 사용 할 때 WebFlux 구성의 해당 섹션에 표시된 대로 이러한 속성을 사용자 정의로 설정할 수 있습니다.  
그렇지 않으면 WebFLux 구성을 사용하지 않는 경우 아래를 사용하십시오.  
```java
@Configuration
class WebConfig {

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter(webSocketService());
    }

    @Bean
    public WebSocketService webSocketService() {
        TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(0L);
        return new HandshakeWebSocketService(strategy);
    }
}
```
사용 가능한 옵션을 보려면 서버의 업그레이드 전략을 확인하십시오. 현재는 Tomcat과 Jetty만 이러한 옵션을 제공합니다.  

### CORS
CORS를 구성하고 WebSocket 엔드 포인트에 대한 엑세스를 제한하는 가장 쉬운 방법은 `WebSocketHandler`가 `CorsConfigurationSource`를  
구현하고  allowed origins, headers, 기타 세부 정보가 포함된 `CorsConfiguration`를 반환하도록 하는 것입니다. 
그렇게 할 수 없는 경우 `SimpleUrlHandler`에서 `corsConfigurations` 속성을 설정하여 URL 패턴으로 CORS 설정을 지정할 수 도 있습니다.
둘 다 지정하면 `CorsConfiguration`에서 결합 방법을 사용하여 결합 됩니다.
#### CORS란?(Cross-origin resource sharing)
같은 도메인이 아닌 곳에 데이터 요청이 왔을 때 보안상으로 막혀 있음.
이것을 해결 하기 위해서 `Access-Control-Allow-Origin`에 접근 가능한 권한을 등록하는 작업이 필요 
설명 : https://developer.mozilla.org/ko/docs/Web/HTTP/CORS 

### Client
생략...
```java
WebSocketClient client = new ReactorNettyWebSocketClient();

URI url = new URI("ws://localhost:8080/path");
client.execute(url, session ->
        session.receive()
                .doOnNext(System.out::println)
                .then());
```

## RSocket
이번 섹션에서는 스트링 프레임워크의 RSocket 프로토콜 지원에 대해서 설명합니다.  

### 개요
RSocket은 TCP, 웹소켓 및 등등의 multiplex duplex 통신을 위한 응용 프로그램 프로토콜 입니다.
다음 interaction 모델중 하나 사용:
* `Request-Response` : 하나의 메시지를 보내고 하나를 받습니다. 
* `Request-Stream` : 하나의 메시지를 보내고 메시지 스트림을 받습니다. 
* `Channel` : 양방향으로 메시지 스트림 보내기
* `Fire-and-Forget` : 단방향 메시지를 보냅니다. 

초기 연결이 이루어지면 `클라이언트`와 `서버`의 구분이 없어집니다. 양쪽 모두 위의 interaction 중 하나를 시작할 수 있습니다.
이것이 프로토콜에서 참여자를 `requester`와 `responder`라고 부르고 interactione들을 `request stream` 또는 단순히 `request`
라고 부르는 이유입니다.  

다음은 RSocket 프로토콜의 주요 기능 및 이점입니다. 
* 네트워크 범위에서 Reactive Steams 의미론
  * Request-Stream 및 Channel 같은 streaming 요청의 경우 요청자와 응답장 사이를 back pressure(배압) 신호로 이동합니다.
  * 요청자가 소스에서 응답자의 속도를 늦추도록 하여 네트워크 계층 혼잡 제어에 대한 의존도를 줄이고 네크워크 수준 또는 모든 수준에서 버퍼링의 필요성을 줄입니다. 
* Request throttling(조절)
  * `LEASE` 프레임을 따서 'Leasing'이라고 불리우는 기능이 있습니다.
  * 다른 세션에 주어진 시간동안 허용하는 총 요청 수를 제한할 수 있습니다.
  * `leases`는 주기적으로 갱신 됩니다.
* Session resumption(재개)
  * 이것은 연결 손실을 위해서 설계되었고 일부 상태를 유지해야 합니다. 
  * state management는 응용 프로그램에 대해서 Transparency(세부사항을 숨겨서 보이지 않게 함)하며 배압과 잘 작동합니다. 
  * 가능한 경우 producer를 중지하고 state required를 줄일 수 있습니다. 
* 대용량 메시지의 단편화 및 재조립
* Keepalive (heartbeats).
RSocket은 여러 언어로 구현되어 있습니다. Java라이브러리는 Project Reactor와 전송을 위한 Reactor Netty를 기반으로 합니다.  
즉 Reactive Streams Publisher의 신호가 Network가 RSocket을 통해서 Transparency하게 전파됩니다. 

### The Protocol
RSocket의 이점 중 하나는 유선에서 잘 정의된 동작과 일부 프로토콜 확장과 함께 읽기 쉬운 사양이 있다는 것입니다.  
따라서 언어 구현 및 상위 수준 프레임워크 API와 상관 없이 사양을 읽는 것이 좋습니다.  
이 섹션에서는 이부 컨텍스트를 설정하기 위한 간략한 개요를 제공합니다.

#### Connecting
처음에 클라이언트는 TCP 또는 WebSocket과 같은 저수준 스트리밍 전송을 통해서 서버에 연결하고 `SETUP` 프레임을 서버에 전송하여 연결 매개변수를 설정합니다.  
서버는 `SETUP`프레임을 거부 할 수 있지만 일반적으로 leasing semantics을 사용하지 않는 한 전송(클라이언트) 및 수신(서버) 후에 양쪽 모두 요청을 시작 할 수 있습니다.  
leasing semantics를 사용하는 경우 요청을 허용하기 위해서 다른 쪽을 에서 LEASE 프레임을 기다려야 합니다.  

#### Making Requests
연결이 설정되면 양측은 REQUEST_RESPONSE, REQUEST_STREAM, REQUEST_CHANNEL, REQUEST_FNF 프레임 중 하나를 통해서 요청을 시작 할 수 있습니다.   
각 프레임은 Requester로부터 Responder에게 하나의 메시지를 전달합니다.  


## 참고 사이트
spring boot와 코틀린, RSocket
* https://spring.io/guides/tutorials/spring-webflux-kotlin-rsocket/

### RSocket vs gRPC
* https://blog.purpler.net/rsocket-vs-grpc/
* 벤치 마크 : https://dzone.com/articles/rsocket-vs-grpc-benchmark 

### RPC(Remote Procedure Call)란
* 참조 : https://co-no.tistory.com/28

### RSocket
https://rsocket.io/about/protocol 
* spring boot rsocket 예제 : https://spring.io/blog/2020/03/02/getting-started-with-rsocket-spring-boot-server 
* baeldung RSocket : https://www.baeldung.com/rsocket 