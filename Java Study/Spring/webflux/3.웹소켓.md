## 원본 문서
https://docs.spring.io/spring-framework/docs/current/reference/html/


## 웹소켓 소개
웹소켓 프로토콜 RFC 6455은 단일 연결을 통해서 클라이언트와 서버간의 전이중 양방향 통신 채널을 설정하는 표준화된 방법을 제공합니다.  
HTTP 프로토콜과 다른 TCP 프로토콜이지만 포트 80 및 433을 사용하고 기본 방화벽 규칙을 재사용할 수 있도록 HTTP 통해서 작동 할 수 있도록 합니다.  
웹 소켓의 interaction은 HTTP 업그레이드 헤더를 사용해서 웹 소켓 프로토콜로 전환하는 HTTP 요청으로 시작됩니다.  
```yaml
# 업그레이드 헤더 사용하는 요청
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket      # updrage 헤더 사용
Connection: Upgrade     # 업그레이드 연결 사용
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080

일반적인 200상태 코드 대신 WebSocket을 지원하는 서버는 다음과 유사한 출력을 반환합니다.

# 서버 응답
```yaml
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```
핸드 쉐이크 후에 HTTP 업그레이드 요청의 기반이 되는 TCP 소켓은 클라이언트와 서버 모두 계속해서 메시지를 보내고 받을 수 있도록 열려 있습니다.  
WebSocket의 작동 방식에 대한 완전한 소개는 이 문서의 범위를 벗어납니다. RFC 6455, HTML5의 WebSocket 장 또는 웹에 있는 많은 소개 및 자습서를 참조하십시오.  
참고로 WebSocket 서버가 웹 서버 뒤에서 실행 중인 경우 WebSocket 업그레이드 요청을 WebSocket 서버에 전달 하도록 구성 할 수 있습니다.  
마찬가지로 애플리케이션이 클라우드 환경에서 실행되는 경우 WebSocket 지원과 관련된 클라우드 제공자의 지침을 확인 하십시오

### HTTP Vs WebSocket
WebSocket이 HTTP와 호환되도록 설계되고 HTTP 요청으로 시작하더라도 두 프로토콜이 매우 다른 아키텍처와 애플리케이션 프로그래밍 모델로 이어진다는 점을 이해하는 것이 중요합니다.  
HTTP 및 REST에서 애플리케이션은 많은 URL로 만들어 집니다. 애플리케이션과 상호 작용하기 위해 클라이언트는 요청-응답 스타일의 해당 URL을 엑세스 합니다.  
서버는 HTTP URL, 메소드 및 헤더를 기반으로 적절한 헨들러로 요청을 라우팅 합니다.  
대조적으로 WebSocket에는 일반덕으로 초기 연결을 위한 URL이 하나만 있습니다. 
모든 애플리케이션 메시지는 동일한 TCP 연결에서 흐릅니다. 이것은 완전히 다른 비동기식 이벤트 기반 메시징 아키텍처를 나타냅니다.  
웹 소켓은 HTTP와 달리 메시지 내용에 의미 체께를 규정하지 않는 저수준 전송 프로토콜이기도 합니다.  
즉 클라이언트와 서버가 메시지 의미 체꼐에 동의하지 않는한 메시지를 라우팅하거나 처리할 방법이 없습니다.  
웹 소켓 클라이언트와 서버는 HTTP 핸드 쉐이크 요청의 Sec-WebSocket-Protocol 헤더를 통해 더 높은 수준의 메시징 프로토콜 사용을 협상할 수 있습니다. 이것이 없다면 자신만의 규칙을 만들어야 합니다.  

### 웹 소켓을 사용해야 하는 경우
웹 소켓은 웹 페이지를 동적이고 대화식으로 만들 수 있습니다. 그러나 많은 경우 Ajax와 HTTP 스트리밍 또는 긴 폴링 조합이 간단하고 효과적인 솔루션을 제공할 수 있습니다.  
예를 들어서 뉴스, 메일 소셜 피드는 동적으로 업데이트 되어야 하지만 몇 분마다 업데이트 하는 것이 괜찮을 수 있습니다. 
반면에 협업, 게임 및 금융 앱은 실시간에 훨씬 더 가까워야 합니다.  
대기 시간 만이 유일한 결정 요인이 아닙니다. 메시지 양이 비교적 적은 경우 HTTP 스트리밍 또는 폴링은 효과적인 솔루션을 제공할 수 있습니다. 
웹 소켓을 사용하는 가장 좋은 사례는 낮은 대기 시간, 높은 빈도 및 높은 볼륨의 조합입니다.  
인터넷을 제어할 수 없는 제한 적인 프록시는 웹소켓의 연결을 방해 할 수 있습니다. 
이는 방화벽 내에서 내부 응용 프로그램에 웹 소켓을 사용하는 것이 공개 응용 프로그램에 사용 하는 것보다 더 간단한 결정임을 의미합니다. 

## WebSocket API
Spring 프레임워크는 웹 소켓 메시지를 처리하는 클라이언트 및 서버 측 애플리케이션을 작성하는데 사용 할 수 있는 웹 소켓 API를 제공합니다.  

### 서버
웹 소켓 서버를 생성하려면 먼저 WebSocketHandler를 생성할 수 있습니다.
```java
import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketSession;

public class MyWebSocketHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        // ...
    }
}
```
그런 다음에 URL에 매핑 할 수 있습니다.  
```java
@Configuration
class WebConfig {

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> map = new HashMap<>();
        map.put("/path", new MyWebSocketHandler());
        int order = -1; // before annotated controllers

        return new SimpleUrlHandlerMapping(map, order);
    }
}
```
웹 플럭스를 사용하는 경우 더이상 할 일이 없습니다.
웹 플럭스 구성을 사용하지 않는 경우에는 아래와 같이 선언 해야 합니다.  
```java
@Configuration
class WebConfig {

    // ...

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}
```

### WebSocketHandler
WebSocketHandler의 핸들 메서드는 WebSocketSession을 취하고 세션의 어플리케이션 처리가 완료 되었을 때 Mono<Void>를 반환합니다.  
Session은 인바운드 및 아웃 바운드에 대한 두가지 스트림을 통해서 처리됩니다.

|WebSocketSession method|설명|
|:--|:--|
|Flux<WebSocketMessage> receive()|인바운드 메시지 스트림에 대한 접근을 제공하고 연결이 닫힐 떄 완료 됩니다. |
|Mono<Void> send(Publisher<WebSocketMessage>)|아웃 바운드 메시지에 대한 소스를 가져오고 메시지를 작성하고 소스가 완료되면 Mono<Void>를 반환합니다.|
WebSocketHandler는 인바운드 및 아웃 바운드 스트림을 통합 흐름으로 구성하고 해당 흐름의 완료를 반영하는 Mono<Void>를 반환 해야 합니다.  
애플리케이션 요구 사항에 따라 다음과 같은 경우 통합 흐름이 완료됩니다.   
* 인바운드 또는 아웃 바운드 메시지 스트림이 완료 됩니다. 
* 인바운드 스트림은 완료되지만( 연결이 닫힘) 그 동안 아웃 바운드 스트림은 무한합니다. 
* 특정 지점에서 WebSocketSession의 close 메서드를 호출 합니다. 
인바운드 및 아웃 바운드 메시지 스트림이 함꼐 구성되면 Reactive Streams이 활동 종료 신호를 보내기 때문에 연결 확인을 할 필요가 없습니다.  
인바운드 스트림은 완료 또는 오류 신호를 수신하고 아웃 바운드 스트림은 취소 신호를 수신합니다.  
핸들러의 가장 기본적은 구현은 인바운드 스트림을 처리하는 것입니다 다음 예제는 그러한 구현을 보여줍니다.
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        return session.receive()        // 이곳에서 인바운드 스트림을 접근합니다.            
                .doOnNext(message -> {  
                    // ...              // 전달 받은 메시지로 무언가 처리를 진행합니다. 
                })
                .concatMap(message -> {
                    // ...              // 메시지 콘텐츠를 사용하는 중첩된 비동기 작업을 수행합니다. 
                })
                .then();                // 수신이 완료되면 완료되는 Mono<Void>를 반환합니다. 
    }
}
```
중첩된 비공기 작업의 경우 풀링된 데이터 버퍼를 사용하는 서버(예 네티)에서 message.retain()을 호출해야 할 수 있습니다.  
그렇지 않으면 데이터를 읽을 기회가 있기 전에 데이터 버퍼가 해제 될 수 있습니다.  
자세한 배경 정보는 데이터 버퍼 및 코덱을 참조하세요.  

다음 구현은 인바운드 및 아웃바운드 스트림을 결합합니다.  
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {

        Flux<WebSocketMessage> output = session.receive()  // 인바운드 메시지 스트림을 처리합니다.
                .doOnNext(message -> {
                    // ...
                })
                .concatMap(message -> {
                    // ...
                })
                .map(value -> session.textMessage("Echo " + value));  // combined flow을 생성하는 아웃바문드 메시지를 

        return session.send(output);  // receive 받는 동안 완료되지 않은 Mono<Void>를 반환 합니다.
    }
}
```
인바운드 및 아웃 바운드 스트림은 다음 예와 같이 독립적이며 완료를 위해서만 결합 될 수 있습니다.
```java
class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono<Void> handle(WebSocketSession session) {

        Mono<Void> input = session.receive()  // 인바운드 메시지 스트림을 처리합니다.
                .doOnNext(message -> {
                    // ...
                })
                .concatMap(message -> {
                    // ...
                })
                .then();

        Flux<String> source = ... ; 
        Mono<Void> output = session.send(source.map(session::textMessage));  //  전달할 메시지를 전송합니다.

        return Mono.zip(input, output).then();  // 스트림에 참여하고 스트림이 끝날 때 완료 되는 Mono<Void>를 반환합니다. 
    }
}
```

### DataBuffer
DataBuffer는 웹플럭스의 바이트 버퍼를 나타냅니다.  
Spring Core의 레퍼런스에는 데이터 버퍼 및 코덱에 대한 자세한 내용이 있습니다.  
* https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers  
이해해야 할 중요 내용은 Netty같은 일부 서버에서 바이트 버퍼가 풀링 되고 참조 카운트되며 메모리 릭을 방지하기 위해서 사용 후에 해제되어야 한다는 점입니다.  
Netty에서 실행 할 때 애플리케이션은 해제 되지 않도록 입력 데이터 버퍼를 유지하는 경우 `DataBufferUtils.retain(dataBuffer)`를 사용해야 하고  
이후 버퍼를 사용한 후에 `DataBufferUtils.release(dataBuffer)`를 사용해야 합니다.

### Handshake
WebSocketHandlerAdapter는 WebSocketService에 위임합니다. 일반적으로 HandshakeWebSocketService은 WebSocket에 대한 기본 검사를 수행한 다음 사용중인 서버에 대해 `RequestUpgradeStrategy`을 수행하는 HandshakeWebSocketService의 인스턴스입니다.  
현재 Reactor Netty, Tomcat, Jetty, Undertow에 대한 기본 제공 지원이 있습니다.  
`HandshakeWebSocketService`는 `WebSocketSession`의 속성을 삽입 할 수 있도록 `Predicate<String>`을 설정할 수 있는 `sessionAttributePredicate`를 노출합니다.  

### Server Configation
각 서버에 대한 RequestUpgradeStrategy는 기본 웹 소켓 서버 엔진에 특정한 구성을 노출합니다.  
WebFlux Java구성을 사용 할 때 WebFlux 구성의 해당 섹션에 표시된 대로 이러한 속성을 사용자 정의로 설정할 수 있습니다.  
그렇지 않으면 WebFLux 구성을 사용하지 않는 경우 아래를 사용하십시오.  
```java
@Configuration
class WebConfig {

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter(webSocketService());
    }

    @Bean
    public WebSocketService webSocketService() {
        TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(0L);
        return new HandshakeWebSocketService(strategy);
    }
}
```
사용 가능한 옵션을 보려면 서버의 업그레이드 전략을 확인하십시오. 현재는 Tomcat과 Jetty만 이러한 옵션을 제공합니다.  

### CORS
CORS를 구성하고 WebSocket 엔드 포인트에 대한 엑세스를 제한하는 가장 쉬운 방법은 `WebSocketHandler`가 `CorsConfigurationSource`를  
구현하고  allowed origins, headers, 기타 세부 정보가 포함된 `CorsConfiguration`를 반환하도록 하는 것입니다. 
그렇게 할 수 없는 경우 `SimpleUrlHandler`에서 `corsConfigurations` 속성을 설정하여 URL 패턴으로 CORS 설정을 지정할 수 도 있습니다.
둘 다 지정하면 `CorsConfiguration`에서 결합 방법을 사용하여 결합 됩니다.
#### CORS란?(Cross-origin resource sharing)
같은 도메인이 아닌 곳에 데이터 요청이 왔을 때 보안상으로 막혀 있음.
이것을 해결 하기 위해서 `Access-Control-Allow-Origin`에 접근 가능한 권한을 등록하는 작업이 필요 
설명 : https://developer.mozilla.org/ko/docs/Web/HTTP/CORS 

### Client
생략...
```java
WebSocketClient client = new ReactorNettyWebSocketClient();

URI url = new URI("ws://localhost:8080/path");
client.execute(url, session ->
        session.receive()
                .doOnNext(System.out::println)
                .then());
```

## RSocket
이번 섹션에서는 스트링 프레임워크의 RSocket 프로토콜 지원에 대해서 설명합니다.  

### 개요
RSocket은 TCP, 웹소켓 및 등등의 multiplex duplex 통신을 위한 응용 프로그램 프로토콜 입니다.
다음 interaction 모델중 하나 사용:
* `Request-Response` : 하나의 메시지를 보내고 하나를 받습니다. 
* `Request-Stream` : 하나의 메시지를 보내고 메시지 스트림을 받습니다. 
* `Channel` : 양방향으로 메시지 스트림 보내기
* `Fire-and-Forget` : 단방향 메시지를 보냅니다. 

초기 연결이 이루어지면 `클라이언트`와 `서버`의 구분이 없어집니다. 양쪽 모두 위의 interaction 중 하나를 시작할 수 있습니다.
이것이 프로토콜에서 참여자를 `requester`와 `responder`라고 부르고 interactione들을 `request stream` 또는 단순히 `request`
라고 부르는 이유입니다.  

다음은 RSocket 프로토콜의 주요 기능 및 이점입니다. 
* 네트워크 범위에서 Reactive Steams 의미론
  * Request-Stream 및 Channel 같은 streaming 요청의 경우 요청자와 응답장 사이를 back pressure(배압) 신호로 이동합니다.
  * 요청자가 소스에서 응답자의 속도를 늦추도록 하여 네트워크 계층 혼잡 제어에 대한 의존도를 줄이고 네크워크 수준 또는 모든 수준에서 버퍼링의 필요성을 줄입니다. 
* Request throttling(조절)
  * `LEASE` 프레임을 따서 'Leasing'이라고 불리우는 기능이 있습니다.
  * 다른 세션에 주어진 시간동안 허용하는 총 요청 수를 제한할 수 있습니다.
  * `leases`는 주기적으로 갱신 됩니다.
* Session resumption(재개)
  * 이것은 연결 손실을 위해서 설계되었고 일부 상태를 유지해야 합니다. 
  * state management는 응용 프로그램에 대해서 Transparency(세부사항을 숨겨서 보이지 않게 함)하며 배압과 잘 작동합니다. 
  * 가능한 경우 producer를 중지하고 state required를 줄일 수 있습니다. 
* 대용량 메시지의 단편화 및 재조립
* Keepalive (heartbeats).
RSocket은 여러 언어로 구현되어 있습니다. Java라이브러리는 Project Reactor와 전송을 위한 Reactor Netty를 기반으로 합니다.  
즉 Reactive Streams Publisher의 신호가 Network가 RSocket을 통해서 Transparency하게 전파됩니다. 

### The Protocol
RSocket의 이점 중 하나는 유선에서 잘 정의된 동작과 일부 프로토콜 확장과 함께 읽기 쉬운 사양이 있다는 것입니다.  
따라서 언어 구현 및 상위 수준 프레임워크 API와 상관 없이 사양을 읽는 것이 좋습니다.  
이 섹션에서는 이부 컨텍스트를 설정하기 위한 간략한 개요를 제공합니다.

#### Connecting
처음에 클라이언트는 TCP 또는 WebSocket과 같은 저수준 스트리밍 전송을 통해서 서버에 연결하고 `SETUP` 프레임을 서버에 전송하여 연결 매개변수를 설정합니다.  
서버는 `SETUP`프레임을 거부 할 수 있지만 일반적으로 leasing semantics을 사용하지 않는 한 전송(클라이언트) 및 수신(서버) 후에 양쪽 모두 요청을 시작 할 수 있습니다.  
leasing semantics를 사용하는 경우 요청을 허용하기 위해서 다른 쪽을 에서 LEASE 프레임을 기다려야 합니다.  

#### Making Requests
연결이 설정되면 양측은 REQUEST_RESPONSE, REQUEST_STREAM, REQUEST_CHANNEL, REQUEST_FNF 프레임 중 하나를 통해서 요청을 시작 할 수 있습니다.   
각 프레임은 Requester로부터 Responder에게 하나의 메시지를 전달합니다.  
그러면 응답자는 응답 메시지와 함께 PAYLOAD 프레임을 반환 할 수 있으며 REQUEST_CHANNEL의 경우 더 많은 요청 메시지와 함꼐 PAYLOAD 프레임을 보낼 수 있습니다.  
요청이 Request-Stream 및 Channel과 같은 메시지 스트림을 포함하는 경우 응답자는 요청자의 Demand 신호를 존중해야합니다.  
Demand는 메시지 수로 표현됩니다. 초기 Demand는 REQUEST_STREAM 및 REQUEST_CHANNEL 프레임에 지정됩니다.  
후속 요구는 REQUEST_N 프레임을 통해 신호됩니다.  
각 측에서 METADATA_PUSH 프레임을 통해 개별 요청이 아니라 전체 연결과 관련된 메타데이터 알림을 보낼 수 있습니다.  

#### Message Format
RSocket 메시지에는 데이터와 메타데이터가 포함됩니다. 메타 데이터는 경로, 보안 토큰 등을 보내는데 사용 할 수 있습니다.
데이터와 메타 데이터는 서로 다른 형식을 지정할 수 있습니다.  
각각에 대한 MIME 유형은 SETUP 프레임에서 선언되고 지정된 연결의 모든 요청에 적용됩니다.  
모든 메시지가 메타데이터를 가질 수 있지만 일반적으로 경로와 같은 메타 데이터는 요청별로 이루어지므로 요청의 첫번째 메시지에만 포함됩니다. 

##### MIME 타입
https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types 

### Java Implementation
RSocket에 대한 JAVA 구현은 Project Reactor를 기반으로 합니다. TCP 및 WebSocket의 전송은 Reactor Netty를 기반으로 합니다.  
Reactive Streams 라이브러리인 Reactor는 프로토콜 구현 작업을 단순화합니다.  
애플리케이션의 경우 선언적 연산자 및 투명한 배압 지원과 함께 Flux 및 Mono를 사용하는 것이 자연스럽습니다.  
RSocket Java의 API는 의도적으로 최소한 기본만 제공합니다. 
프로토콜 기능에 중점을 두고 애플리케이션 프로그래밍 모델을 더 높은 수준의 독립적인 관심사로 남겨 둡니다.  
io.rsocket.RSocket은 아래의 내용으로 4가지 요청 상호 작용 유형을 모델링합니다. 
* `Mono` : 단일 메시지에 대한 규약
* `Flux` : 스트림 메시지 
* `io.rsocket.Payload` : 바이터 버퍼로 데이터 및 메타 데이터를 엑세스 할 수 있는 실제 메시지 
RSocket 계약은 대칭적으로 사용 됩니다. 요청을 위한 애플리케이션에는 요청을 수행할 RSocket이 제공됩니다.  
응답을 위한 어플리케이션에서는 요청을 처리하기 위한 RSocket을 구현합니다.  

이것은 완벽한 소개를 의미 하지 않습니다. 대부분의 경우 Spring 애플리케이션은 API를 직접 사용 할 필요가 없습니다. 
그러나 스프링에 독립적인 RSocket을 보거나 실험하는 것은 중요 할 수 있습니다.  
https://github.com/rsocket/rsocket-java/tree/master/rsocket-examples

### Spring Support
`spring-messaging` 에는 다음이 포함됩니다. 
* RSocketRequester - 데이터와 메타데이터 인코딩/디코딩을 io.rsocket.RSocket로 사용해여 요청하는 fluent API
* Annotated Responders - 응답을 위한 handler method 애노테이션 `@MessageMapping`
spring-web 모듈에는 Jackson CBOR/JSON 및 RSocket 애플리케이션에 필요할 가능성이 있는 ProtoBuf와 같은 인코더 및 디코더 구현이 포함됩니다.  
또한 효율적인 경로 일치를 위해서 연결 할 수 있는 `PathPatternParser`도 포함합니다.  
Spring Boot 2.2는 WebFlux 서버에서 TCP 또는 WebSocket을 통해서 RSocket 서버를 지원합니다.  
RSocketRequester.Builder 및 RSocketStrategies에 대한 클라이언트 지원 및 자동 구성도 있습니다.  
Spring Security 5.2는 RSocket 지원을 제공합니다.  
Spring Integration 5.2는 RSocket 클라이언트 및 서버와 상호 작용하기 위한 인바운드 및 아웃바운드 게이트웨이를 제공합니다. 자세한 내용은 Spring 통합 참조 매뉴얼을 참조하십시오.  
Spring Cloud Gateway는 RSocket 연결을 지원합니다.  
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#messaging.rsocket


## RSocketRequester
`RSocketRequester`는 RSocket 요청을 수행하는 fluent API를 제공하여 low level 데이터 버퍼 대신 데이터 및 메타 데이터에 대한 개체를 수락하고 반환합니다.  
클라이언트에서 요청을 만들거나 서버에서 요청을 만들기 위해서 양쪽에서 사용 할 수 있습니다.  
### Client Requester
클라이언트 측에서 `RSocketRequester`를 얻으려면 연결 설정과 함꼐 RSocket SETUP 프레임을 보내는 것과 관련된 연결을 수행해야 합니다.  
RSocketRequester는 SETUP 프레임에 대한 연결 설정을 포함하여 io.rsocket.core.RSocketConnector를 준비하는 데 도움이 되는 빌더를 제공합니다.  
```java
RSocketRequester requester = RSocketRequester.builder().tcp("localhost", 7000);

URI url = URI.create("https://example.org:8080/rsocket");
RSocketRequester requester = RSocketRequester.builder().webSocket(url);
```
위의 항목은 즉시 연결되지 않고 요청이 있으면 공유 연결이 transparently하게 설정되어 사용됩니다.  

#### Connection Setup
RSocketRequester.Builder는 초기 SETUP 프레임을 사용자 지정하기 위해 다음을 제공합니다.
* dataMimeType(MimeType) - 연결 데이터의 MIME 유형을 설정합니다.
* metadataMimeType(MimeType) — 연결에서 메타데이터의 MIME 유형을 설정합니다.
* setupData(Object)  -   SETUP에 포함할 데이터입니다.
* setupRoute(String, Object…​) —  SETUP에 포함할 메타데이터의 경로.
* setupMetadata(Object, MimeType) —  SETUP에 포함할 기타 메타데이터.

데이터의 경우 기본 MIME 유형은 첫 번째로 구성된 디코더에서 파생됩니다. 메타데이터의 경우 기본 MIME 유형은 요청당 여러 메타데이터 값과 MIME 유형 쌍을 허용하는 복합 메타데이터입니다. 일반적으로 둘 다 변경할 필요가 없습니다.  
SETUP 프레임의 데이터 및 메타데이터는 선택 사항입니다. 서버 측에서는 @ConnectMapping 메서드를 사용하여 연결 시작과 SETUP 프레임의 내용을 처리할 수 있습니다. 메타데이터는 연결 수준 보안에 사용될 수 있습니다.

#### Strategies
RSocketRequester.Builder는 요청자의 설정을 셋팅하기 위해서 위해 RSocketStrategies를 전달 받습니다.  
데이터 및 메타데이터 값의 (역)직렬화를 위한 인코더 및 디코더를 제공하려면 이것을 사용해야 합니다.  
기본적으로 String, byte[], ByteBuffer에 대한 spring-core의 기본 코덱만 등록됩니다.  
spring-web을 추가하면 다음과 같이 등록할 수 있는 더 많은 항목에 액세스할 수 있습니다.
```java
RSocketStrategies strategies = RSocketStrategies.builder()
    .encoders(encoders -> encoders.add(new Jackson2CborEncoder()))
    .decoders(decoders -> decoders.add(new Jackson2CborDecoder()))
    .build();

RSocketRequester requester = RSocketRequester.builder()
    .rsocketStrategies(strategies)
    .tcp("localhost", 7000);
```
`RSocketStrategies`는 재사용을 위해 설계되었습니다. 일부 시나리오에서는 예를 들어 클라이언트와 서버가 동일한 애플리케이션에 있는 경우 Spring 구성에서 선언하는 것이 바람직할 수 있습니다.  

#### Client Responders
`RSocketRequester.Builder` 를 사용하여 서버의 요청에 대한 응답자를 구성할 수 있습니다.
서버에서 사용되는 동일한 인프라를 기반으로 클라이언트 측 응답에 Annotation을 사용할 수 있습니다. 
그러나 다음과 같이 설정 할 수도 있습니다.
```java
RSocketStrategies strategies = RSocketStrategies.builder()
    .routeMatcher(new PathPatternRouteMatcher())  // spring-web이 있는 경우 효율적인 PathPatternRouteMatcher를 사용하십시오.경로 일치.
    .build();

SocketAcceptor responder =
    RSocketMessageHandler.responder(strategies, new ClientHandler());   // @MessageMaping 및/또는 @ConnectMapping 메서드를 사용하여 클래스에서 응답자 만들기

RSocketRequester requester = RSocketRequester.builder()
    .rsocketConnector(connector -> connector.acceptor(responder))  // Register the responder.
    .tcp("localhost", 7000);
```
위의 내용는 클라이언트 응답자의 프로그래밍 방식 등록을 위해 설계된 바로 가기 일뿐입니다. 
다음과 같이 직접 적용 할 수도 있습니다. 
```java
ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

RSocketRequester requester = RSocketRequester.builder()
    .rsocketConnector(connector -> connector.acceptor(handler.responder()))
    .tcp("localhost", 7000);
```
위의 경우 RSocketMessageHandler에서 setHandlerPredicate를 사용하여 클라이언트 응답자를 감지하는 다른 전략으로 전환해야 할 수도 있습니다. @RSocketClientResponder 대 기본 @Controller와 같은 사용자 정의 주석을 기반으로 합니다.  
이는 클라이언트와 서버가 있거나 동일한 응용 프로그램에 여러 클라이언트가 있는 시나리오에서 필요합니다.  

### Server Requester
서버에서 연결된 클라이언트로 요청 하는 것은 requster를 얻는 것을 의미합니다.  
Annotated Responders에서 @ConnectMapping 및 @MessageMapping 메서드는 RSocketRequester 인수를 지원합니다.
이것으로 연결 요청자에 엑세스하는데 사용합니다.  
@ConnectMapping 메소드는 본질적으로 요청이 시작되기 전에 처리되어야 하는 SETUP 프레임의 핸들러임을 명심하십시오.  
따라서 첫 요청을 처리구문에서 분리 해야합니다. 
```java
@ConnectMapping
Mono<Void> handle(RSocketRequester requester) {
    requester.route("status").data("5")
        .retrieveFlux(StatusReport.class)
        .subscribe(bar -> {  // 처리와 무관하게 비동기로 요청 시작
            // ...
        });
    return ...  // 처리 및 반환 완료
}
```

### Requests
클라이언트 또는 서버 Requester는 다음과 같이 요청 할 수 있습니다.  
```java
ViewBox viewBox = ... ;

Flux<AirportLocation> locations = requester.route("locate.radars.within")  // 요청 메시지의 메타 데이터 안에 포함할 경로 지정
        .data(viewBox)  // 요청 메시지에 대한 데이터를 제공합니다. 
        .retrieveFlux(AirportLocation.class);  // 예상되는 응답을 선언 합니다. 
```
인터렉션 타입은 입력 및 출력의 카디널리티에서 암시적으로 결정됩니다.  
위의 예는 하나의 값이 전송되고 값의 스트림이 수신되기 때문에 Request-Stream 입니다.  
대부분의 경우 입력 및 출력 선택이 RSocket 상호 작용 유형과 응답자가 예상하는 입력 및 출력 유형과 일치하는 한 문제가 없습니다.  
유효하지 않은 조합의 유일한 예는 다대일입니다.  
data(Object) 메서드는 또한 Flux 및 Mono를 포함한 모든 Reactive Streams Publisher와 ReactiveAdapterRegistry에 등록된 값의 다른 생산자를 허용합니다.  
동일한 유형의 값을 생성하는 Flux와 같은 다중 값 게시자의 경우 오버로드된 데이터 방법 중 하나를 사용하여 모든 요소에 대한 유형 검사 및 인코더 조회를 방지하는 것이 좋습니다.  
```java
data(Object producer, Class<?> elementClass);
data(Object producer, ParameterizedTypeReference<?> elementTypeRef);
```
data(Object) 단계는 선택 사항입니다. 데이터를 보내지 않는 요청의 경우 추가하지 않아도 됩니다.  
```java
Mono<AirportLocation> location = requester.route("find.radar.EWR"))
    .retrieveMono(AirportLocation.class);
```
복합 메타데이터(기본값)를 사용하고 등록된 인코더에서 값을 지원하는 경우 추가 메타데이터 값을 추가할 수 있습니다.  
```java
String securityToken = ... ;
ViewBox viewBox = ... ;
MimeType mimeType = MimeType.valueOf("message/x.rsocket.authentication.bearer.v0");

Flux<AirportLocation> locations = requester.route("locate.radars.within")
        .metadata(securityToken, mimeType)
        .data(viewBox)
        .retrieveFlux(AirportLocation.class);
```
Fire-and-Forget의 경우 Mono<Void>를 반환하는 send() 메서드를 사용합니다. Mono는 메시지가 성공적으로 전송되었음을 나타낼 뿐 처리되었다는 의미는 아닙니다.  
Metadata-Push의 경우 Mono<Void> 반환 값과 함께 sendMetadata() 메서드를 사용합니다.  

### Annotated Responders

## 참고 사이트
spring boot와 코틀린, RSocket
* https://spring.io/guides/tutorials/spring-webflux-kotlin-rsocket/

### RSocket vs gRPC
* https://blog.purpler.net/rsocket-vs-grpc/
* 벤치 마크 : https://dzone.com/articles/rsocket-vs-grpc-benchmark 

### RPC(Remote Procedure Call)란
* 참조 : https://co-no.tistory.com/28

### RSocket
https://rsocket.io/about/protocol 
* spring boot rsocket 예제 : https://spring.io/blog/2020/03/02/getting-started-with-rsocket-spring-boot-server 
* baeldung Spring-boot RSocket : [https://www.baeldung.com/rsocket ](https://www.baeldung.com/spring-boot-rsocket)
* 브로드 캐스트 방법 : https://stackoverflow.com/questions/68072641/is-it-possible-to-broadcast-with-rsockets