# 서문
### 카프카를 디자인하게 된 이유
* 링크드인에서 내부 인프라 시스템 구축을 위해서 시작됨
* 실시간 어플리케이션과 데이터 흐름을 지원하기 위해서 
* 카프카는 메시지 스트림을 읽게 해주는 메시징 시스템
  * 전통적인 메시징 시스템 : ActiveMQ, RabbitMQ, IBM's MQSeries
### 전통적인 메시징 시스템과 다른 점
1. 카프카는 클러스터로 실행되며 확장 가능한 분산 시스템으로 실행됩니다.
   * 데이터 스트림 처리를 위해 탄력적으로 확장할 수 있음
2. 원하는 충분한 시간동안 데이터를 저장하기 위해 만들어진 스토리지 시스템입니다. 
   * 신뢰성 있는 데이터 전송을 보장, 서로 다른 시스템의 연결 계층으로 사용
3. 대부분의 메시징 시스템은 단순히 메시지 전달만 초점을 가지지만 카프카는 스트림 프로세싱 능력이 있음

# 1장 카프카 흝어 보기
### 메시지 발행과 구독하기(publish/subscribe)
* 메시지 발행/구독 시스템에서는 데이터를 발생자가 직접 구독자에게 보내지 않음
* 대신 발행자가 메시지를 발행/구독 시스템에 전송하면 구독자가 특정 부류의 메시지를 구독할 수 있게됨
* 이때 발생된 메시지를 저장하고 중계하는 역활을 브로커가 수행
## 카프카 살펴보기
* 카프카는 `분산 커밋 로그` 및 `분산 스트리밍 플랫폼`이라고 부름
* DB의 commit 로그와 비슷하게 카프카 데이터에 대해서 지속해서 저장하고 읽을 수 있습니다.
* 시스템 장애와 확장에 따른 성능 저하를 방지하기 위해서 데이터를 분산합니다 .
### 카프카 메시지와 배치
* 카프카의 데이터의 기본단위 메시지이며 바이트 배열로 관리됨 
  * DB의 row와 record와 비교됩니다. 
* 메시지에는 key라는 메타 데이터가 포함 될 수 있음
* 메시지는 topic으로 분류되는 partition에 저장되며 일관된 해시값으로 키를 생성해서 분류됩니다. 
* 카프카는 효율성을 위해서 여러 개의 메시지를 모아서 batch형태로 파티션에 수록함
* 배치 크기가 클수록 단위시간당 처리되는 메시지는 많아지지만 전송시간은 길어집니다. 
* 추가로 배치는 데이터 압축이 되므로 더 효율적으로 동작합니다. 
### 스키마
* 카프카의 메시지는 바이트 배열로 처리되지만 내용의 이해가 쉽도록 스키마를 사용 할 수 있습니다.
* 여러 표준 형식이 있지만 간단한 방식으로 JSON과 XML을 주로 사용합니다. 
* 그러나 강력한 기능을 사용하려면 아파치 Avro를 사용합니다. 
  * 아파치 Avro는 하둡을 위해서 개발된 직렬화 프레임 워크임
* 카프카에서는 일관된 데이터 형식이 중요함
  * 메시지 쓰기 작업가 읽기 작업의 분류 필요
  * 카프카는 잘 정의된 스키마를 공유 리포지토리에 저장해서 사용 할 수 있음
### 토픽과 파티션
* 참조 사이트: https://kafka.apache.org/intro 
* 토픽(topic)은 DB의 테이블이나 FS의 폴더와 비슷함
* 토픽은 여러개의 파티션으로 구성될 수 있으며 메시지는 파티션에 끝에 추가됨
* 각 파티션은 서로 다른 서버에 분산 적재 될 수 있음(I/O 분산을 통한 성능 향상)
  * 수평적 확장 가능
* 카프카에서 스트림이란 프로듀서(producer)로 부터 컨슈머(consumer)로 이동되는 연속적인 데이터를 말함
### 프로듀서와 컨슈머(생산자와 소비자)
* 카프카의 클라이언트는 시스템의 사용자이며 프로듀서나 컨슈머라는 두가지 형태를 지닙니다. 
* 프로듀서는 새로운 메시지를 생성하며 발행자/작성자라고 합니다.
  * 프로듀서는 특정 토픽을 대상으로 메시지를 생성하며 어떤 파티션에 수록되는지 관여하지 않습니다. 
  * 특수하게 파티션을 지정할 때는 메시지 키를 사용합니다. 
* 컨슈머는 메시지를 읽으며 다른 발행/구독 시스템에서 구독자/독자라고 합니다. 
* 컨슈머는 메시지가 생성된 순서대로 읽으며 오프셋을 유지함 
  * 오프셋은 지속적으로 증가하는 정수값입니다. 
  * 주키퍼나 카프카에서는 각 파티션에서 마지막에 읽은 메시지의 오프셋을 저장하므로 메시지 읽기를 중단하더라도 그 다음 메시지를 읽을 수 있음
* 컨슈머는 컨슈머 그룹의 멤버로 동작합니다. 
* 컨슈머 그룹은 하나의 토픽을 소비하기 위해서 같은 그룹의 여러 컨슈머화 함께 동작합니다. 
* 한 토픽의 각 파티션은 하나의 컨슈머만 소비할 수 있습니다. 
  * 이처럼 컨슈머가 특정 파티션에 대응 되는 것을 파티션 소유권이라고 합니다. 
  * 이방식을 사용하면 대량의 메시지를 갖는 토픽을 수평적으로 확장합니다.
  * 만약에 컨슈머가 자신의 파티션의 메시지를 읽는 데 실패하더라도 같은 그룹의 다른 컨슈머가 파티션 소유권을 재조정 받아 처리 할 수 있음
### 브로커와 클러스터 
* 하나의 카프카 서버를 브로커(broker)라고 합니다.
* 브로커는 프로듀서로 부터 메시지를 수신하고 오프셋 지정후 저장
* 컨슈머의 파티션 읽기 요청에 응답하고 디스크의 메시지를 전송
  * 일반적으로 하나의 브로커는 초당 수천 개의 토픽과 수백만개의 메시지를 처리합니다. 
* 카프카의 브로커는 클러스터의 일부로 동작함 
  * 여러개의 브로커가 하나의 클러스터에 포함될 수 있으며 그중에 하나는 자동으로 선정되는 클러스터 컨트롤러의 기능을 수행
* 클러스터 컨트롤러는 각 브로커에게 담당 파티션을 할당하고 모니터링 기능 수행 
* 각 파티션은 클러스터의 한 브로커가 담당하며 파티션 리더라고 부르며 파티션은 여러 브로커에 복제될 수 있습니다. 
* 각 파티션을 사용하는 모든 컨슈머와 프로듀서는 파티션 리더와 연결되어야 합니다. 
* 아파치 카프카의 핵심 기능 보존 기능
  * 카프카는 기본적으로 토픽의 보존 설정을 할 수 있습니다.
    * 예를 들어 7일과 같이 메시지를 보존하거나 1GB와 같이 지정된 크기가 될때까지 메시지를 보존함
### 다중 클러스터
* 카프카의 복제 메커니즘은 단일 클러스터에만 동작하도록 설계
* 다중 클러스터의 복제를 위해서는 미러메이커라는 도구를 사용해야 함

## 카프카를 사용해야 하는 이유
### 다중 프로듀서
* 카프카는 무리없이 많은 프로듀서의 메시지를 처리할 수 있음
### 다중 컨슈머
* 다중 프로듀서와 더불어 많은 컨슈머가 상호 간섭없이 어떤 메시지도 읽을 수 있도록 지원
* 큐 시스템과는 다르게 이미 소비한 메시지를 다른 클라이언트와 공유 할 수 있음
### 디스크 기반 보존
* 카프카는 지속해서 메시지를 보존할 수 있음
* 컨슈머 애플리케이션이 항상 실시간으로 실행되지 않아도 됨
* 컨슈머가 다시 실행되면 중단 시점의 메시지부터 처리 가능
### 확장성 및 고성능 지원
## 데이터 생태계
### 이용 사례
#### 활동 추적
* 링크드인에서 프런트엔드에서 사용자의 행동 패턴을 수집해서 카프카에 전송하면 백엔드에서 소비하는 형태
#### 메시지 전송
* 알림 메시지를 전송해야하는 애플리케이션에 유용함
#### 메트릭과 로깅
* 애플리케이션의 메트릭과 로그 데이터를 모으는데 이상적
  * 메트릭이란 타임스탬프와 숫자값을 포함하는 이벤트, 주기적인 발생
#### 커밋 로그
* DB의 변경사항을 카프카 메시지 스트림으로 생성할 수 있음
#### 스트림 프로세싱
* 메시지가 생성되자마자 실시간으로 데이터 처리가능 

## 카프카의 기원
* 카프카는 링크드인의 파이프라인의 문제를 해결을 위해 고성능 메시징 시스템을 제공하도록 개발됨
* 다양한 유형의 데이터 처리 및 실시간 제공을 위한 메시징 시스템

### 링크드인의 문제점
* 