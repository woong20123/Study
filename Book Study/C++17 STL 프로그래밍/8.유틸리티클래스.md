## std::optional을 이용한 실패를 안전하게 밝혀내기
* optional은 has_value를 사용하면 값의 유무를 확인 할 수 있습니다. value를 통해서 값에 접근합니다. 
* if(x) {...}와 *x를 통해서도 접근 할 수 있습니다.
```c++
oint read_int()
{
    int i;
    if (cin >> i) { return { i }; }
    return {};
}

oint operator+(oint a, oint b)
{
    if (!a || !b) 
        return {};
    return { *a + *b };
}

void main()
{
    cout << "Please enter 2 integers.\n";
    auto a{ read_int() };
    auto b{ read_int() };

    a.has_value();
    auto sum(a + b + 10);

    if(sum){
        cout << *a << " + " << *b << " + 10 ="
            << *sum << '\n';
    }else{
        cout << "sorry, the input was something else than 2 numbers.";
    }
}
```

## 튜플에 함수 적용
```c++

static void print_student(size_t id, const string & name, double gpa)
{
    cout << "Student " << quoted(name)
        << ", ID : " << id
        << ", GPA : " << gpa << '\n';
}


void main()
{
    using student = tuple<size_t, string, double>;
    student john{ 123, "John Doe"s, 3.7 };

    {
        // 개별 멤버로 분해하고 개별변수로 함수 호출
        const auto& [id, name, gpa] = john;
        print_student(id, name, gpa);
    }

    cout << "-----\n";
    
    auto arguments_for_later = {
        make_tuple(234, "John Doe"s, 3.7),
        make_tuple(345, "Billy Foo"s, 4.0),
        make_tuple(456, "Cathy Bar"s, 3.5),
    };

    for(const auto &[id, name, gpa]: arguments_for_later) {
        print_student(id, name, gpa);
    }

    cout << "-----\n";

    // std::apply를 사용하면 tuple을 바로 호출 할 수 있음
    apply(print_student, john);
    cout << "-----\n";

    for(const auto & args : arguments_for_later){
        apply(print_student, args);
    }

    cout << "-----\n";
}
```

## std::tuple로 빠르게 데이터 구조체 생성
```c++
struct Foo {
    int a;
    string b;
    float c;
}
// 다음과 같이 변경 해서 사용할 수 있습니다.

using Foo = tuple<int, string, float>;
Foo t;
std::get<0>(t) // 첫번째 멤버 접근
std::get<1>(t) // 첫번째 멤버 접근
```

## 타입에 대해 더 안전한 std::any를 이용한 void 대체
* 모든 타입의 포인터를 저장 할 수 있는 `void *`는 사용하기 편리하여 널리 사용 되었습니다. 
* c++ 17에서는 std::any을 지원합니다. 
### std::any
* has_value() 함수를 사용해서 인스턴스에 값이 있는지 아닌지 확인 합니다. 
* `x.type() == typeid(T)`을 통해서 타입을 확인 할 수 있습니다. 
* any_cast를 사용해하면 내부의 값을 전달 받을 수 있습니다. 
  * 복사를 피하기 위해서 `any_cast<T&>(x)`를 사용해서 복사를 방지합니다.  
```c++
using namespace std;

using int_list = list<int>;

void print_anything(const std::any & a)
{
    if(!a.has_value()){
        cout << "Nothing.\n";
    }else if(a.type() == typeid(string)){
        cout << "It's a string: "
            << quoted(any_cast<const string&>(a)) << '\n';
    }else if(a.type() == typeid(int)){
        cout << "It's an integer: "
            << any_cast<int>(a) << '\n';
    }
    else if (a.type() == typeid(int_list)) {
        const auto& l(any_cast<const int_list&>(a));
        cout << "It's a list: ";
        copy(begin(l), end(l),
            ostream_iterator<int>{cout, ","});
        cout << '\n';
    }else {
        cout << "Can't handle this item.\n";
    }
}

void main()
{
    print_anything({});                     // Nothing.
    print_anything("abc"s);                 // It's a string: "abc"
    print_anything(123);                    // It's an integer: 123
    print_anything(int_list{ 1,2,3 });      // It's a list: 1,2,3,
    print_anything(any(in_place_type_t<int_list>{}, { 1,2,3 }));      // It's a list: 1,2,3,
}
```

## std::variant로 다양한 타입 저장
* variant는 안정적이면서 효율적인 `union`방식입니다.
* 힙을 사용하지 않기 때문에 union 기반의 코드처럼 시간을 많이 사용하지도 않습니다. 
* holds_alternative는 variant를 전달받아서 특정 값이 들어있는지 체크합니다.
* index()를 사용하면 특정 타입의 인덱스를 전달 받을 수 있습니다. 
* get_if를 사용하면 특정 타입일 때만 정상적으로 인스턴스를 전달 받을 수 있습니다. 
* visit는 함수객체와 variant를 전달받습니다. 
  * 함수 객체에는 variant를 담을 수 있는 모든 타입에 대핸 다른 오버로드 구현을 해야합니다. 
* std::any와 std::variant는 비슷한 점이 많지만 다른점은 std::variant는 저장할 수 있는 타입을 지정 해야 합니다.
```c++
using int_list = list<int>;

class cat {
    string name;
public:
    cat(string n ) : name{n} {}
    void meow() const {
        cout << name << " says Meow!\n";
    }
};;

class dog {
    string name;
public:
    dog(string n) : name(n) {}
    void woof() const {
        cout << name << " says Woof!\n";
    }
};

using animal = variant<dog, cat>;

template<typename T>
bool is_type(const animal &a){
    return holds_alternative<T>(a);
}

struct animal_voice
{
    void operator()(const dog& d) const { d.woof(); }
    void operator()(const cat& c) const { c.meow(); }
};

void main()
{
    list<animal> l{ cat{"Tuba"}, dog{"Balou"}, cat{"Boddy"} };

    // index()를 사용한 분기 처리
    for(const animal & a : l) {
        switch (a.index())
        {
        case 0:
            get<dog>(a).woof();
            break;
        case 1 :
            get<cat>(a).meow();
            break;
        }
    }
    cout << "-----\n";

    // get_if를 사용하는 방식
    for(const animal & a : l ){
        // if 초기값
        if(const auto d(get_if<dog>(&a)); d){
            d->woof();
        }else if( const auto c(get_if<cat>(&a)); c){
            c->meow();
        }
    }
    cout << "-----\n";

    // variant visit를 사용하는 방식 
    for(const animal &a : l) {
        visit(animal_voice{}, a);
    }
    cout << "-----\n";

    cout << "There are"
        << count_if(begin(l), end(l), is_type<cat>)
        << " cats and"
        << count_if(begin(l), end(l), is_type<dog>)
        << " dogs in the list.\n";
}
```

## 같은 객체의 서로 다른 멤버 변수 공유
```c++
struct person {
    string name;
    size_t age;
    person(string n, size_t a) : name{ move(n) }, age{a}
    { cout << "CTOR " << name << '\n'; }
    ~person() { cout << "DTOR" << name << '\n'; }
};


int main() 
{
    shared_ptr<string> shared_name;
    shared_ptr<size_t> shared_age;

    {
        auto sperson(make_shared<person>("John Doe", 30));
        // shared_ptr의 일부분을 객체로 참조하여도 person에 대한 use_count는 증가합니다.
        shared_name = shared_ptr<string>(sperson, &sperson->name);
        // shared_ptr의 일부분을 객체로 참조하여도 person에 대한 use_count는 증가합니다.
        shared_age = shared_ptr<size_t>(sperson, &sperson->age);
    }

    cout << "name : " << *shared_name
        << "\nage : " << *shared_age << '\n';
}
```