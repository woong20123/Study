## std::async를 이용한 ASCII 만델브로 렌더러 병렬화
```c++
using namespace std;

using cmplx = complex<double>;


static auto scalar(int min_from, int max_from, double min_to, double max_to) {
	const int w_from{ max_from - min_from };
	const double w_to{ max_to - min_to };
	const int mid_from{ (max_from - min_from) / 2 + min_from };
	const double mid_to{ (max_to - min_to) / 2.0 + min_to };
	return [=](int from) {
		return double(from - mid_from) / w_from * w_to + mid_to;
	};
}

template<typename A, typename B>
static auto scaled_cmplx(A scaler_x, B scaler_y) {
	return [=](int x, int y) {
		return cmplx{ scaler_x(x), scaler_y(y) };
	};
}

static auto medelbrot_iterations(cmplx c) {
	cmplx z{};
	size_t iterations{ 0 };
	const size_t max_iterations{ 100000 };
	while (abs(z) < 2 && iterations < max_iterations) {
		++iterations;
		z = pow(z, 2) + c;
	}
	return iterations;
}


int main() {
	const size_t w{ 100 };
	const size_t h{ 40 };
	auto scale(scaled_cmplx(
		scalar(0, w, -2.0, 1.0),
		scalar(0, h, -1.0, 1.0)
	));

	auto i_to_xy([=](int x) {
		return scale(x % w, x / w);
		});

    // medelbrot_iterations를 async를 통해서 비동기 처리 합니다. 
    // launch::async 이기 때문에 지연 없이 바로 수행합니다.
	auto to_iteration_count([=](int x) {
		return async(launch::async,
			medelbrot_iterations, i_to_xy(x));
		});

    
	vector<int> v(w * h);
    // 비동기 처리에 대한 응답값을 std::future를 통해서 전달 받습니다. 
	vector<future<size_t>> r(w * h);
	iota(v.begin(), v.end(), 0);

	transform(begin(v), end(v), begin(r),
		to_iteration_count);

    // x.get()을 호출해서 비동기 작업에 대한 결과 값이 나오길 대기합니다. 
	auto binfunc([w, n{ 0 }](auto output_it, future<size_t> & x) mutable {
		*++output_it = (x.get() > 50 ? '*' : ' ');
		if (++n % w == 0) { ++output_it = '\n'; }
		return output_it;
	});
	accumulate(begin(r), end(r),
		ostreambuf_iterator<char>{cout}, binfunc);
}
```

## std::async를 이용한 문자열 생성 비동기 작업
```c++
#include <iostream>
#include <iomanip>
#include <thread>
#include <string>
#include <sstream>
#include <future>

using namespace std;
using namespace chrono_literals;

struct pcout : public stringstream {
	static inline mutex cout_mutex;
	~pcout() {
		lock_guard<mutex> l{ cout_mutex };
		cout << rdbuf();
		cout.flush();
	}
};

static string create(const char * s)
{
	pcout{} << "3s CREATE " << quoted(s) << '\n';
	this_thread::sleep_for(3s);
	return { s };
}

// 전달 받은 문자열 a와 b를병합 합니다. 가상의 지연시간 5초 추가
static string concat(const string & a, const string & b) 
{
	pcout{} << "5s CONCAT "
		<< quoted(a) << " "
		<< quoted(b) << '\n';
	this_thread::sleep_for(5s);
	return a + b;
}

// 전달 받은 문자열을 하나 받아서 복제하여 병합 합니다. 가상의 지연시간 3초 추가
static string twice(const string &s)
{
	pcout{} << "3s TWICE" << quoted(s) << '\n';
	this_thread::sleep_for(3s);
	return s + s;
}

// 함수 f를 전달 받아서 캡쳐하여 비동기적으로 호출합니다.
template<typename F>
static auto asynchronize(F f)
{
	return [f](auto ... xs) {
		return [=]() {
			return async(launch::async, f, xs...);
		};
	};
}

// 함수 f를 전달 받아 호출 합니다. 전달된 인수들이 future이기 때문에 get을 통해서 대기합니다.
template<typename F>
static auto fut_unwrap(F f)
{
	return [f](auto ...xs) {
		return f(xs.get()...);
	};
}

// 전달 받은 F를 비동기 적으로 호출 합니다. 전달 받은 인수들이 future이기 때문에 fut_unwrap 호출하여 대기한 후 함수를 호출합니다. 
template<typename F>
static auto async_adapter(F f)
{
	return [f](auto ... xs) {
		return [=]() {
			return async(launch::async,
				fut_unwrap(f), xs()...);
		};
	};
}


int main() {
	auto pcreate(asynchronize(create));
	auto pconcat(async_adapter(concat));
	auto ptwice(async_adapter(twice));

	auto result(
		pconcat(
			ptwice(
				pconcat(
					pcreate("foo "),
					pcreate("bar ")
				)
			),
			pconcat(
				pcreate("this "),
				pcreate("that ")
			)
		)
	);

	cout << "Setup done, Nothing executed yet.\n";
	cout << result().get() << '\n';
}
```