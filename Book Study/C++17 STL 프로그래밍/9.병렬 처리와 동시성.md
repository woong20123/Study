## 표준 알고리즘을 사용한 자동으로 코드 병렬화
* std의 알고리즘에 `execution::par`만 추가해준다면 병렬로 처리합니다. 
### 실행 정책
|정책|의미|
|:--|:--|
|sequenced_policy| 실행 정책이 없는 기존의 알고리즘과 비슷하게 순차적으로 실행합니다. `std::execution::seq`|
|parallel_policy| 병렬로 처리로 작성을 공유하는 복수의 스레드로 실행합니다. `std::execution::par`|
|parallel_unsequenced_policy|복수의 스레드로 동작하면서 벡타화를 허용합니다. `std::execution::par_unseq`
```c++
using namespace std;

static bool odd(int n) { return n % 2; }

int main() 
{
    vector<int> d(50000000);

    mt19937 gen;
    uniform_int_distribution<int> dis(0, 100000);
    auto rand_num([=]() mutable { return dis(gen); });

    // execution::par를 사용하면 자동으로 코드의 병렬화를 수행합니다.
    generate(execution::par, begin(d), end(d), rand_num);

    sort(execution::par, begin(d), end(d));

    reverse(execution::par, begin(d), end(d));

    auto odds(count_if(execution::par, begin(d), end(d), odd));

    cout << (100.0 * odds / d.size())
        << "% of the numbers are odd.\n";
}
```
### 벡터화
* 벡터화는 CPU와 컴파일러 둘다 지원해야 합니다.
* 예제 코드를 통해서 설명을 드립니다.
* 벡터화를 사용하면 가능한 적은 명령어로 많은 수학 연산을 배치해서 프로그램 속도를 향상 시킵니다.
```c++
    std::vector<int> v{ 1,2,3,4,5,6,7/*...*/ };
    int sum{ std::accumulate(v.begin(), v.end(), 0) };

    // accomulate는 다음과 같은 반복문을 생성합니다.
    {
        int s{ 0 };
        for (size_t i{ 0 }; i < v.size();++i){
            sum += v[i];
        }
    }

    // 벡터화를 사용하면 다음과 같이 코드를 생성합니다. 
    {
        int s{ 0 };
        for (size_t i{ 0 }; i < v.size() / 4; i += 4)
            sum += v[i] + v[i + 1] + v[i + 2] + v[i + 3];

        // v.size() / 4의 나머지요소에 대한 처리
    }
```

## std::scoped_lock으로 데드락 피하기
* 뮤텍스 잠금 순서에 따라서 데드락이 발생할 수 있습니다. 
* c++ 17에는 scoped_lock이 추가되었습니다. 복수의 뮤텍스도 추가할 수 있습니다. 
```c++
// 데드락 발생
static void deadlock_func_1()
{
    cout << "bad f1 acquiring mutex A..." << endl;
    lock_guard<mutex> la{ mut_a };
    this_thread::sleep_for(100ms);
    cout << "bad f1 acquiring mutex B..." << endl;
    lock_guard<mutex> lb{ mut_b };
    cout << "bad f1 got both mutexes." << endl;
}

static void deadlock_func_2()
{
    cout << "bad f2 acquiring mutex B..." << endl;
    lock_guard<mutex> lb{ mut_b };
    this_thread::sleep_for(100ms);
    cout << "bad f2 acquiring mutex A..." << endl;
    lock_guard<mutex> la{ mut_a };
    cout << "bad f2 got both mutexes." << endl;
}

static void sane_func_1()
{
    scoped_lock l{ mut_a, mut_b };
    cout << "sane f1 got both mutexes." << endl;
}

static void sane_func_2() 
{
    scoped_lock l{ mut_b, mut_a };
    cout << "sane f2 got both mutexes." << endl;
}

int main() 
{
    {
        thread t1{ sane_func_1 };
        thread t2{ sane_func_2 };
        t1.join();
        t2.join();
    }

    {
        thread t1{ deadlock_func_1 };
        thread t2{ deadlock_func_2 };
        t1.join();
        t2.join();
    }
}
```
## std::call_once로 안전하게 초기화 지연
```c++
once_flag callflag;

static void once_print()
{
    cout << '!';
}

static void print(size_t x)
{
    // call once는 callflag를 기반으로 한번만 호출 되는 것을 보장합니다.
    std::call_once(callflag, once_print);
    cout << x;
}

int main() 
{
    vector<thread> v;
    for (size_t i{ 0 } ; i < 10 ; ++i){
        v.emplace_back(print, i);
    }
    for (auto& t : v) { t.join(); }
    cout << '\n';
}

```
## std::async를 이용한 ASCII 만델브로 렌더러 병렬화
```c++
using namespace std;

using cmplx = complex<double>;


static auto scalar(int min_from, int max_from, double min_to, double max_to) {
	const int w_from{ max_from - min_from };
	const double w_to{ max_to - min_to };
	const int mid_from{ (max_from - min_from) / 2 + min_from };
	const double mid_to{ (max_to - min_to) / 2.0 + min_to };
	return [=](int from) {
		return double(from - mid_from) / w_from * w_to + mid_to;
	};
}

template<typename A, typename B>
static auto scaled_cmplx(A scaler_x, B scaler_y) {
	return [=](int x, int y) {
		return cmplx{ scaler_x(x), scaler_y(y) };
	};
}

static auto medelbrot_iterations(cmplx c) {
	cmplx z{};
	size_t iterations{ 0 };
	const size_t max_iterations{ 100000 };
	while (abs(z) < 2 && iterations < max_iterations) {
		++iterations;
		z = pow(z, 2) + c;
	}
	return iterations;
}


int main() {
	const size_t w{ 100 };
	const size_t h{ 40 };
	auto scale(scaled_cmplx(
		scalar(0, w, -2.0, 1.0),
		scalar(0, h, -1.0, 1.0)
	));

	auto i_to_xy([=](int x) {
		return scale(x % w, x / w);
		});

    // medelbrot_iterations를 async를 통해서 비동기 처리 합니다. 
    // launch::async 이기 때문에 지연 없이 바로 수행합니다.
	auto to_iteration_count([=](int x) {
		return async(launch::async,
			medelbrot_iterations, i_to_xy(x));
		});

    
	vector<int> v(w * h);
    // 비동기 처리에 대한 응답값을 std::future를 통해서 전달 받습니다. 
	vector<future<size_t>> r(w * h);
	iota(v.begin(), v.end(), 0);

	transform(begin(v), end(v), begin(r),
		to_iteration_count);

    // x.get()을 호출해서 비동기 작업에 대한 결과 값이 나오길 대기합니다. 
	auto binfunc([w, n{ 0 }](auto output_it, future<size_t> & x) mutable {
		*++output_it = (x.get() > 50 ? '*' : ' ');
		if (++n % w == 0) { ++output_it = '\n'; }
		return output_it;
	});
	accumulate(begin(r), end(r),
		ostreambuf_iterator<char>{cout}, binfunc);
}
```

## std::async를 이용한 문자열 생성 비동기 작업
```c++
#include <iostream>
#include <iomanip>
#include <thread>
#include <string>
#include <sstream>
#include <future>

using namespace std;
using namespace chrono_literals;

struct pcout : public stringstream {
	static inline mutex cout_mutex;
	~pcout() {
		lock_guard<mutex> l{ cout_mutex };
		cout << rdbuf();
		cout.flush();
	}
};

static string create(const char * s)
{
	pcout{} << "3s CREATE " << quoted(s) << '\n';
	this_thread::sleep_for(3s);
	return { s };
}

// 전달 받은 문자열 a와 b를병합 합니다. 가상의 지연시간 5초 추가
static string concat(const string & a, const string & b) 
{
	pcout{} << "5s CONCAT "
		<< quoted(a) << " "
		<< quoted(b) << '\n';
	this_thread::sleep_for(5s);
	return a + b;
}

// 전달 받은 문자열을 하나 받아서 복제하여 병합 합니다. 가상의 지연시간 3초 추가
static string twice(const string &s)
{
	pcout{} << "3s TWICE" << quoted(s) << '\n';
	this_thread::sleep_for(3s);
	return s + s;
}

// 함수 f를 전달 받아서 캡쳐하여 비동기적으로 호출합니다.
template<typename F>
static auto asynchronize(F f)
{
	return [f](auto ... xs) {
		return [=]() {
			return async(launch::async, f, xs...);
		};
	};
}

// 함수 f를 전달 받아 호출 합니다. 전달된 인수들이 future이기 때문에 get을 통해서 대기합니다.
template<typename F>
static auto fut_unwrap(F f)
{
	return [f](auto ...xs) {
		return f(xs.get()...);
	};
}

// 전달 받은 F를 비동기 적으로 호출 합니다. 전달 받은 인수들이 future이기 때문에 fut_unwrap 호출하여 대기한 후 함수를 호출합니다. 
template<typename F>
static auto async_adapter(F f)
{
	return [f](auto ... xs) {
		return [=]() {
			return async(launch::async,
				fut_unwrap(f), xs()...);
		};
	};
}


int main() {
	auto pcreate(asynchronize(create));
	auto pconcat(async_adapter(concat));
	auto ptwice(async_adapter(twice));

	auto result(
		pconcat(
			ptwice(
				pconcat(
					pcreate("foo "),
					pcreate("bar ")
				)
			),
			pconcat(
				pcreate("this "),
				pcreate("that ")
			)
		)
	);

	cout << "Setup done, Nothing executed yet.\n";
	cout << result().get() << '\n';
}
```