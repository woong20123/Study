## 람다 표현식을 이용해 실행중인 함수 정의
* 람다에서 멤버 함수를 사용하려면 this, *this를 캡쳐 해야 합니다.
* mutable을 사용하면 `[=]`로 복사된 변수를 수정할 수 있습니다. 
* constexpr 명시적으로 사용하면 constexpr기준을 충족하는지 컴파일러 단위에서 체크 합니다.
```c++
void main()
{
    auto just_one([]() {return 1; });
    auto just_two([] {return 2; });

    cout << just_one() << ", " << just_two() << '\n';

    auto plus([](auto l, auto r) { return l + r; });
    cout << plus(1, 2) << '\n';
    cout << plus(std::string{"a"}, "b") << '\n';

    auto counter(
        [count = 0]() mutable { return ++count; }
    );

    for (size_t i{ 0 } ; i < 5 ; ++i){
        cout << counter() << ", ";
    }
    cout << '\n';

    int a{ 0 };
    auto incrementer([&a] { ++a; });

    incrementer();
    incrementer();
    incrementer();

    cout << "Value of 'a' after 3 imcrementer() calls : " << a << '\n';

    auto plus_ten([=](int x) { return plus(10, 3); });
    cout << plus_ten(5) << '\n';

}
```

## 논리 결합을 이용한 복잡한 프레디케이트 생성
* stl은 logical_and, logical_or 등등 다양한 함수 객체를 제공합니다. 
```c++
// 첫 글자가 a 일 때 true
static bool begins_with_a(const std::string &s)
{
    return s.find("a") == 0;
}

// 마지막 글자가 b 일 때 true
static bool ends_with_b(const std::string & s)
{
    return s.rfind("b") == s.length() - 1;
}

// 전달 받은 predicate 함수에 대한 조건 결함 헬퍼 함수
template<typename A, typename B, typename F>
auto combine(F binary_func, A a, B b)
{
    return [=](auto param) {
        return binary_func(a(param), b(param));
    };
}

void main()
{
    // std::logical_and를 사용해서 두 조건이 모두 만족시 true를 리턴하도록 설정
    auto a_xxx_b(combine(
        logical_and<>{},
        begins_with_a, ends_with_b));
   
    cout << "ac : " << a_xxx_b("ac") << '\n';           // 0
    cout << "cb : " << a_xxx_b("cb") << '\n';           // 0
    cout << "ab : " << a_xxx_b("ab") << '\n';           // 1
    cout << "axxb : " << a_xxx_b("axxxb") << '\n';      // 1
    
}
```

## 같은 입력으로 두 개 이상의 함수 호출 
* 코드 중복에 대한 개선을 람다 표현식 헬퍼를 이용해서 쉽게 제거 할 수 있습니다. 
```c++

// std::accumulate와 잘 작동하도록 입력 변형 함수를 파라미터로 받습니다. 
template<typename T>
auto map(T fn)
{
    // reduce_fn 받는 함수 객체 반환
    return [=](auto reduce_fn) {
        return [=](auto accum, auto input) {
            return reduce_fn(accum, fn(input));
        };
    };
}

template<typename T>
auto filter(T predicate)
{
    return [=](auto reduce_fn) {
        return [=](auto accum, auto input) {
            if (predicate(input)) {
                return reduce_fn(accum, input);
            }
            else {
                return accum;
            }
        };
    };
}

void main()
{
    istream_iterator<int> it{ cin };
    istream_iterator<int> end_it;

    auto even([](int i) {return i % 2 == 0; });
    auto twice([](int i) {return i * 2; });

    auto copy_and_advance([](auto it, auto input) {
        *it = input;
        return ++it;
    });

    accumulate(it, end_it,
        std::ostream_iterator<int>{cout, ", "},
        filter(even)(
            map(twice)(copy_and_advance)     
       )
    );
    cout << '\n';

    // 1,2,3,4,5,6 -> 4, 8, 12,
}
```