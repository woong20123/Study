# 성능 측정 
* 프로파일러와 소프트웨어 타이머를 통해서 측정 할수 있습니다. 

# 사고 방식 최적화
## 성능은 반드시 측정해야 합니다. 
* 테스트 가능한 예측을 만들고 적어둔다
* 코드 변경 사항을 기록한다.
* 사용 가능한 최고의 측정기로 측정한다. 
* 실험 결과의 자세한 내용을 보관한다. 
## 최적화를 하는 사람은 맹수 사냥꾼입니다. 
* 최적화의 성능 개선을 측정할 수 있어야 합니다.
  * 1%의 개선을 위해서는 버그의 리스크를 감당할 수 없습니다. 
  * 20%개선이라면 버그의 리스크를 감당할 수 있습니다. 
## 90/10 규칙
* 프로그램 코드의 10%가 실행 시간의 90%를 소비한다. 
* 가장 자주 호출 되는 부분의 성능을 개선 해야 합니다.
## 암달의 법칙 
* 코드 일부의 최적화가 전체의 성능을 얼마나 개선시키는가에 대해서 공식으로 설명합니다. 

# 실험 수행
* 실험이란 프로그램을 두번 실행하는 것을 말합니다. 
  * 기존의 코드와 새로 변경된 코드를 수행해서 예측되었다면 `검증(validate)`되었다고 말합니다 
  * 주의할점은 `검증(validate)`과 `증명(prove)`은 다르다는 점입니다.
    * 왜냐하면 수정한 코드가 아닌 다른 이유로 개선될 가능성도 있기 때문입니다.
* 훌륭한 과학자는 `회의론자` 입니다. 항상 무언가를 의심하는 것이 중요합니다. 
* 그리고 배우는 것을 멈추지 않아야 합니다.

## 연구 노트를 보관하세요
* 각 테스트를 문서화하면 반복 수행을 빠르게 할 수 있습니다. 
* 사람의 기억력은 한계가 있기 때문에 기록이 필요합니다. 

## 성능 측정 기준과 목표 설정 
* 성능 개선의 기준과 목표가 있어야 비용 산정에 유용합니다.
* 또한 실무에서는 관리자와 개발자 사이의 간극을 줄일 수 있습니다.
  * 정확한 목표 제시를 통해서 비용의 소모 이유를 설명할 수 있음
## 측정 할만 UX 관련 수치
* UX란 무엇인가?
  * User Experience로 사용자 경험을 말합니다. 
  * 제품이나 시스템, 서비스등을 직접, 간접적으로 이용하면서 느끼는 반응과 행동을 설계하는 것을 UX 디자인이라고 함
### 시작시간
* 엔터 키를 누른 후에 프로그램이 메인 입력 처리 루프에 들어가기 까지 걸리는 시간 
* 프로그램에서는 main에서 메인 루프로 들어가기 까지 걸리는 시간을 가르킴
* 예를 들어서 마이크로 소프트에서는 하드웨어 제조사에게 윈도우 쉘이 시작한 뒤 10초이내에 메인 루프에 들어가야 한다고 요구 사항 요청합니다. 
### 종료시간
* 사용자가 닫기 요청을 한 후에 프로세스가 실제로 종료되기 까지 걸리는 시간 
* 종료 시간에는 모든 스레드와 종속 프로세스를 중지 시키는 데 필요한 시간도 포함됨
### 응답 시간
* 명령을 수행하는 데 걸리는 평균 시간 또는 최악의 경우를 고려한 시간 
* 응답 시간은 아래와 같이 분류 할 수 있음
  * 0.1초 미만 : 사용자가 직접적인 제어권을 가짐
    * 사용자는 요청이 즉각적으로 받아 들여 진다고 느낍니다. 
  * 0.1 ~ 1초 : 사용자가 제어권을 가짐
    * 사용자는 제어권은 있지만 지연이 발생한다고 느낍니다. 
  * 1초 ~ 10초 : 컴퓨터에 제어권이 있음
    * 10초는 사용자가 집중할 수 있는 최대 시간입니다. 
  * 10초 이상 : 10초 이상이라면 다른 작업을 충분히 수행할 수 있는 시간입니다 .
* 시간의 경험에 대해 정리한 사이트 
  * http://bit.ly/powers-10
### 처리량
* 응답시간의 역수입니다. 
* 데이터 베이스나 웹 서비스의 같은 배치 지향 프로그램에서 측정 지수로 적합합니다. 
### 최적화에 대해서
* 최적화를 필요이상으로 할 필요는 없습니다. 
* 예를 들어서 0.1초의 응답시간을 100배 빠르게 해서 1밀리초로 만든다면 성능은 개선되지만 실제 사용자에게는 의미가 없습니다. 

## 측정한 것만이 개선할 수 있음
* 주의 할점은 단일함수, 서브시스템, Task, Test case를 최적화하는 것과 전체 프로그램의 성능을 개선하는 것은 전혀 다른다는 것입니다. 
  * 예를 들어 DB에서 selece 구문을 10000번 수행 부분을 개선했다고 전체 DB의 성능이 빨라지지 않고 단지 해당하는 select구문만 빨라집니다. 
  * update, delete 구문은 별개로 동작합니다. 
## 프로그램 실행 프로파일 
* `프로파일러`는 어떤 프로그램이 어디에 시간을 쓰는지 통계 자료를 생성하는 프로그램입니다. 
* 비주얼 스튜디오와 GCC는 가장 실행이 빈번한 코드를 찾는데 도움이되는 프로파일러을 제공합니다. 
* 프로파일러의 구현 방법은 여러가지입니다. 
* 그중에 윈도우와 리눅스에서 모두 사용하는 방법은 아래와 같습니다 .
  * 프로 파일링할 프로그램에 모든 함수를 측정 하라고 지시하는 특수한 컴파일러 플래그를 붙여 다시 컴파일 합니다. 
    * 플래그가 붙으면 각 함수의 시작과 끝에 몇 가지 어셈블리 명령어가 추가됩니다. 
  * 측정할 프로그램과 프로파일링 라이브러리를 링크합니다. 
  * 측정할 프로그램을 실행 할 떄마다 프로파일링 테이블을 디스크에 파일로 저장합니다. 
  * 테이블을 기반으로 텍스트 또는 그래픽 보고서를 생성합니다. 
* 또 다른 방식
  * 수정하지 않은 프로그램을 프로파일링 라이브러리와 링크해 측정
    * 라이브러리에는 프로그램을 빠르개 일시 정지하고 명령 포인터 값을 기록하는 루틴 있음
  * 측정할 프로그램을 실행 할 때마다 프로파일링 테이블을 디스크에 파일로 저장
  * 테이블을 기반으로 텍스트 또는 그래픽 보고서를 생성합니다. 
* 프로파일러의 최대 장점은 가장 자주 실행되는 함수 목록을 표시 해준다는 점입니다. 
* 저자의 경험상 디버그 빌드와 릴리즈 빌드에서 프로파일링한 결과는 서로 같습니다. 
### 최적화 프로 팁
* 윈도우에서 디버그 빌드를 프로파일링할 때 런타임 라이브러리의 디버그 버전과 연결되는 점입니다. 
* 디버그 버전의 메모리 관리자 함수는 추가적인 테스트 비용 덕분에 비용이 증가 할 수 있습니다. 
* 만약 추가 테스트 비용을 하지 않으려면 비주얼 스튜디오의 `속성` -> `구성 속성` -> `디버깅` -> `환경`에 
  * `_NO_DEBUG_HEAP`이라는 이름으로 변수를 만든뒤 1로 설정합니다. 
```c++
_NO_DEBUG_HEAP=1
```
