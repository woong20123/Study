# 성능 측정 
* 프로파일러와 소프트웨어 타이머를 통해서 측정 할수 있습니다. 

# 사고 방식 최적화
## 성능은 반드시 측정해야 합니다. 
* 테스트 가능한 예측을 만들고 적어둔다
* 코드 변경 사항을 기록한다.
* 사용 가능한 최고의 측정기로 측정한다. 
* 실험 결과의 자세한 내용을 보관한다. 
## 최적화를 하는 사람은 맹수 사냥꾼입니다. 
* 최적화의 성능 개선을 측정할 수 있어야 합니다.
  * 1%의 개선을 위해서는 버그의 리스크를 감당할 수 없습니다. 
  * 20%개선이라면 버그의 리스크를 감당할 수 있습니다. 
## 90/10 규칙
* 프로그램 코드의 10%가 실행 시간의 90%를 소비한다. 
* 가장 자주 호출 되는 부분의 성능을 개선 해야 합니다.
## 암달의 법칙 
* 코드 일부의 최적화가 전체의 성능을 얼마나 개선시키는가에 대해서 공식으로 설명합니다. 

# 실험 수행
* 실험이란 프로그램을 두번 실행하는 것을 말합니다. 
  * 기존의 코드와 새로 변경된 코드를 수행해서 예측되었다면 `검증(validate)`되었다고 말합니다 
  * 주의할점은 `검증(validate)`과 `증명(prove)`은 다르다는 점입니다.
    * 왜냐하면 수정한 코드가 아닌 다른 이유로 개선될 가능성도 있기 때문입니다.
* 훌륭한 과학자는 `회의론자` 입니다. 항상 무언가를 의심하는 것이 중요합니다. 
* 그리고 배우는 것을 멈추지 않아야 합니다.

## 연구 노트를 보관하세요
* 각 테스트를 문서화하면 반복 수행을 빠르게 할 수 있습니다. 
* 사람의 기억력은 한계가 있기 때문에 기록이 필요합니다. 

## 성능 측정 기준과 목표 설정 
* 성능 개선의 기준과 목표가 있어야 비용 산정에 유용합니다.
* 또한 실무에서는 관리자와 개발자 사이의 간극을 줄일 수 있습니다.
  * 정확한 목표 제시를 통해서 비용의 소모 이유를 설명할 수 있음
## 측정 할만 UX 관련 수치
* UX란 무엇인가?
  * User Experience로 사용자 경험을 말합니다. 
  * 제품이나 시스템, 서비스등을 직접, 간접적으로 이용하면서 느끼는 반응과 행동을 설계하는 것을 UX 디자인이라고 함
### 시작시간
* 엔터 키를 누른 후에 프로그램이 메인 입력 처리 루프에 들어가기 까지 걸리는 시간 
* 프로그램에서는 main에서 메인 루프로 들어가기 까지 걸리는 시간을 가르킴
* 예를 들어서 마이크로 소프트에서는 하드웨어 제조사에게 윈도우 쉘이 시작한 뒤 10초이내에 메인 루프에 들어가야 한다고 요구 사항 요청합니다. 
### 종료시간
* 사용자가 닫기 요청을 한 후에 프로세스가 실제로 종료되기 까지 걸리는 시간 
* 종료 시간에는 모든 스레드와 종속 프로세스를 중지 시키는 데 필요한 시간도 포함됨
### 응답 시간
* 명령을 수행하는 데 걸리는 평균 시간 또는 최악의 경우를 고려한 시간 
* 응답 시간은 아래와 같이 분류 할 수 있음
  * 0.1초 미만 : 사용자가 직접적인 제어권을 가짐
    * 사용자는 요청이 즉각적으로 받아 들여 진다고 느낍니다. 
  * 0.1 ~ 1초 : 사용자가 제어권을 가짐
    * 사용자는 제어권은 있지만 지연이 발생한다고 느낍니다. 
  * 1초 ~ 10초 : 컴퓨터에 제어권이 있음
    * 10초는 사용자가 집중할 수 있는 최대 시간입니다. 
  * 10초 이상 : 10초 이상이라면 다른 작업을 충분히 수행할 수 있는 시간입니다 .
* 시간의 경험에 대해 정리한 사이트 
  * http://bit.ly/powers-10
### 처리량
* 응답시간의 역수입니다. 
* 데이터 베이스나 웹 서비스의 같은 배치 지향 프로그램에서 측정 지수로 적합합니다. 
### 최적화에 대해서
* 최적화를 필요이상으로 할 필요는 없습니다. 
* 예를 들어서 0.1초의 응답시간을 100배 빠르게 해서 1밀리초로 만든다면 성능은 개선되지만 실제 사용자에게는 의미가 없습니다. 

## 측정한 것만이 개선할 수 있음
* 주의 할점은 단일함수, 서브시스템, Task, Test case를 최적화하는 것과 전체 프로그램의 성능을 개선하는 것은 전혀 다른다는 것입니다. 
  * 예를 들어 DB에서 selece 구문을 10000번 수행 부분을 개선했다고 전체 DB의 성능이 빨라지지 않고 단지 해당하는 select구문만 빨라집니다. 
  * update, delete 구문은 별개로 동작합니다. 
## 프로그램 실행 프로파일 
* `프로파일러`는 어떤 프로그램이 어디에 시간을 쓰는지 통계 자료를 생성하는 프로그램입니다. 
* 비주얼 스튜디오와 GCC는 가장 실행이 빈번한 코드를 찾는데 도움이되는 프로파일러을 제공합니다. 
* 프로파일러의 구현 방법은 여러가지입니다. 
* 그중에 윈도우와 리눅스에서 모두 사용하는 방법은 아래와 같습니다 .
  * 프로 파일링할 프로그램에 모든 함수를 측정 하라고 지시하는 특수한 컴파일러 플래그를 붙여 다시 컴파일 합니다. 
    * 플래그가 붙으면 각 함수의 시작과 끝에 몇 가지 어셈블리 명령어가 추가됩니다. 
  * 측정할 프로그램과 프로파일링 라이브러리를 링크합니다. 
  * 측정할 프로그램을 실행 할 떄마다 프로파일링 테이블을 디스크에 파일로 저장합니다. 
  * 테이블을 기반으로 텍스트 또는 그래픽 보고서를 생성합니다. 
* 또 다른 방식
  * 수정하지 않은 프로그램을 프로파일링 라이브러리와 링크해 측정
    * 라이브러리에는 프로그램을 빠르개 일시 정지하고 명령 포인터 값을 기록하는 루틴 있음
  * 측정할 프로그램을 실행 할 때마다 프로파일링 테이블을 디스크에 파일로 저장
  * 테이블을 기반으로 텍스트 또는 그래픽 보고서를 생성합니다. 
* 프로파일러의 최대 장점은 가장 자주 실행되는 함수 목록을 표시 해준다는 점입니다. 
* 저자의 경험상 디버그 빌드와 릴리즈 빌드에서 프로파일링한 결과는 서로 같습니다. 
### 최적화 프로 팁
* 윈도우에서 디버그 빌드를 프로파일링할 때 런타임 라이브러리의 디버그 버전과 연결되는 점입니다. 
* 디버그 버전의 메모리 관리자 함수는 추가적인 테스트 비용 덕분에 비용이 증가 할 수 있습니다. 
* 만약 추가 테스트 비용을 하지 않으려면 비주얼 스튜디오의 `속성` -> `구성 속성` -> `디버깅` -> `환경`에 
  * `_NO_DEBUG_HEAP`이라는 이름으로 변수를 만든뒤 1로 설정합니다. 
```c++
_NO_DEBUG_HEAP=1
```

## 시간 측정하기 
* 측정 실험을 할 때는 불규칙 편차와 체계적 편자를 주의해야 합니다. 
  * 활을 쏘는 것을 테스트로 비교해서 설명합니다. 
  * 불규칙(random) 편차 : 예를 들면 궁수가 활을 쏠 때 불어오는 바람이 영향을 미치는 것과 같습니다. 
  * 체계적(systematic) 편차 : 궁수가 서있는 바닥이 기울어져 있는 경우
### 정밀도, 진도, 정확도
* 불규칙 편차가 없는 측정은 정밀(`precise`)하다고 말합니다. 
  * 즉 반복적으로 측정 할 수 있으며 측정 값이 서로 비슷하다면 정밀하다고 합니다. 
* 정확하지 않더라도 정밀 할 수 있습니다.
  * 과녁에서 정중앙이 아니더라도 발사한 화살이 한곳에 모여 있다면 정밀하다고 할 수 있습니다. 
* 체계적 편차가 없는 측정은 충실(`true`)합니다.(진도가 높음)
  * 동일한 현상을 반복적으로 측정했는데 실제 값에 가깝다면 충실합니다. 
* 정확한 측정을 위해서는 정밀하면서 충실해야합니다. 
* 정확도는 측정한 값이 실제 값과 얼마나 근접한지에 대해서 결정되는 값입니다. 
### 측정 해상도
* 측정 해상도(`resolution`)란 측정을 나타내는 크기의 단위입니다. 
  * 손목시계는 `1초`의 측정 해상도를 가집니다. 
* 같은 장소에서 두 이벤트가 발생하면 하나의 시계로 타이머 틱을 통해서 `소요 시간`을 측정 할 수 있습니다.
* 서로 다른 시계에서는 틱 수를 비교 할 수 없기 때문에 UTC(`Coordinated Universal Time`)로 시간을 동기화해서 해결하려고 합니다. 
  * UTC는 영국 그리니치에 있는 왕립 천문대(경도 0)에서의 천문학적 자정 맞춰서 동기화합니다. 
### 컴퓨터로 시간 측정하기 
* 원래의 IBM PC에는 틱 카운터가 없었고 대신 소프트웨어를 통해서 지원했습니다. 
* 최초의 마이크로 소프트 C 런타임 라이브러리는 ANSI C 라이브러리의 time_t를 사용합니다. 
* 원래의 IBM PC는 AC 전원 공급 장치에서 오는 주기적인 인터럽트를 사용해서 커널을 깨우거나 전환합니다.
  * AC전원이 60Hz인 북미에서는 틱 주기가 `16.67(= 1000/60)` 밀리 초입니다. 
  * 50Hz인 유럽에서는 틱 주기가 `20(= 1000/50)` 밀리 초입니다. 
* 윈도우 8 이상의 운영체제에서는 GetSystemTimePreciesAsFileTime(FILETIME*)을 사용해서 고해상도 틱을 생성합니다. 
  * 100단위 나노초 해상도를 가짐 
### 지연시간 
* 지연 시간(`latency`)이란 명령을 내린 시점부터 명령을 시작하는 시점까지 경과 시간을 말합니다.
## 측정 장애물 극복하기 
* 정확도는 1% ~ 2% 정도의 정확도만으로 충분합니다. 
* 최적화된 코드와 이전 코드의 실행 시간 비율을 %로 표시하는 것을 상대적 성능이라하며 이것을 사용하세요
  * 상대적 측정은 편차가 똑같이 적용되므로 체계적 편차를 배재할 수 있으며 직관적입니다.
* 모듈 테스트를 측정해서 반복성을 높이세요
* 측정 기준을 사용해서 성능을 튜닝 할 수 있습니다. 
  * 응답시간 평균을 수집해서 통계를 활용합니다. 
* 여러 차례 반복한 결과의 평균으로 정확도를 높일 수 있습니다.
* 프로세스의 우선순위를 높여서 운영체제의 비결정적인 행동을 줄이수 있습니다. 
  * SetPriorityClass() 함수는 프로세서의 우선 순위를 조작합니다. 
  * SetThreadPriority() 함수는 스레드의 우선 순위를 조작합니다.
```c++ 
SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS);
SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
```