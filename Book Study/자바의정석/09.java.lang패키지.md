## java.lang 패키지
* java.lang 패키지는 자바 프로그래밍의 가장 기본이 되는 클래스를 포함함
  * import 없이 사용 가능 

### Object 클래스 
* 모든 클래스의 조상 클래스
* 아래의 메서드를 사용 가능함
  * clone() : 자신의 복사본을 복사합니다. 
  * equals() : 객체 자신과 obj가 같은 객체인지 확인
  * finalize() : 객체가 소멸될 때 자동적으로 호출됨
  * getClass() : 객체 자신의 클래스 정보를 담고 있는 class인스턴스를 반환함
  * hashCode() : 객체 자신의 해시코드를 반환합니다.
  * toString() : 객체 자신의 정보를 문자열로 반환합니다.
  * notify() : 객체를 사용하려고 기다리는 스레드를 하나만 깨운다.
  * notifyAll() : 객체 자신을 사용하려고 기다리는 모든 스레드를 깨운다.
  * wait() : 다른 스레드가 notify()나 notifyAll을 호출 할 때까지 현재 스레드를 무한이나 지정된 시간동안 기다림

#### equal(Object obj) 함수
* 매개 변수로 객체의 참조변수를 받아서 비교하여 결과를 boolean을 리턴합니다. 
  * 주소값으로 비교를 진행합니다. 
```java
// Object가 가진 equals 메서드
public boolean equals(Object obj) {
        return (this == obj);
}
```
* equals 메서드를 value체크를 하려면 오버라이딩해서 값을 비교하도록 구현하면 됩니다. 
* String 클래스는 equals 메서드를 오버라이딩해서 값을 비교하도록 구현되어 있습니다. 

#### hashCode 함수
* Object의 주소값으로 해시코드를 만들어서 반환합니다. 
* 32비트에서는 4byte주소 -> 4byte 해시값을 만들기 때문에 중복이 발생하지 않았음
* 64비트에서는 8byte주소 -> 4byte 해시값 => 중복 발생 가능
  * HashMap이나 HashSet과 같은 클래스에 저장할 객체라면 hashCode 메서드를 오버라이딩 해야합니다.
  * String클래스의 경우 문자열의 내용이 같으면 동일한 해시코드를 반환하도록 구현되어 있습니다.
* System.identityHashCode(Object zx) Object 클래스의 hashCode 처럼 주소 값으로 해시코드를 생성함

#### toString 함수
* 인스턴스에 대한 문자열을 제공하는 목적으로 정의합니다.
```java
// Object 클래스에 정의된 toString 
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

#### clone 함수
* 자신을 복제하여 새로운 인스턴스를 생성합니다. 
* clone()은 값만 복사하기 때문에 참조타입의 인스턴스가 있다면 오버라이딩 해서 구현해야합니다. 
  * Cloneable을 구현한 클래스에서만 clone을 호출 할 수 있음 
```java
// Cloneable 인터페이스를 구현해야지 clone을 호출 할 수 있음 
class Point implements Cloneable{
    int x, y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }

    public Object clone() {
        Object obj = null;
        try{
            obj = super.clone();
        } catch(CloneNotSupportedException e) {}
        return obj;
    }
}

class CloneEx1 {
    public static void main(String[] args){
        Point original = new Point(3, 5);
        Point copy = (Point)original.clone();
        System.out.println(original);
        System.out.println(copy);
    }
}
```

#### 공변반환 타입
* JDK 1.5부터 공변 반환 타입(`covariant return type`) 이라는 것이 추가됨
```java
public Point clone() { // 반환할 타입을 Object에서 Point로 변경 
    Object obj = null;
    try{
        obj = super.clone();
    }catch(CloneNotSupportedException e) {}
    return (Point)obj;
}
```

#### 얕은 복사와 깊은 복사 
```java
public Circle deepCopy(){
  Object obj = null;
  try{
    obj = super.clone();
  }catch(CloneNotSupportedException e) {}
  Circle c = (Circle)obj;
  // 참조객체에 대해서 깊은 복사 작업이 필요함 
  c.p = new Point(this.p.x, this.p.y);
  return c;
}
```

#### getClass() 함수 
* 자신이 속한 클래스의 객체를 반환하는 메서드입니다. 
* Class 객체는 클래스의 모든 정보를 가지고 있으며 클래스당 1개만 존재함 
* 클래스 파일이 `클래스 로더`(ClassLoader)에 올라갈 때 자동으로 생성됨
  * 클래스 로더란 실행시에 필요한 클래스를 동적으로 메모리에 로드하는 역활
  * 만약에 클래스(class 파일)를 찾지 못하면 ClassNotFoundException이 발생함
* 클래스 객체를 얻는 방법
```java
Class cObj = new Card().getClasS();
Class cObj = Card.class;
Class cObj = Class.forName("Card");
```

## String 클래스
* 자바에서는 문자열을 위한 클래스를 제공함 
### 변경이 불가능한(immutable) 클래스
* 한번 생성된 String 인스턴스는 문자열을 읽어 올 수 만 있고 변경할 수 없음
* `+` 연산자를 통한 문자열 결합은 새로운 인스턴스가 생성됨 
* 문자열 결합시에는 StringBuffer를 통해서 다루는 것이 효율적임 

### 문자열 비교
* `문자열 리터럴`은 이미 존재하는 내용을 재사용합니다.
  * ex ) "abc", "aaaa"
* `==` 연산자를 사용하면 두 문자열의 주소값을 비교합니다.
* equals() 메서드를 사용하면 문자열의 값을 비교 할 수 있음

### 문자열 리터럴
* 자바 소스에 포함된 모든 문자열 리터럴은 컴파일시에 클래스 파일에 저장됨
* JVM내의 상수 저장소에 저장됨
  
### join()과 StringJoiner
* join은 여러 문자열 사이의 구분자를 넣어서 결합합니다. 
  * split의 반대 작업
```java
// join메서드를 사용한 예제
String animals = "dog,cat,bear";
// , 구분자로 나눠서 배열로 저장
String[] arr = animals.split(",");
// 문자열 배열을 dog-cat-bear
String str = String.join("-", arr);

// StringJoiner 를 사용한 예제
StringJoiner sj = new StringJoiner(",", "[", "]");
String[] strArr = { "aaa", "bbb", "ccc"};

for(String s : strArr)
  sj.add(s.toUpperCase());

// sj = "[AAA,BBB,CCC]"

```

### 유니코드 보충 문자 
* 유니코드가 20비트로 확장하게 됨
* 하나의 문자를 char타입으로 다루지 못하고 int형으로 다룰수 없게 됨

### 문자 인코딩 변환
* getBytes를 사용하면 문자열의 문자 인코딩을 다른 인코딩으로 변경할 수 있음
* JAVA는 UTF-16을 사용하지만 문자열 리터럴에 포함되는 문자들은 OS의 인코딩을 사용함
  * 한글 윈도우즈는 CP949를 사용함 

### String -> 기본형, 기본형 -> String 변환
* valueOf 메서드로 통일해서 사용
```java
String str = String.valueOf(1);
int i = Integer.valueOf("100");
```