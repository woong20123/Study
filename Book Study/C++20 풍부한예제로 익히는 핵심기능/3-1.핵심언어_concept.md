* c++20 이전에는 함수나 클래스에 접근하는 방식은 구체적인 형식을 접근 하는 방식과 일반적으로 접근하는 방식으로 나뉩니다.
  * 간단한 예로 함수 직접 호출과 템플릿 호출이 있습니다.
### 직접 호출의 문제점
* 모든 데이터 형에 대해서 overloading 하는 방식은 지루합니다. 
* 암시적 변환(implicit conversion)은 예상하지 않은 동작으로 유발 할 수 있습니다.
```c++
template<typename T>
auto add(T first, T second){
    return first + second;
}

int main() 
{
    // bool -> int로 승격
    // ret은 int로 변경
    auto ret = add(true, false);
}
```
### 너무 일반적인 접근 방식 문제점
```c++
    std::list<int> myList{ 1, 10, 3, 2, 5 };
    // std::sort는 임의 접근 반복자만 허용합니다. 
    // 사용자는 임의 접근 반복자만 요구하는 것을 알수 없습니다.
    std::sort(begin(myList), end(myList));
```
## Concept
* 콘셉트는 컴파일 시점 술어입니다. 템플릿 매개변수에 의미론적인 제약을 가합니다.
* 다음 아래의 예에서 ValueSwappable과 LegacyRandomAccessIterator 같은 요구조건을 `명명된 요구 조건`이라고 부릅니다.
* c++20에서는 이것을 콘셉트라고 공식화 합니다. 
```c++
// std::sort의 중복 적재 버전
template<class RandomIt, class Compare>
constexpr void sort(RandomIt first, RandomIt last, Compare comp);

// 중복 적재 버전의 형식 요구 조건
// RandomIt은 반드시 ValueSwappable과 LegacyRandomAccessIterator의 요구 조건을 충족 해야 합니다.
// RandomIt의 역 참조 형식 MoveAssignable과 MoveConsturctible의 요구조건을 충족해야 합니다.
// RandomIt은 역 참조 형식은 반드시 Compare의 요구조건을 충족해야 합니다.

template<class I>
concept random_access_iterator = 
    bidirectional_iterator<I> && 
    derived_from<ITER_CONCEPT(I), random_access_iterator_tag> &&
    totally_ordered<I> &&
    sized_sentinel_for<I, I> &&
    requires(I i, const I j, const iter_difference_t<I> n) {
        { i += n} -> same_as<I&>;
        { j + n } -> same_as<I>;
        { n + j } -> same_as<I>;
        { i -= n} -> same_as<I&>;
        { j - n } -> same_as<I> 
        { j[n] } -> same_as<iter_reference_t<I>>;
    };
```

## 콘셉트의 장점
* 템플릿 매개변수에 대한 요구조건들이 인터페이스의 일부가 된다.
* 콘셉트에 기반해서 함수를 중복적재하거나 클래스 템플릿을 특수화 할 수 있습니다. 
* 클래스 템플릿의 일반 함수에도 콘셉트를 적용할 수 있습니다. 
* 컴파일러는 템플릿 매개변수에 대한 요구조건들을 주어진 템플릿 인수와 비교함으로 좀 더 개선된 오류 메시지를 생성 할 수 있습니다. 
* 다른 사람들이 미리 정의한 콘셉트들을 활용 할 수 있습니다. 
* auto와 콘셉트의 용법이 통합 되었습니다. 
* 함수 선언에 콘셉트가 있으면 자동으로 함수 템플릿이 됩니다. 
* c++ 콘셉트는 실행 시점 비용이 추가되지 않습니다. 

## 콘센트의 적용 방법과 용도
* 다음의 예는 미리 정의된 std::integral의 콘셉트를 정의하는 네가지 방법을 설명합니다.
```c++
/*
* std::integral<T>
* template <class _Ty>
* concept integral = is_integral_v<_Ty>;
*/

// integral는 템플릿 매개 변수를 기본형 정수로 제한합니다.
// 1. require 절 행
template<typename T>
requires std::integral<T>
auto gcd(T a, T b){
    if (b == 0) return a;
    else return gcd(b, a % b);
}

// 2. 후행 requires 절 행
template<typename T>
auto gcd1(T a, T b) requires std::integral<T> {
    if (b == 0) return a;
    else return gcd1(b, a % b);
};

// 3. 제약이 있는 템플릿 매개변수
template<std::integral T>
auto gcd2(T a, T b){
    if (b == 0) return a;
    else return gcd2(b, a % b);
}

// 4. 단축 함수 템플릿
// 이 형태만 a와 b의 형식이 다를 수 있습니다.
auto gcd3(std::integral auto a, std::integral auto b){
    if (b == 0) return a;
    else return gcd3(b, a % b);
}
```

### requires 절
* requires라고 시작하는 절은 템플릿 매개변수나 함수 선언에 대한 요구 조건 및 제약 을 서술 합니다.
  * 하나의 명명된 콘셉트
  * 명명된 콘셉트들의 논리곱(`&&`) 또는 논리 합(||)
  * requires 표현식 같은 컴파일 시점 술어가 와야 합니다. `requires (i <= 20)`
```c++
template<unsigned int i>
// 비형식 인수 컴파일 시점 술어
requires(i <= 20)
int sum(int j) {
    return i + j;
}

int main() {
    std::cout << '\n';

    std::cout << "sum<20>(2000)" << sum<20>(2000) << '\n';
    // std::cout << "sum<23>(2000)" << sum<23>(2000) << '\n'; // 오류 C7602 관련 제약 조건이 충족되지 않습니다.
    std::cout << '\n';
}
```

### 콘셉트의 용도
* 콘셉트는 결국은 하나의 컴파일 시점의 술어입니다. 
  * 컴파일 시점의 술어란 컴파일 시점에 실행되는 하나의 부울 값을 돌려주는 함수를 뜻합니다. 
### 컴파일 시점 술어
* 수행 위치에 따라서 런타임, 컴파일 시점에서 사용 할 수 있습니다. 
```c++
// 예제는 콘셉트를 컴파일 시점과 실행 시점에 평가되는 술어로 사용하는 예제입니다. 
using namespace std;

struct Test {};

int main() {
    cout << '\n';

    // bool 값을 true, false로 출력 합니다. 
    cout << std::boolalpha;

    // true - 런타임 시점
    // three_way_comparable는 여섯가지 비교연산자를 지원하는 체크하는 콘셉트입니다.
    cout << "std::three_way_comparable<int> : "
        << std::three_way_comparable<int> << '\n';

    // True - 런타임 시점
    cout << "std::three_way_comparable<double> : ";
    if (std::three_way_comparable<double>)
        cout << "True";
    else 
        cout << "False";
    cout << '\n';


    // 컴파일 시점
    static_assert(std::three_way_comparable<string>);

    // False - 컴파일 시점
    cout << "std::three_way_comparable<Test> : ";
    if constexpr (std::three_way_comparable<Test>) cout << "True";
    else cout << "False";
    cout << '\n';

    // True - 컴파일 시점
    cout << "std::three_way_comparable<std::vector<int>> : ";
    if constexpr (std::three_way_comparable<vector<int>>) cout << "True";
    else cout << "False";           
}
```
### 클래스 템플릿 
* 클래스 템플릿에서 템플릿 매개변수의 한정적인 조건을 제안합니다.
```c++
using namespace std;

// std::regular는 정규 형식인지 체크하는 콘셉
// int 처러 복사, 기본생성, 상등 판정이 가능한 형식인지 판단합니다/
template<std::regular>
class MyVector {};

int main() {
    MyVector<int> myVec1;
    MyVector<int&> myVec2;  // int &은 정규형식이 아님 에러 발생 
}
```

### 일반적 멤버 함수
* 클래스 템플릿의 일반 함수에 콘셉트를 추가하는 예제입니다. 
```c++
struct NotCopyable {
    NotCopyable() = default;
    NotCopyable(const NotCopyable&) = delete;
};

// 클래스 템플릿 일반함수에 콘셉트를 추가합니다.
template<typename T>
struct MyVector {
    // copy가 가능한 인스턴스만 추가 할 수 있습니다.
    void push_back(const T &) requires std::copyable<T> {}
};

int main() {
    MyVector<int> MyVec1;
    MyVec1.push_back(2020);

    MyVector<NotCopyable> MyVec2;
    MyVec2.push_back(NotCopyable());     // std::copyable형식을 만족하지 않음
}
```

### 가변 인수 템플릿 
* 가변 인수에 적용하는 예제입니다.
```c++
// 가변 인수의 값을 integral -> 기본형 정수만으로 제한합니다. 
// 모두 접기 표현식 
template<std::integral... Args>
bool all(Args... args) { return (... && args);  }

template<std::integral... Args>
bool any(Args... args) { return (... || args); }

template<std::integral... Args>
bool none(Args... args) { return !(... || args); }


int main() {
    cout << std::boolalpha << '\n';

    cout << "all(5, true, false) : " << all(5, true, false) << '\n';        // false

    cout << "any(5, true, false) : " << any(5, true, false) << '\n';        // true

    cout << "none(5, true, false) : " << none(5, true, false) << '\n';      // false
}
```

### 함수 중복 적재
* 콘셉트를 기반해서 특수화된 함수 템플릿을 중복 적재할 수있습니다. 
```c++
using namespace std;

template<std::forward_iterator I>
void advance(I & iter, int n){
    cout << "forward_iterator" << '\n';
}

template<std::bidirectional_iterator I>
void advance(I & iter, int n) {
    cout << "bidirectinal_iterator" << '\n';
}

template<std::random_access_iterator I>
void advance(I & iter, int n){
    cout << "random_access_iterator" << '\n'
}

int main() {
    cout << '\n';

    std::forward_list forwList({ 1, 2, 3 });
    std::forward_list<int>::iterator itFor = forwList.begin();
    advance(itFor, 2);

    std::list li{ 1, 2, 3 };
    std::list<int>::iterator itBi = li.begin();
    advance(itBi, 2);

    std::vector vec{ 1, 2, 3 };
    std::vector<int>::iterator itRa = vec.begin();
    advance(itRa, 2);
}

```