## 모듈이 필요한 이유
* 간단한 프로그램을 빌드한다해도 파일을 크기가 커집니다.
```bat
find /v /c output "" || cl.exe /std:c++20 /c main.cpp /E > output
```

## 고전적인 빌드 과정
* c++ 프로그램의 빌드 과정은 전처리, 컴파일, 링크 과정으로 구성됩니다. 

### 전처리 
* 소스 파일에 #include, #define 같은 지시자또는 지시문을 처리합니다. 
* 또한 #if, #else, #elif, #ifdef, #ifndef, #endif 지시자를 해석해서 조건에 따라서 소스 코드의 해당 부분을 포함하거나 제외합니다. 
* 전처리기의 출력은 컴파일러의 입력이 됩니다.(번역 단위)

### 컴파일
* 컴파일 단계에서는 주어진 번역 단위에 담긴 C++ 소스 코드를 해석해서 어셈블리 코드로 변환하고 
* 어셈블리 코드에 대응되는 이진 기계어 명령들로 이루어진 이진 파일(목적 파일)을 출력합니다.
  * 목적 파일은 목적 파일이 정의하지 않은 기호(symbol)들도 참조 할 수 있습니다. 
* 목적 파일들을 링크해서 하나의 실행 파일이나 정적, 동적 라이브러리를 만들 수 있습니다. 

### 링크
* 링크 단계에서 링커는 실행 파일이나 정적/공유 라이브러리를 출력합니다.
  * 정의 되지 않은 기호(Symbol)을 해결하는 것도 링커의 임무입니다.

이러한 빌드 과정은 `C`의 것을 물려 받은 것입니다. 번역 단위가 하나일때는 잘 진행되지만 번역 단위가 여러개 일때는 다양한 문제가 발생합니다. 

### 빌드 과정의 문제점
#### 거듭된 치환
* 전처리기에서 #include 지시문은 해당 헤더 파일을 치환합니다. 
* 상황에 따라서 치환이 여러번 일어납니다.
* 번역 단위가 커지면 컴파일 시간이 길어집니다.
* 헤더 파일과 달리 모듈은 단 한번만 도입이 됩니다.
```bat
find /v /c output "" || cl.exe /std:c++20 /c main.cpp /E > output
```

#### 전처리기 매크로의 위험
* 매크로가 위험한 점은 단순한 텍스트 치환이기 때문에 C++의 의미론과 무관하게 작동합니다. 
```c++
// webcolors.h
#define RED 0xFF0000

// productinfo.h
#define RED 0

// 만약 어떤 cpp에서 RED를 사용할때는 헤더를 어떻게 선언 했냐에 따라서 RED의 값이 달라집니다. 
```

#### 기호 중복 정의 
* ORD(One Definition Rule)는 단일 정의 규칙을 뜻합니다.
* 함수에 대한 ORD은 다음과 같습니다.
  * 임의의 번역 단위에 함수의 정의는 많아야 하나이어야 합니다. 
  * 프로그램안에서 함수의 정의는 많아야 하나이어야 합니다. 
```c++
// header.h
void func() {}

// header2.h
#include "header.h"

// main.cpp
#include "header.h"
#include "header2.h"

// main에서 func()이 중복 정의 되었다는 링커 오류 메시지가 출력 됩니다. 

int main() {}
```
* 위의 중복을 개선하기 위해서 전처리기를 사용해서 중복을 회피합니다. 
```c++
// header.h
#ifndef FUNC_H
#define FUNC_H
void func() {}
#endif
```

## 모듈의 장점
* 모듈은 단 한번만 도입되며, 비용이 사실상 0입니다.
* 모듈을 도입하는 순서에 따른 차이가 없습니다. 
* 모듈에서는 기호 중복 정의 문제가 거의 발생하지 않습니다. 
* 모듈은 코드의 논리적 구조를 표현하는데 유리합니다.
  * 어떤 이름을 모듈 밖으로 노출 할 것인지 명시적으로 지정할 수 있습니다. 
  * 다수의 모듈을 더 큰 모듈 하나로 묶어서 그 모듈들을 제공할 수 있습니다.
* 모듈 덕분에 코드를 인터페이스 부분과 구현 부분으로 분리 할 필요가 없습니다.

### 모듈의 예제
```c++
// math.ixx
// 다음은 모듈의 선언입니다.
export module math;

// add 함수에 export가 있기 때문에 클라이언트가 함수를 사용할 수 있습니다.
export int add(int fir, int sec) {
    return fir + sec;
}


// main.cpp
// math 모듈을 이 소스 파일에 도입합니다. 
import math;

using namespace std;

int main() {
    add(2000, 22);
}

```

#### 모듈 파일 
* MSVC 컴파일러는 `xxx.ixx` 형태의 파일을 사용합니다. 
  * i는 인터페이스를 뜻하고 xx는 c++ 소스 파일을 뜻합니다. 
  * Microsoft에서는 모듈 파일을 모듈 인터페이스 소스라고 부릅니다. 
* Clang 컴파일러는 예전에는 `cppm 확장자`를 사용 했으나 최근에는 `cpp 확장자`를 사용합니다 .
* GCC 컴파일러는 모듈 파일에 대해서 특별한 확장자를 사용하지 않습니다. 
* 전역 모듈 조각을 둘 수 있습니다. 
  * 이 영역은 모듈의 컴파일에 필요한 헤더 파일이나 기타 매크로 정의를 두는 장소 입니다. 
```c++
// math1.ixx
module;
// 전역 모듈 조각 시작
#include <numeric>
#include <vector>
// 전역 모듈 조각 종료
export module math;

export int add(int fir, int sec) {
    return fir + sec;
}

export int getProduct(const std::vector<int>& vec){
    return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());
}
```

### MSVC 컴파일러
* MSVC 컴파일러로 모듈을 컴파일하고 링크하려는 설정
```c++
// 다음을 수행하면 math.obj와 math.ifc 파일을 생성합니다. 
// ifc 파일에는 모듈 인터페이스의 메타 데이터가 들어 있습니다. 
cl.exe /std:c++20 /c math.ixx

// 실행 파일 client.exe 파일을 생성합니다. 
// 내부적으로 math.ifc 파일의 메타데이터를 이용해서 모듈을 참조합니다. 
cl.exe /std:c++20 /EHsc client.cpp math.obj
```

### 모듈 내보내기
* 모듈 파일에 선언된 이름들을 모듈 외부로 내보내는(export) 방법은 크게 세가지 입니다.

#### 개별 내보내기
* 다음 예처럼 각각의 이름에 export 키워드를 붙여서 개별적으로 내보낼 수 있습니다. 
```c++
export module math;
export int mult(int fir, int sec);  
export void doTheMath();
```
#### 그룹 내보내기
* 여러 임을 하나의 그룹으로 묶어서 내보내는 것도 가능합니다. 
```c++
export module math

export {
    int mult(int fir, int sec);
    void doTheMath();
}
```

### namespace 내보내기
* namespace 내보내기의 경우 클라이언트는 이름 공간의 이름을 명시한 완전 한정 이름을 사용해서 특정 이름에 접근 해야 합니다.
```c++
export namespace math {
    int mult(int fir, int sec);
    void doTheMath();
}

// 다음과 같이 접근합니다. 
math::doTheMath
```

### 바람직한 모듈 구조
* 내보낼 이름만 선언하는 것을 모듈 인터페이스 단위라고 부릅니다.
* 실제 구현을 담은 모듈 파일을 모듈 구현 단위라고 부릅니다. 
```c++
module // 전역 모듈 조각

#include <아직 모듈화 되지 않는 라이브러리 헤더>

export module math;     // 모듈 선언, 여기서 부터 모듈 시작
import <다른 모듈>      // 들여올 다른 모듈

<내보내지 않을 선언들>  // 모듈 안에서만 보이는 이름

export namespace math {
    <내보낼 선언들>     // 사용자가 보게될 이름
}
```

### 모듈 인터페이스 단위와 모듈 구현 단위
* 모듈이 커지면 하나의 `모듈 인터페이스 단위`와 하나 이상의 `모듈 구현 단위`로 분할 하는 것이 바람직합니다.
#### 모듈 인터페이스 단위
* 모듈 인터페이스 단위에는 모듈 선언을 내보내는 문장이 있어야 합니다.
  * `export module math`
* add와 getProduct는 모듈이 내보낼 이름입니다. 
* 하나의 모듈에는 모듈 인터페이스가 하나이어야 합니다.
```c++
// mathInterfaceUnit.ixx
module;

#include <vector>

export module math;

export namespace math {
    int add(int fir, int sec);
    int getProduct(const std::vector<int> & vec);
}
```
#### 모듈 구현 단위
* 모듈 구현 단위에서는 모듈 선언에 export를 붙이지 않습니다. 
* 하나의 모듈의 여러 개의 모듈 구현 단위가 있을 수 있습니다. 
```c++
// mathImplementationUnit.cpp
module;
#include <numeric>

module math;

namespace math {
    int add(int fir, int sec){
        return fir + sec;
    }

    int getProduct(const std::vector<int>& vec){
        return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());
    }
}
```

## 하위 모듈과 모듈 분할
* 모듈이 더욱 더 커지면 모듈 자체를 더 작은 조각을 나누어서 관리할 필요가 있습니다. 
* c++20에는 하위모듈과 모듈 분할이라는 두가지 접근 방식을 제공합니다. 
  
### 하위 모듈
* 하나의 모듈을 다른 여러 모듈을 도입한 후 다시 내보낼 수 있습니다. 
```c++
// mathModule.ixx
export module math;

export import math.math1;
export import math.math2;

// mathModule1.ixx
export module math.math1;

export int add(int fir, int sec){
    return fir + sec;
}

// mathModule2.ixx
export module math.math2;

export {
    int mul(int fir, int sec) {
        return fir * sec;
    }
}

// mathModuleClient.cpp
// 모듈을 통해서 하위 모듈을 접근할 수 있습니다. 
#include <iostream>
import math;

int main() {
    cout << '\n';
    cout << "add(3,4): " << add(3,4) << '\n';
    cout << "mul(3,4): " << mul(3,4) << '\n';
}

// mathModuleClient1.cpp
// 하위 모듈을 직접 접근 할 수 있습니다. 
#include <iostream>
import math.math1;

int main() {
    cout << '\n';
    cout << "add(3,4): " << add(3,4) << '\n';
}
```

### 모듈 분할 
* 하나의 모듈을 다수의 분할(partition)들로 쪼개는 기능을 제공합니다. 
```c++
// mathPartition.ixx
export module math;

export import :math1;
export import :math2;

// mathPartition1.ixx
export module math::math1;
export int add(int fir, int sec){
    return fir + sec;
}

// mathPartition2.ixx
export module math::math2;
export {
    int mul(int fir, int sec){
        return fir * sec;
    }
}
```