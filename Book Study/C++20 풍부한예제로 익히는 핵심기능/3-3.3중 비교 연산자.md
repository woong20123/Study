c++ 20에서 3중 비교 연산자(`<=>`)가 추가 되었습니다. (흔히 우주선 모양이여서 우주선 연산자라고 부릅니다.)
값 A B에 대해서 A < B, A == B, A > B 인지 판정합니다. 

### c++ 이전의 순서 판정 
* 비교 연산자를 선언 하려면 6가지 연산자를 모두 선언 해야 합니다. 
```c++
struct MyInt {
    int value; 
    explicit MyInt(int val) : value{val} {}
    bool operator == ( const MyInt & rhs) const {
        return value == rhs.value;
    }
    bool operator != ( const MyInt & rhs) const {
        return !(*this == rhs);
    }
    bool operator < ( const MyInt & rhs) const {
        return value < rhs.value;
    }
    
    bool operator <= ( const MyInt & rhs) const {
        return !(rhs < *this)
    }
    bool operator > ( const MyInt & rhs) const {
        return rhs < *this;
    }
    bool operator >= ( const MyInt & rhs) const {
        return !(*this < rhs);
    }
};
```

### c++20부터의 순서 판정
* c++20 에서는 3중 비교 연산자를 직접 정의하거나 =default를 사용해서 컴파일러가 자동으로 생성하게 할 수 있습니다. 
  * (==, !=, <, <= ,>, >=) 연산자가 자동으로 생깁니다. 
```c++
#include <compare>
#include <iostream>
struct MyInt{
    int value;
    explicit MyInt(int val) : value{val} {}
    // 3중 비교 연산자에 대한 명시적 선언
    auto operator<=>(const MyInt& rhs) const {
        return value <=> rhs.value;
    }
}

struct MyInt2{
    int value;
    // 3중 비교 연산자에 대한 암시적 선언
    explicit MyInt2(int val) : value{val} {}
    auto operator<=>(const MyInt2& rhs) const = default;
};

// c++Insights 에서 생성되는 암시적 3중 연산자
#include <compare>
struct MyInt2
{
  int value;
  inline explicit MyInt2(int val)
  : value{val}
  {
  }
  
  inline constexpr std::strong_ordering operator<=>(const MyInt2 & rhs) const /* noexcept */ = default;
  inline constexpr bool operator==(const MyInt2 & rhs) const /* noexcept */ = default;
};
```

### 비교 범주
* c++ 비교 범주는 다음과 같습니다. 
  * 강 순서(strong ordering)
  * 약 순서(weak ordering)
  * 부분 순서(partial ordering)
### std::string_ordering
* 모두 만족

### std::weak_ordering
* 동치만 빼고 만족

### std::partial_ordering
* 관계 연산자만 만족

#### 비교 범주를 가르는 세가지 성질
* 관계 연산자 성질
  * T는 여섯가지 비교 연산자(==, !=, < ,<=,>,>=)를 모두 지원합니다. 
* 동치(equivalent) 성질
  * a와 b가 동치일 때 f(a)와 f(b)도 동일 합니다. f는 전달받은 인수를 읽기 전용으로만 사용합니다. 
  * 즉 동치인 값은 구별 할 수 없습니다.
  
* 비교 가능 성질
  * T의 모든 값은 비교 가능입니다. 
  * a와 b에 대해서 a < b, a == b, a > b 중 하나가 참입니다. 
  * 예를 들어서 a = 5.5, b = NaN 일때 비교 성질을 충족하지 않습니다.

### 3중 비교 연산자 사용법
* 3중 비교 연산자는 다음과 같은 규칙을 가집니다. 
* (a <=> b) < 0 if lhs < rhs
* (a <=> b) > 0 if lhs > rhs
* (a <=> b) == 0 if lhs and rhs are equal/equivalent.

3중 비교 연산자는 암묵적으로 constexpr이므로 컴파일 시점 비교에 사용 될 수 있습니다. 

컴파일러 생성 3중 비교 연산자는 어휘순 비교를 사용합니다. 
어휘순 비교란 모든 기반 클래스를 왼쪽에서 오른쪽으로 흝으면서 각 클래스의 모든 비정적 멤버들을 선언 순서로 비교합니다.

### 표현식 재작성
`a < b` 같은 표현식을 만나면 컴파일러는 이 표현식을 `(a <=> b) < 0`과 같은 표현식으로 변환합니다. 
`a OP b` -> `(a <=> b) OP 0` 형식으로 변환합니다.
```c++
// https://cppinsights.io/
// 기존 코드
#include <compare>
struct MyInt2{
    int value;
    // 3중 비교 연산자에 대한 암시적 선언
    explicit MyInt2(int val) : value{val} {}
    auto operator<=>(const MyInt2& rhs) const = default;
};

int main() {
  MyInt2 a{1}, b{2};
  
  if(a == b){}
  if(a != b){}
  if(a > b){}
  if(a >= b){}
  if(a < b){}
  if(a <= b){}
  
  return 0;
}
// 변환 코드 
int main()
{
  MyInt2 a = MyInt2{1};
  MyInt2 b = MyInt2{2};
  if(a.operator==(b)) {
  } 
  
  if(!a.operator==(b)) {
  } 
  
  if(operator>(a.operator<=>(b), __cmp_cat::__unspec(0))) {
  } 
  
  if(operator>=(a.operator<=>(b), __cmp_cat::__unspec(0))) {
  } 
  
  if(operator<(a.operator<=>(b), __cmp_cat::__unspec(0))) {
  } 
  
  if(operator<=(a.operator<=>(b), __cmp_cat::__unspec(0))) {
  } 
  
  return 0;
}
```

## 사용자 정의 연산자와 컴파일러 생성 연산자
* 사용자 정의연산자와 컴파일러 생성 연산자가 동시에 있는 경우에는 사용자 정의 연산자를 우선 사용합니다. 


## 3중 비교 연산자 - cpp레퍼런스
표현식은 다음과 같은 객체를 반환합니다. 
* (a <=> b) < 0 if lhs < rhs
* (a <=> b) > 0 if lhs > rhs
* (a <=> b) == 0 if lhs and rhs are equal/equivalent.

축소 변환이 발생하면 형식 오류 입니다. 
그렇지 않고 피연산자가 정수 유형이면 연산자는 std::strong_ordering 유형의 prvalue를 생성합니다. 
* std::strong_ordering::equal 두 피연산자가 같다면
* std::strong_ordering::less 두 피연산자중 첫번째 피연산자가 작다면 
* std::strong_ordering::greater  두 피연산자중 첫번째 피연산자가 크다면
그렇지 않고 피연산자가 부동 소수점 유형이면 연산자는 std::partial_ordering 유형의 prvalue를 생성합니다. 
* std::partial_ordering::less 만약 a가 b보다 작다면
* std::partial_ordering::greater  if a is greater than b
* std::partial_ordering::equivalent  b와 equivalent 한경우 ( -0 <=> +0은 동일)
* std::partial_ordering::unordered (NaN <=> anything is unordered).

