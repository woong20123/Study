# 코루틴
* 함수의 제어흐름은 1번의 `호출`과 1번의 '반환'으로 이루어져 있습니다.
* 코루틴은 일시 정지, 재개를 여러 번 반복 할 수 있습니다. 
  * 일시 정지된 코루틴을 호출자가 파괴 할 수 있습니다. 
* `co_await`는 표현식 앞에 붙이는 단항 연산자입니다. 
  * 표현식을 일시 정지하거나 재개 할 수 있습니다.
* `co_yield`는 생성기 함수를 사용하는데 쓰입니다.?

### 생성기 함수
* 코루틴을 사용하지 않는 함수는 
```c++
// 코루틴을 사용하지 앟는 탐욕적 생성기 함수
std::vector<int> getNumber(int begin, int end , int inc = 1) {
    std::vector<int> numbers;
    for(int i = begin; i < end ; i += inc){
        numbers.push_back(i);
    }
    return numbers;
}

int main() {
    cout << '\n';

    const auto numbers = getNumber(-10, 11);
    for (auto n : numbers) cout << n << " ";
    cout << "\n\n";
    for (auto n : getNumber(0, 101, 5)) cout << n << " ";
    cout << "\n\n";
}
```

### 코루틴의 특징
* 코루틴은 이벤트 주도적 응용 프로그램을 작성할 때 흔히 사용됩니다. 
* 코루틴은 협조적 다중 태스팅(cooperative multitasking)에도 흔히 쓰입니다.
  * 각 작업 필요한 시간만큼 사용하되 sleep이나 waiting에 빠지지 않고 다른 작업에 시간을 양보합니다. 

### 코루틴 개념
* c++ 20의 코루틴은 비대칭, 일급, 스태없는 코루틴입니다.
* 비대칭 코루틴(asymmetric coroutine)이란 제어 흐름이 호출자에게로 돌아갑니다. 
* 일급 코루틴(first-class coroutine) 마치 데이터 처럼 행동하며 입급 함수와 비슷합니다. 
  * 일급 코루틴은 함수의 인수나 반환값으로 사용 될 수 있습니다.
* 스택 없는 코루틴은 최상위 코루틴의 실행을 일시 정지하거나 재개 할 수 있습니다. 
  * 호출된 코루틴이 제어 흐름을 양보하면 제어 흐름은 호출자로 돌아옵니다.
  * 실행 재개를 위해 코루틴은 자신의 상태를 스택과는 분리된 곳에 저장합니다.
  * 스택 없는 코루틴은 재개 가능 함수라고 부릅니다. 

### 코루틴 만들기
* 다음 네가지중에 하나라도 사용하는 함수는 코루틴이 됩니다. 
  * co_return
  * co_await
  * co_yield
  * 구간 기반 for 루프안의 co_await 표현식

#### 코루틴 팩토리와 코루틴 객체
* 아래 예제에서 `MyFuture<int>`는 코루틴 객체이고 `createFuture()`함수는 코루틴 팩토리입니다. 
```c++
MyFuture<int> createFuture() {
    co_return 2021;
}

int main() {
    auto fut = createFuture();
    std::cout << "fut.get() : " << fut.get() << '\n';
}
```
### 코루틴 제약 사항
* 코루틴에는 return 문이나 자료표 반환 형식, 제약 없는 자리표, 제약 있는 자리표를 사용 할 수 없습니다. 
* 가변 인수를 가진 constexpr 함수, consteval 함수, 클래스 생성자, 소멸자, main 함수는 코루틴이 될 수 없습니다.

### promise object
* 약속 객체는 코루틴 내부에서 조작되며 약속 객체를 통해서 결과 또는 예외를 전달 합니다 .
* 클라이언트는 멤버 함수 get_return_object가 돌려준 재개 가능 객체를 이용해서 코루틴과 상호 작용 합니다. 
#### 약속 객체 인터페이스

|멤버 함수|설명|
|:--|:--|
|기본생성자| 약속 객체는 반드시 기본 생성 가능이어야 합니다.|
|initial_suspend()| 코루틴이 일시 정지 상태로 시작하는지 여부를 돌려 줍니다.|
|final_suspend() noexcept | 코루틴이 일시 정지 상태로 종료되는지 여부를 돌려 줍니다.|
|unhandled_exception() | 예외가 발생하면 호출 됩니다. |
|get_return_object() | 코루틴 객체를 돌려줍니다. |
|return_value(val) | co_return val에 의해 호출 됩니다. |
|return_void() | co_return에 의해 호출 됩니다. |
|yield_value(val) | co_yield val에 의해 호출 됩니다. |

### 코루틴 핸들
* 코루틴 핸들은 코루틴 프레임의 실행 재개나 파괴를 외부에서 제어하는데 쓰이는 비소유 핸들입니다. 

### 코루틴 프레임
* 코루틴 프레임은 코루틴의 상태를 담는 내부 객체로 흔히 힙에 할당됩니다. 
* 코루틴 프레임은 앞에서 언급한 약속 객체와 코루틴의 인수들 복사본, 일시 정지 지점 나타내는 객체, 지역 변수들로 구성됩니다. 
* 저장 공간 절약을 위해서 컴파일러가 코루틴의 할당을 최적화 할 수 있으려면 두 조건이 충족되어야 합니다.
  * 코루틴 객체의 수명이 코루틴 호출자의 수명에 안에 포함되어야 합니다. 
  * 코루틴 호출자가 코루틴 프레임의 크기를 알아야 합니다.

### 대기 가능 객체와 대기자 객체
* yield_value, initial_suspend, final_suspend는 대기 가능 객체를 돌려 줍니다.
  * 컴파일러는 세 함수에 대해서 co_await 연산자를 적용합니다. 
* 대기 가능 객체는 Awaitable 콘셉트를 충족해야합니다.

### Awaitable 콘셉트
* 다음의 세 멤버 함수를 요구합니다. 

|함수 |설명|
|:--|:--|
|await_ready|결과가 준비되었는지의 여부를 돌려줍니다.|
|await_suspend|코루틴의 실행 재개 또는 파괴를 결정합니다.|
|await_resume|co_await 표현식의 결과를 제공합니다.|

#### std::suspend_alway와 std::suspend_never
* std::suspend_alway는 항상 코루틴을 정지합니다.
* std::suspend_never 결코 일시 정지 하지 않습니다. 

#### initial_suspend
* 약속 객체의 멤버 함수 initial_suspend의 리턴 값에 따라서 다르게 동작합니다.
  * std::suspend_always 객체를 돌려주면 그 코루틴은 일시 정지 상태로 시작합니다.
  * std::suspend_never 객체를 돌려주면 그 코루틴은 결코 일시 정지 상태가 되지 않습니다. 즉시 실행
```c++
// 일시 정지 상태로 시작
std::suspend_always initial_suspend() {
    return {}
}
// 바로 시작
std::suspend_never initial_suspend() {
    return {}
}
```
#### final_suspend
* 약속 객체의 멤버 함수 final_suspend의 리턴 값에 따라 다르게 동작합니다.
  * std::suspend_always 객체를 돌려주면 자신의 끝에서 일시 정지 됩니다.
  * std::suspend_neber 객체를 돌려주면 끝에서 일시 정지 되지 않습니다. 
```c++
```