c++ 20에서는 consteval과 constinit라는 두가지 키워드가 추가되었습니다. 

## consteval
consteval은 즉시 함수(immediate function)를 생성합니다.
즉시 함수란 하나의 컴파일 상수로 평가되는 함수로 컴파일 시점에 실행됩니다. 
즉시 함수는 암묵적으로 인라인 함수가 되며 반드시 constexpr 함수의 요구 조건을 충족해야 합니다. 
* 불충족 조건
  * static와 thread_local 변수
  * try 블록과 goto 문
  * 비 consteval 함수의 호출과 비 constexpr 변수의 사용

## consteval 함수와 constexpr 함수의 차이
consteval 함수는 상황에 따라서 컴파일 시점에 실행 될 수도 있고 런타임 시점에 실행 될 수 있습니다. 
consteval 함수의 경우에는 컴파일 시점에만 실행 될 수 있습니다. 

## constinit
constinit는 저장기간이 static이거나 스레드 변수에 적용 할 수 있습니다. 
constinit를 해당 변수들에 적용하면 컴파일 시점에 초기화 됩니다. 
다만 constinit는 상수성을 포함하지 않습니다. 

## constinit 변수와 constexpr 변수와 차이점
* const와 constexpr은 상수성을 포함하지만 constinit는 상수성을 포함하지 않습니다. 
* constinit는 지역 변수에 적용 할 수 없습니다. 

## Static Initialization Order Fiasco(정적 변수 초기화) 순서와 그 해법
코드의 서로 다른 번역 단위에 있는 정적 저장기간의 변수들이 순서에 의존적인 문제를 말합니다. 
정적 변수의 초기화는 두단계로 진행합니다. 
정적 단계(컴파일 시점)에서 상수 표현시을 초기화 할 수 있다면 정적 변수는 해당 상수 값으로 초기화 됩니다. 그렇지 않다면 0으로 
동적 단계(런타임 시점)에서 0으로 초기화 해둔 정적 변수들을 실행 시점의 값으로 초기화 됩니다.

```c++
// SIOF1.cpp
int sum(int l, int r){
    return l + r;
}

auto staticA = sum(1, 2);

// main.cpp
#include <iostream>
using namespace std;

extern int staticA;
auto staticB = staticA;

int main() {
 
    cout << "staticB : " << staticB << "\n";
}
```
아래와 같이 링커 순서에 따라서 정적 변수의 값이 변합니다. 
```bash
cl.exe /c main.cpp SIOF1.cpp
cl.exe /Fe:test1.exe SIOF1.obj main.obj # test1.exe 파일 생성
test1.exe # staticB : 3 출력
cl.exe /Fe:test2.exe main.obj SIOF1.obj # test2.exe 파일 생성
test2.exe # staticB : 0 출력
```

## c++20 이전에 해결 방법
### 지역 범위 정적 변수의 지연 초기화를 이용한 해범
지역 범위 정적 변수란 중괄호 안에서 선언된 정적 변수입니다. 
지역 범위 정적 변수는 이것이 처음 사용 될 때 생성 됩니다. 

```c++
// SIOF1.cpp
int sum(int l, int r){
    return l + r;
}

int & staticA() {
    // 지역 범위 정적 변수는 처음 사용 될 때 생성 됩니다. 
    static auto staticA = sum(1, 2);
    return staticA;
}

// main.cpp
#include <iostream>
using namespace std;

int & staticA();
// 링크 순서와 상관 없이 이곳에서 처음 사용 되기에 staticB은 일정한 값을 가집니다. 
auto staticB = staticA();

// 생략
```

### c++ 20에서는 constinit를 사용해서 해결 합니다.
* staticA는 컴파일 시점에 초기화 되기 때문에 링크 순서와 상관 없이 동일한 값을 가집니다. 
```c++ 
// SIOF1.cpp
// constexpr는 컴파일 시점에 평가 할 수 있다면 컴파일 시점 평가 함수로 평가 됩니다.
constexpr int sum(int l, int r){
    return l + r;
}

// staticA는 컴파일 시점에 초기화 됩니다.
constinit auto staticA = sum(1, 2);

// main.cpp
#include <iostream>
using namespace std;

extern constinit int staticA;
auto staticB = staticA;

// 생략
```

## consteval c++ 레퍼런스 번역
consteval - 함수가 즉시 함수임을 지정합니다. 즉 함수에 대한 모든 호출은 컴파일 타임 상수를 생성해야합니다.  
consteval 지정자는 함수 또는 함수 템플릿을 즉시 함수, 즉 모든 잠재적으로 평가된 호출로 선언합니다.  
즉시 함수는 constexpr 함수이며 경우에 따라 constexpr 함수 또는 constexpr 생성자에 적용 가능한 요구 사항을 충족 해야 합니다.  
constexpr과 마찬가지로 consteval은 지정자는 인라인을 의미합니다.  
그러나 소멸자, 할당 함수, 할당 해제 함수에는 적용되지 않을 수 있습니다.  
constexpr, consteval 및 constinit 지정자중 하나만 선언 지정자에 나타낼 수 있습니다.  
```c++
consteval int sqr(int n) {
  return n*n;
}
constexpr int r = sqr(100); // OK
 
int x = 100;
int r2 = sqr(x);            // Error: Call does not produce a constant
 
consteval int sqrsqr(int n) {
  return sqr(sqr(n));       // Not a constant expression at this point, but OK
}
 
constexpr int dblsqr(int n) {
  return 2*sqr(n);          // Error: Enclosing function is not consteval
                            // and sqr(n) is not a constant
}

consteval int f() { return 42; }
consteval auto g() { return &f; }
consteval int h(int (*p)() = g()) { return p(); }
constexpr int r = h();  // OK
constexpr auto e = g(); // ill-formed: a pointer to an immediate function is
                        // not a permitted result of a constant expression
```

```c++
#include <iostream>
 
// This function might be evaluated at compile-time, if the input
// is known at compile-time. Otherwise, it is executed at run-time.
constexpr unsigned factorial(unsigned n) {
    return n < 2 ? 1 : n * factorial(n - 1);
}
 
// With consteval we have a guarantee that the function will be evaluated at compile-time.
consteval unsigned combination(unsigned m, unsigned n) {
    return factorial(n) / factorial(m) / factorial(n - m);
}
 
static_assert(factorial(6) == 720);
static_assert(combination(4,8) == 70);
 
int main(int argc, const char*[]) {
 
    constexpr unsigned x{factorial(4)};
    std::cout << x << '\n';
 
    [[maybe_unused]]
    unsigned y = factorial(argc); // OK
//  unsigned z = combination(argc, 7); // error: 'argc' is not a constant expression
}
```
## constinit c++ 레퍼런스 번역
constinit - 변수에 정적 초기화(zero initialization, constant intialization)이라고 선언합니다. 아니면 형식 오류를 반환합니다. 
constinit 지정자는 정적 또는 스레드 저장 기간을 가진 변수에 선언됩니다. 
변수가 constinit 선언된 경우 초기화 선은 constinit로 적용 해야 합니다.
constinit 선언된 변수에 동적 초기화 구문이 있으면 형식 오류를 반환합니다. 
선언된 변수가 참조인 경우 constinit와 constexpr과 동일합니다.
선언된 변수가 객체인 경우 constexpr은 static initialization과 constant destruction을 가져야 한다고 명령하고 const 형식로 만듭니다. 
constinit의 경우에는 객체를 const 형식으로 지정하지 않습니다. 
```c++
const char *g() { return "dynamic initialization"; }
constexpr const char *f(bool p) { return p ? "constant initializer" : g(); }
 
constinit const char *c = f(true); // OK
// constinit const char *d = f(false); // error
```
constinit 또한 thread_local 변수가 이미 초기화되었음을 컴파일러에 알리기 위해 초기화 하지 않는 선언에서 사용 할 수 있습니다. 
숨겨진 가드 변수로 인해 발생 할 수 있는 오버 헤드를 줄일 수 있습니다. 
```c++
extern thread_local constinit int x;
int f() { return x; } // no check of a guard variable needed
```