## DLL을 사용해야 하는 이유
* 애플리케이션의 기능 확장
  * DLL은 프로세스의 주소 공간에 동적으로 로드 될 수 있습니다. 
  * 애플리케이션이 수행중이여도 수행할 코드를 로드 할 수 있습니다. 
* 프로젝트 관리의 단순화
  * 개발 과정에서 여러 그룹이 서로 다른 작업을 수행한다면 DLL을 통해서 관리를 쉽게 할 수 있습니다. 
* 메모리 절약
  * 두개 이상의 애플리케이션이 동일한 DLL을 사용한다면 램에 한번만 로드하고 애플리케이션들이 공유할 수 있습니다. 
  * c/c++ 런타임 라이브러리가 좋은 예입니다. 
  * 정적 라이브러리를 사용하게 되면 메모리에 여러번 로드 됩니다. 
* 리소스 공유
  * DLL은 다이얼 로그릐 박스 템플릿, 문자열, 아이콘, 비트맵등 많은 리소스를 포함 할 수 있습니다. 
* 플랫폼 차별성 해소 
  * 다양한 윈도우 버전들은 서로 다른 함수를 제공합니다.
  * 최신 기능의 함수를 호출하면 윈도우 버전별로 프로세스의 구동여부가 달라집니다. 
  * 이러한 최신 기능을 DLL로 분리해두면 해당 기능만 사용 못하고 프로세스는 구동될 수 있습니다. 

## DLL과 프로세스 주소 공간 
* 일반적으로 DLL 파일은 다른 애플리케이션에서 호출 하는 함수들의 집합인 모듈로 구성됩니다. 
* 빌드시 /DLL 옵션을 지정해주면 DLL 파일 이미지에 특수한 정보를 포함 시킵니다.
* 애플리케이션이 DLL을 호출 하기 위해서 DLL을 프로세스 주소 공간에 로드 해야 합니다.
  * 이후로 DLL을 호출 하면 생성된 오브젝트들은 호출된 스레드 및 프로세스가 소유하게 됩니다.
  * VirtualAlloc 함수를 사용하면 DLL을 호출한 스레드가 속해있는 프로세스의 주소공간에 예약 됩니다. 

## DLL 작성 방법 및 묵시적 링킹 방법
### DLL 생성
1. export 할 함수의 원형 및 구조체, 심벌등을 포함하는 헤더파일 생성(DLL 파일 생성하기 위한 소스 코드는 이 헤더 파일을 include 해야 합니다.)
2. DLL 모듈 내에서 포함 시킬 함수 및 변수를 구현하는 c++ 소스 코드 모듈 작성 
3. DLL 모듈을 생성하기 위해서 각 소스 코드를 컴파일하여 obj 파일 생성
4. 링커를 통해서 obj파일을 결합하여 DLL 이미지 파일 생성합니다. 
5. lib 파일을 생성합니다. `lib 파일`에는 export하는 함수나 변수의 심범 이름을 유지합니다. 
   1. 실행 모듈을 생성할 때 반드시 필요합니다. 
6. DLL을 사용하려는 실행 모듈에서는 헤더 파일을 추가해야 합니다. 
7. import할 함수/변수를 참조하는 c++ 소스 파일 작성
8. 컴파일러는 각 소스 파일에 대해서 obj 파일 생성
9. 링커는 `lib 파일`을 확인하여 obj 파일을 결합하여 exe를 생성
   1. exe파일에는 어떤 DLL이 필요한지 import한 심볼 정보가 들어 있습니다. 

* `__declspec` 이란 스토리지 클래스 정보를 지정하기 위한 확장 특성 구문 여기서는 dllexport, dllimport를 지정합니다. 
  * `__declspec(dllexport)` 한정자를 컴파일러가 확인하면 obj파일에 대한 정보를 .lib 파일을 기록합니다. 

## 실행 모듈의 수행
* 실행 파일이 수행되면 프로세스를 위한 가상 주소 공간을 생성하고 로더는 실행 모듈을 프로세스 주소공간에 매핑합니다. 
  * 이후 DLL 파일들을 찾아서 프로세스 주소공간에 매핑합니다. 
### DLL을 검색하는 조건
1. 실행 파일 이미지가 있는 디렉터리
2. GetSystemDirectory 함수의 반환 값인 윈도우 시스템 디렉토리
3. 16비트 시스템 디렉토리(윈도우 디렉토리 이하 System 하위 폴더)
4. GetWindowsDirectory 함수 반환 값이 윈도우 디렉토리
5. 프로세스의 현재 디렉토리
6. PATH 환경 변수에 포함된 디렉토리