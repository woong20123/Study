## 고정 특징
* 템플릿에서 특정 템플릿 파라미터의 특성으로 간주되는 값을 `특질(Trait)`이라고 합니다
* 특질 종류
  * 고정 특질과 같이 데이터 형에 고정되는 것이 있습니다. 
  * 값 특질은 데이터형에 고정되지 않는 특성을 말합니다.
```c++

// 특질 선언 및 정의
template<typename T>
class AccumulationTraits;

template<>
class AccumulationTraits<char> {
public:
	// AccT는 고정 특질
	using AccT = int;
	// 값 특질
	static AccT const zero() {
		return 0;
	}
};

template<>
class AccumulationTraits<short> {
public:
	using AccT = int;
	static AccT const zero() {
		return 0;
	}
};

template<>
class AccumulationTraits<int> {
public:
	using AccT = long;
	static AccT const zero() {
		return 0;
	}
};

template<>
class AccumulationTraits<unsigned int> {
public:
	using AccT = long;
	static AccT const zero() {
		return 0;
	}
};

template<>
class AccumulationTraits<float> {
public:
	using AccT = double;
	static AccT const zero() {
		return 0;
	}
};

// 특질을 템플릿 파라미터로 추가 할 수 있습니다. 
// 함수 템플릿은 기본값을 설정할 수 없기 때문에 클래스 템플릿으로 선언합니다. 
template<typename T, 
typename AT = AccumulationTraits<T>>
class Accum {
public:
	using AccT = typename AccumulationTraits<T>::AccT;
	static typename AT::AccT accum(T const * beg, T const * end) {
		AccT total = AccumulationTraits<T>::zero();
		while (beg != end) {
			total += *beg;
			++beg;
		}
		return total;
	}
};

// T를 리턴값을 사용하면 작은 단위의 값을 사용할 때 오버 플로가 발생 가능
// 리턴 값 및 total 저장 값을 특질로 구성 하면 문제를 해결 할 수 있습니다
template<typename T>
typename Accum<T>::AccT accum(T const * beg, T const * end)
{
	return Accum<T>::accum(beg, end);
}

int main() {
	int num[] = { 1,2,3,4,5 };
	cout << accum(&num[0], &num[5]) / 5 << '\n';

	char name[] = "templates";
	int length = sizeof(name) - 1;
	cout << name << " is " << accum(&name[0], &name[length]) / length << '\n';
}
```

## 정책과 정책 클래스 
* 위의 예제에서는 전달 받은 데이터들의 합만 구했지만 다양한 방식의 기능을 제공하고 싶을 때가 있습니다.
* 그때 필요한 것이 정책(Policy)라고 하며 해당 기능이 담긴 클래스를 정책 클래스라고 합니다.
```c++


// 특질 선언 및 정의
template<typename T>
class AccumulationTraits;
// 생략....

class SumPolicy {
public:
	template<typename T1, typename T2>
	static void accumulate(T1 & total, T2 const & value) {
		total += value;
	}
};

class MultPolicy {
public:
	template<typename T1, typename T2>
	static void accumulate(T1 & total, T2 const & value) {
		total *= value;
	}
};

// 특질을 템플릿 파라미터로 추가 할 수 있습니다. 
// 함수 템플릿은 기본값을 설정할 수 없기 때문에 클래스 템플릿으로 선언합니다. 
template<typename T, 
        typename Policy = SumPolicy,
        typename AT = AccumulationTraits<T>>
class Accum {
public:
	using AccT = typename AccumulationTraits<T>::AccT;
	static typename AT::AccT accum(T const * beg, T const * end) {
		AccT total = AccumulationTraits<T>::zero();
		while (beg != end) {
            // 정책 클래스 적용
			Policy::accumulate(total, *beg);
			++beg;
		}
		return total;
	}
};

// T를 리턴값을 사용하면 작은 단위의 값을 사용할 때 오버 플로가 발생 가능
// 리턴 값 및 total 저장 값을 특질로 구성 하면 문제를 해결 할 수 있습니다
template<typename T>
typename Accum<T>::AccT accum(T const * beg, T const * end)
{
	return Accum<T>::accum(beg, end);
}

int main() {
	int num[] = { 1,2,3,4,5 };
	cout << Accum<int, MultPolicy>::accum(&num[0], &num[5]) << '\n';
}
```

## 특질과 정책의 차이점
* 특질 특징
  * 대부분 자연 스러운 기본 값을 가집니다. 
  * 특질 파라미터는 하나 이상의 주요 파라미터에 긴밀히 종속되어 있습니다.
  * 특질은 멤버 함수보다는 데이터 형이나 상수와 결합됩니다.
  * 특질은 특질 템플릿으로 모아집니다. 
* 정책 특징
  * 행위에 초점을 맞춥니다. 
  * 템플릿의 다른 파라미터와 크게 관련이 없습니다. 
  * 대체로 멤버 함수와 결합됩니다. 
  * 정책은 일반 클랙스나 클래스 템플리승로 모을 수 있습니다.

## 클래스형 결정