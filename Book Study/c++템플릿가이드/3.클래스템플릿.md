## 클래스 템플릿
```c++
#include <vector>
#include <stdexcept>

template<typename T>
class Stack {
private :
	std::vector<T> elems;

public:
	void push(T const &);
	void pop();
	T top() const;
	bool empty() const {
		return elems.empty();
	}
};

// 생략...
``` 
## 템플릿 특수화
* 기존의 템플릿과 다르게 동작하도록 구현할 수 있습니다. 
* 템플릿 파라미터 선언을 다음과 같이 변경합니다. `template<>`
* `T` 구문을 변경하려는 타입으로 변경합니다.
```c++
#include <vector>
#include <stdexcept>

template<>
class Stack<std::string> {
private :
	std::deque<std::string> elems;

public:
	void push(std::string const &);
	void pop();
	std::string top() const;
	bool empty() const {
		return elems.empty();
	}
};

// 생략.
```

## 부분 특수화
* 클래스 템플릿은 부분적으로 특수화 할 수 있습니다. 
```c++
// 템플릿 원본
template<typename T1, typename T2>
class MyClass {

}

Myclass<int, float> mif;

// 부분 특수화 : 두 템플릿 파라미터가 같은 값을 가짐
template<typename T>
class MyClass<T, T> {

}
Myclass<float, float> mff;

// 부분 특수화 : 두번째 데이터 형이 int
template<typename T>
class MyClass<T, int> {

}
Myclass<float, int> mfi;

// 부분 특수화 : 두 템플릿 파라미터가 포인터 형임
template<typename T1, typename T2>
class MyClass<T1*, T2*> {

}
Myclass<int*, float*> mp;
```