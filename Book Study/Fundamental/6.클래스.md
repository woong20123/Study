## 클래스와 구조체 차이
* c 컴파일러를 사용하면 구조체에는 함수를 추가 할 수 없지만 c++ 컴파일러를 사용하면 함수가 추가 할 수 있습니다. 
* 기본 접근 지정자는 구조체는 public, 클래스는 private입니다. 

## 클래스의 메모리 구조
* 정적 멤버변수는 클래스에 의해서 접근할 수 있다는 것 빼고는 전역 변수와 같습니다. 
* 멤버 변수는 선언 순서대로 메모리 코드 영역에 위치합니다. 
  * 멤버 변수에 접근 할 때는 오프 셋을 계산하여 접근합니다. 
* 구조체 멤버 맞춤 옵션을 통해서 cpu의 메모리 접근 횟수를 최적화 합니다. 
  * 기본 값 현재 `zp8`
```c++ 
#include <stddef.h>
class CTest
{
public:
	char m_Char;
	int m_Int;
	double m_Double;

	static int m_SInt;

	int MemberFunc() 
	{
		return m_Int;
	}
};

void PrintOffset()
{
	
	int OffsetC = offsetof(CTest, m_Char);
	int OffsetI = offsetof(CTest, m_Int);
	int OffsetD = offsetof(CTest, m_Double);

    // [0, 4, 8] 
    // 결과가 다음과 같은 이유는 /zp8 옵션을 사용하기 떄문에
	cout << "[" << OffsetC << ", " << OffsetI << ", " << OffsetD << "]" << endl;
}

int main()
{
	PrintOffset();
	return 0;
}
```

## 클래스의 크기
* 멤버 변수가 존재 하지 않는 클래스의 경우 원래는 크기가 0이지만 메모리를 점유하기 위해서 1바이트의 크기를 배정합니다. 
* 멤버 변수가 존재 하지 않고 가상 함수가 있는 클래스의 경우 8바이트(x64)를 가집니다. 
  * 가상 함수 테이블을 가르키는 vfptr이라는 값을 가져야 하기 때문에 포인터 하나가 추가됩니다 
```c++
class CEmpty
{
public:
	CEmpty() {};
	~CEmpty() {};
};

class CVirtualEmpty
{
public:
	CVirtualEmpty() {}
	virtual ~CVirtualEmpty() {}
};

int main()
{
	CEmpty e;
	CVirtualEmpty ve;

	cout << "CEmpty Size : " << sizeof(CEmpty) << endl;
	cout << "CVirtualEmpty Size : " << sizeof(CVirtualEmpty) << endl;

	return 0;
}
```

## 생성자와 소멸자
* 생성자나 소멸자가 명시적으로 정의되어 있지 않다면 특별히 필요하지 않다면 컴파일러는 굳이 암시적으로 생성자나 소멸자를 정의하지 않습니다. 
  * 부모 클래스의 생성자가 명시적으로 정의되어 있다면 자식 클래스의 생성자가 암시적이여도 컴파일러는 정의합니다.
  * 소멸자도 동일하게 동작합니다. 

## 생성자와 소멸자의 호출 순서
```c++
class CParent
{
public:
	CParent()
	{
		cout << _T("CParent - Constructor") << endl;
	}

	~CParent()
	{
		cout << _T("CParent - Destructor") << endl;
	}
};

class CChild : public CParent
{
public:
	CChild()
	{
		cout << _T("CChild - Constructor") << endl;
	}

	~CChild()
	{
		cout << _T("CChild - Destructor") << endl;
	}
};

/*
결과
CParent - Constructor
CChild - Constructor
CChild - Destructor
CParent - Destructor
*/

int main() {
	CChild c;
	return 0;
}
```
* 일반적으로 부모와 자식간의 생성자 및 소멸자의 클래스 호출 순서는 예제 처럼 부모 생성자 -> 자식 생성자 -> 자식 소멸자 -> 부모 소멸자
  * 실제로은 자식의 생성자가 먼저 호출이 됩니다. 다만 선처리 작업을 통해서 부모의 생성자가 호출 됩니다. 
```c++
CChile()
{
    // 선처리 영역
    // 부모의 클래스 생성자 호출
    // 멤버가 클래스인 경우 생성자 호출
    // .. 기타 선처리

    // 자식의 생성자 함수 수행
    cout << _T("CChild - Constructor") << endl;
}
```

## virtual 소멸자 
* 가상 함수 테이블을 통해서 부모 클래스로 업 캐스팅된 객체에서 자식 클래스의 소멸자를 찾아서 호출 할 수 있습니다. 
  * 또한 vfprt을 사용하는 RTTI 정보를 사용 할 수 있습니다. 
```c++
// CParent, CChild 생략
// CParent의 소멸자가 아닐 경우에는 소멸자를 찾아서 호출 할 방법이 없습니다. 
/* 
[결과]
 CParent - Constructor
 CChild - Constructor
 CParent - Destructor
*/ 
int main() {
	CParent * pParent = new CChild;
	delete pParent;
}
```

## 복사 생성자와 복사 대입 연산자 
```c++
void main()
{
    int x = 1;

    // 복사 생성자 호출
    int y1(x);

    // 복사 생성자 호출
    // 복사 대입 연산자 같기 때문에 꼭 외어야 합니다. 
    int y2 = x;

    int y3;
    // 복사 대입 연산자 
    y3 = x;
}
```
### 복사 생성자 
* 복사 생성자를 선언하지 않는 경우에는 암시적 복사 생성자가 생성됩니다. 
* 컴파일러에서 생성되는 암시적 복사 생성자 
  * 부모 클래스의 복사 생성자호출 
  * 멤버가 클래스인 경우 복사 생성자 호출
  * 멤버가 기본 타입인 경우 메모리 복사
  * 멤버가 배열인 경우 원소 타입에 따라서 처리
  * 멤버가 참조 타입인 경우 대상 복사
* 명시적 복사 생성자의 호출 방식은 다음과 같습니다.
```c++
class CTest
{
public :
    // 기본 생성자
    CTest() 
    {
        this.m_Value = 1;
    }

    // 복사 생성자
    CTest(const CTest& obj)
    {
        this.m_Value = obj.m_Value;
    }
// 생략
}
```
* 다시 한번 기억 할 점을 기록합니다. 
  * `명시적인 복사 생성자`는 부모나 멤버 클래스의 `기본 생성자`를 호출 합니다. 
  * `암시적인 복사 생성자`는 부모나 멤버 클래스의 `복사 생성자`를 호출 합니다.

### 복사 대입 연산자