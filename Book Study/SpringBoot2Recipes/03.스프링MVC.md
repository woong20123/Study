## 스프링 MVC로 시작하기 
* 이클립스에서 셋팅
  * 프로젝트 우클릭 -> spring -> editer starter 
    * Spring web 추가
* 프로젝트 실행시 다음 작업 실행
  * 내장형 톰캣을 8080 포트로 시작한다.
  * 두서너 개의 기본 서블릿 필터를 등록하고 활성화 한다.
    * CharacterEncodingFilter 
      * spring.http.encoding.charset 속성으로 설정 가능한 구성이며 기본적으로 UTF-8 인코등
    * HiddenHttpMethodFilter
      * 실제 HTTP 메소드를 정의하는 _method로 이름 지어진 숨겨진 양식 필드의 사용을 활성화함
      * spring.mvc.hiddenmethod.filter.enabled로 설정 가능
    * FormContentFilter
      * PUT, PATCH, DELETE 요청 양식 할당에 용이하도록 래핑함
    * RequestContextFilter
      * 현재 요청을 스레드로 노출해서 Jersey와 같은 스프링 MVC가 아닌 것도 사용할 수 있도록 합니다.
  * .css, .js, favicon.ico 같은 정적 리소스를 구성한다. 
  * WebJars로 통합을 활성화한다.
    * WebJars란
      * JVM 기반의 웹 어플리케이션에서 클라이언트 의존성을 쉽게 관리함
      * JVM 기반의 빌드 툴을 사용해서 클라이언트측 의존성을 다운로드
      * 사용하고 있는 클라이언트측의 의존성을 파악할 수 있음
      * 수동적인 종속성을 자동으로 해결하고 선택적으로 RequireJS를 통해 적재
      * 메이븐 중앙저장소를 통해 배포 
      * JSDELIVR에서 제공하는 공개 CDN을 사용 가능
    * 기본 오류 처리 기능을 구성한다.
    * 필요한 컴포넌트로 DispatcherServlet을 사전 구성한다.
      * Servlet이란?
        * 자바를 사용해서 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말함
        * 서블릿은 자바 코드 안에 HTML을 포함한다. 
      * DispatcherServlet이란?
        * 모든 http 요청을 받아서 요청을 처리할 handler에게 분배하는 역활을 함
        * Spring의 Front Controller가  DispacherServlet임
      * DispatcherServlet 동작 원리
        * 특별한 타입의 빈들을 찾거나 기본 전략에 맞는 빈들을 등록함
        * HandlerMapping : 핸들러를 찾아주는 인터페이스
        * HandlerAdapter : 핸들러를 실행하는 인터페이스 
        * HandlerExceptionResolver
        * ViewResolver

* Controller 등록 작업
  * @RestController는 해당 클래스가 스프링 부트로부터 감지될 대상이라는 것을 가르킴
  * @GetMapping은 특정 URL에 도착하는 GET 요청을 매핑합니다. 
* 예제 코드
```java
// HelloWorldController.java
@RestController
public class HelloWorldController {
	@GetMapping("/")
    // @RequestMapping(value="/", method=RequestMethod.GET)
	public String hello() {
		return "Hello, World, from Spring Boot 2!";
	}
}

// HelloWorldControllerTest.java
@WebMvcTest(HelloWorldController.class)
public class HelloWorldControllerTest {
	@Autowired
	private MockMvc mockMvc;
	
	@Test
	public void testHelloWorldController() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/"))
		.andExpect(status().isOk())
		.andExpect(content().string("Hello World, from Spring Boot 2!"))
		.andExpect(content().contentTypeCompatibleWith(MediaType.TEXT_PLAIN));
	}
}
```

## 스프링 MVC로 REST 리소스 노출하기 
* JSON 마샬링을 하려면 JSON 라이브러리 필요
  * Jackson 라이브러리
* java Optional 
  * NullPointerException 피하기 위해서 제공되는 
* @Service
  * 스프링 부트에서 이클래스를 감지하고 객체를 생성함
* 예제로 작성한 책을 Rest 리소스로 노출하려면 BookController라는 클래스를 만듭니다.
  * @RestController 애노테이션을 추가합니다.
* Mockito 라이브러리
  * 유닛 테이스를 위한 java mocking framework
  * mock()을 사용해서 목 객체를 만들어서 반환합니다. ex) Person p = mock(Person.class);
  * @Mock을 사용하면 목객체를 바로 생성할 수 있음
  * when 메서드를 사용하면 지정 메서드가 특정 값을 리턴할 수 있게 합니다. 
    * when(p.getName()).thenReturn("JDM");
    * when(p.find(anyInt())).thenReturn("유진"); // 어떤 입력 숫자갑이여도 다음과 같이 리턴
  * doThrow를 사용하면 예외를 던집니다.
  * doNoting을 사용하면 void로 선언된 메서드에 when을 설정합니다.
  * verify는 해당 구문이 호출 되었는지 체크 합니다.
    * verify(p, times(1)).setName(any(String.class));

* JsonPath 란?
  * Json 객체를 탐색하기 위한 표준화된 방법 
  * `$`는 ROOT 를 표현합니다. 
  * [start:end] 배열의 slice 연산자
  * [?(<expression>)] 필터 표현식 참인 경우 매칭 요소
    * 예) book[?(@.price==49.99)]
  * dot 표현식
    * 예) $.store.book[0].title
  * braket 표현식
    * 예) $[`store`][`book`][0][`title`]
  * 자주사용하는 표현식 예제
    * $..* : 전체 요소(.. 딥 스캔)
    * $[?(@.age == 26)] : age가 26인 요소
    * $[0][`balance`] : 첫번째 요소의 balance
    * $[*]['age']  : 모든 요소의 나이
    * $..[`name`][`first`] : 모든 요소의 성
* Xml은 Xpath라는 표현식이 존재함
  
  
* RestController 테스트

  
* 예제 소스
```java
// Book.java 파일
public class Book {
	private String isbn;
	private String title;
	private List<String> authors = new ArrayList<>();

	public Book() {}
	
	public Book(String isbn, String title, String... authors) {
		this.isbn = isbn;
		this.title = title;
		this.authors.addAll(Arrays.asList(authors));
	}
  // ... 생략
}

// BookService.java 파일
public interface BookService {
	Iterable<Book> findAll();
	Book create(Book book);
	Optional<Book> find(String isbn);
}

// InMemoryBookService.java 파일
// BookService 실제 구현 
@Service
public class InMemoryBookService implements BookService {
	
	private final Map<String, Book> books = new ConcurrentHashMap<>();
	
	@Override
	public Iterable<Book> findAll(){
		return books.values();
	}
	
	@Override 
	public Book create(Book book) {
		books.put(book.getIsbn(), book);
		return book;
	}
	
	@Override
	public Optional<Book> find(String isbn){
		return Optional.ofNullable(books.get(isbn));
	}
}

// BookController.java 파일
// Book과 관련된 처리를 담당합니다.
@RestController
@RequestMapping("/books")
public class BookController {
	private final BookService bookService;
	
	public BookController(BookService bookService) {
		this.bookService = bookService;
	}
	
	@GetMapping
	public Iterable<Book> all() {
		return bookService.findAll();
	}
	
	@GetMapping("/{isbn}")
	public ResponseEntity<Book> get(@PathVariable("isbn") String isbn){
		return bookService.find(isbn).map(ResponseEntity::ok).orElse(ResponseEntity.notFound().build());
	}
	
	@PostMapping
	public ResponseEntity<Book> create(Book book, UriComponentsBuilder uriBuilder){
		Book created = bookService.create(book);
		URI newBookUri = uriBuilder.path("/books/{isbn}").build(created.getIsbn());
		return ResponseEntity.created(newBookUri).body(created);
	}
}

```