* 이번장에서는 스프링 데이터 모듈을 사용해서 리액티브 방식으로 데이터에 엑세스하는 방식을 학습합니다. 

## 최근 데이터 처리 패턴 
* 마이크로서비스는 응용 프로그램 특히 클라우드 네이티브 애플리케이션에서 가장 중요한 아키텍쳐 스타일입니다. 
  * 대부분의 경우 이 아키텍처를 사용하면 소프트웨어를 신속하게 개발 할 수 있습니다. 
  * https://cncf.io/about/charter 
### 도메인 주도 설계 
* 에릭 에반스가 쓴 도메인 주도 설계는 마이크로서비스 아키텍쳐를 위한 중요한 이론적 기초를 제공합니다.
* DDD(Domain-driven design) 공통 어휘(컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델의 무결정의 유지하기 위한 일련의 원칙을 공식화합니다. 
* DDD가 중요한 결과는 DDD의 관점에 정의한 각각의 바운디드 컨텍스트(bounded context)가 하나의 마이크로 서비스로 매핑됩니다. 
  * http://dddcommunity.org/resources/ddd_terms.

### 마이크로서비스 시대의 데이터 저장소
* 마이크로 서비스 아키텍처가 도입됨에 따라서 서비스간의 데이터 저장소를 공유하지 않게 된 것입니다.
  * 즉 논리적으로 분할된 각각의 서비스가 데이터베이스를 소유하고 관리하는 경우 서비스API 호출을 제외한 방식으로 다른 서비스의 데이터에 액세스 할 수 없는 것이 이상적입니다.
    * 데이터 베이스 스키마와 강한 결합 없이 서비스를 계속 진화 시킬수 있어야 함
    * 더 섬세한 자원을 관리 할 수 있어야 함
    * 수평적으로 확장이 가능해야 함
    * 가장 적합한 영속 계층 구현을 사용할 수 있어야 함 
* 스토리지 분리 중 하나의 데이터 베이스에 각각의 서비스에 대해 별도의 스키마를 할당 하는 방식
  * 이러한 구성은 구현이 쉽고 서버 리소스를 적게 필요로 하며 개발 초기 단계에서 매우 매력적입니다. 
  * 동일한 데이터 베이스에 저장되면 둘이상의 서비스에 속한 데이터를 수정할 수 없도록 해야합니다.
* 서비스마다 별도의 데이터 베이스 구성하는 방법 
  * 더 많은 관리가 필요하지만 각각의 데이터 베이스를 서비스에 맞게 세부적으로 설정할 수 있습니다.
  * 필요한 경우 해당 데이터베이스만 수직 또는 수평으로 확장 할 수 있습니다. 
* 두가지 방법을 섞어서 구성 할 수도 있으며 다른 종류의 데이터베이스 서버를 동시에 사용하는 것도 가능합니다. 

### 다중 저장소 영속화
* 다중 언어 프로그램이라는 용어로 비즈니스 및 기술적 맥락에서 가장 적합한 언어를 사용해 최고의 효과를 얻는 수 있는 아이디어를 표현합니다. 
* 동시에 데이터 영속성 분야에서도 유사한 생각의 변화가 있었습니다. 
  * 요즘에는 시스템이 둘 이상의 데이터 베이스 기술을 사용하는 것이 거의 일상적인 일입니다. 
  * 관계형 데이터베이스 시스템(RDBMS)은 동일한 ACID 원칙을 토대로 구축되며 유사한 SQL 언어로 제공합니다.
  * 최근에 등장한 NoSQL 데이터 베이스는 특정 사례에 더 나은 기능을 제공합니다. 

### 서비스로서 데이터 베이스 
* 잘 설계된 마이크로 서비스 아키텍쳐에서는 모든 서비스가 상태에 의존적이지 않으며, 모든 상태 정보는 데이터 지속성을 관리하는 방법을 알고 있는 특정 서비스에 저장됩니다. 
* 클라우드 환경에서는 서비스가 상태를 저장하지 않으면서 효율적으로 확장할 수 있고 높은 가용성을 가집니다. 
* 이러한 솔루션은 일반 데이터 베이스(MySQL, PostgreSQL, Redis)를 수정해서 제공하거나 클라우드용으로 설계된 DB(AWS Redshift, 구글 BitTable, 마소의 CosmosDB)
* 잘 알려진 클라우드 기반 데이터 저장소 및 DB 서비스 
  * AWS S3는 웹 서비스 인터페이스를 통해 키-값 저장소를 제공합니다. 파일, 이미지, 백업 또는 바이트 버킷으로 표시할 수 있는 기타 정보를 저장하도록 설계합니다. 
  * AWS DynamoDB는 아마존 AWS에서만 사용할 수 있는 NoSQL 데이터 베이스로 여러 데이터 센터에서 동기식 복제를 제공합니다. 
  * AWS Redshift는 병렬 처리 기술(MPP)을 기반으로 구축된 데이터 웨어 하우스 입니다. 대용량 데이터 분석 작업에 유용합니다. 
  * Heroku PostgreSQL
  * Google Cloud SQL은 구글에서 제공하는 PostgreSQL 및 MySQL 데이터 베이스입니다.
  * Google BigTable은 낮은 지연 시간과 높은 처리량을 보장하면 대량 작업을 처리 할 수 있는 스토리지입니다. 
  * Azure Cosmos DB는 마소가 제공하는 전 세계적으로 분산된 다중 모델 데이터베이스입니다. 

### 마이크로 서비스 사이의 데이터 공유 
* 실제 비즈니스 시스템에서는 클라이언트 요청을 처리하기 위해서 두 개 이상의 서비스가 소유한 데이터를 쿼리 해야할 때가 있습니다. 
  * 마이크로 서비스 아키텍쳐 이전에는 이 작업을 단일 조인 쿼리로 구현 했습니다. 마이크로 서비스에서는 금지되는 방식입니다. 
  * 다중 서비스 요청을 처리하려면 주문 및 결제 서비스를 모두 쿼리하고 필요한 데이터를 변환해 집계 결과를 클라이언트에 반환하는 어뎁터 서비스를 구현해야합니다. 
  * 만약 두 서비스간에 데이터 요청이 많거나 의존성이 강하다면 하나의 서비스로 병합하는 게 나을 수도 있습니다. 
* 해당 문제를 해결하는 방안중에 가장 많이 사용되는 것은 `분산 트랜젝션`과 `이벤트 기반 아키텍쳐` 입니다. 
  
#### 분산 트랜젝션 
* 분산 트랜젝션은 네트워크가 분리된 두 개 이상의 컴퓨터 시스템에 저장된 데이터를 업데이트하는 트랜젝션입니다. 
* 실제로 대부분의 데이터 베이스 시스템은 강력하고 엄격한 2단계 락을 사용해서 글로벌 직렬성(Serializability)을 보장합니다.
  * 직렬성이라고 하면 각각의 트랜젝션이 일정한 순서를 가지고 순차적으로 실행됨을 말합니다. 
* 분산 트랙젝션은 여러개의 마이크로 서비스로 구성된 시스템에서는 권장 되지 않습니다. 
  * 몇가지 이유가 있지만 가장 중요한 것은 다음과 같습니다. 
    * 분산 트랜젝션을 사용하는 서비스에는 2단계 커밋을 지원하는 API가 필요하지만 이를 구현하기가 쉽지 않습니다. 
    * 분산 트랜젝션을 사용하는 마이크로 서비스는 강하게 결합되어 있고 이는 마이크로 서비스에서는 권장하지 않는 방식입니다.
    * 분산 트랜젝션은 확장이 되지 않습니다. 이로 인해서 대역폭이 제한되고 시스템 확장이 저하됩니다.ㅏ 
#### 이벤트 기반 아키텍쳐
* 메시지 브로커를 사용해서 이벤트 기반으로 동작하도록 구성합니다. 
* 첫번째 서비스는 데이터를 변경하고 메시지 브로커에 이벤트를 전달하고 두번째 서비스는 이벤트를 수신하고 이에 따라서 저장 데이터를 변경합니다. 
  * 서비스는 동시에 블로킹 되지 않으며 상호 의존성이 없습니다.
  * 각 서비스의 컴포넌트가 구동 중이지 않아도 요청에 대한 처리가 가능합니다.

#### 궁극의 일관성
* 도메인 주도 설계 구현에서는 불확실성을 도메인 모델의 포함시킬 것을 제안합니다. 
  * 예를 들어서 `결제 정보 확인중` 이라는 새로운 상태를 도입해서 결제 정보 확인 없이 주문을 생성할 수 도 있습니다. 
  * 새로운 상태는 불확실한 상황에서 한정된 시간동안 유지되는 별도의 비즈니스 이벤트로 다룹니다. 
  * 이러한 접근 방식을 사용하면 항상 일관성을 유지할 필요가 없습니다.
* 이러한 미래의 일관성을 궁극적 일관성(eventual consistency) 이라고 합니다. 
  * 대개 궁극적 일관성을 보장한다는 것은 운영을 성공적으로 수행 할 수 있는 안정적인 시스템 구축이라는 목적을 달성하기에 충분합니다.

#### SAGA 패턴
* 마이크로 서비스 분야에서 분산 트랜젝션에 가장 널리 사용되는 패턴중 하나는 SAGA 패턴입니다. 
* saga는 소수의 작은 트랜젝션으로 구성되며 각 트랜젝션은 하나의 마이크로 서비스에 국한됩니다.
* 외부 요청이 saga를 시작하고, saga가 첫번째 작은 트랜젝션을 시작합니다. 
* 성공 할 경우 두번째 트랜젝션이 시작됩니다.  
* 트랜젝션이 중간에 성공하지 못한다면 이전 트랜젝션에 대한 보상이 기동됩니다.
  * 이를 구현하는 패턴은 코레오그래피(event-based choreography)와 오케스트레이션(orchestration via a coordinator service)

#### 이벤트 소싱
* 마이크로 서비스 응용 프로그램의 이벤트 플로를 처리하기 위해서 이벤트 소싱 패턴을 사용 할 수 있습니다. 
  * 이벤트 소싱은 각 비즈니스 엔티티 상태 변화 순서를 저장합니다. 
  * 이정보를 사용하면 이벤트를 순차적으로 복기해서 계정 상태를 계산 할 수 있으며 쿼리를 통해서 어느 시점의 엔티티 상태를 확인 할 수 있습니다.
  * 일반적으로 이벤트 소싱을 구현하는 서비스는 다른 서비스가 엔티티 업데이트를 구독 할 수 있도록 하는 API를 제공합니다. 
  * 현재 상태를 계산하는데 필요하는 시간을 최적화 하기 위해서 주기적인 스냅 샷을 저장할 수 있습니다. 
    * 저장소 크기를 줄이기 위해서 스냅샷 이전의 데이터를 삭제 할 수도 있습니다. 
* 예제 은행 계좌 이벤트 로그
|날짜|처리유형|금액|
|:--|:--|:--|
|2018-06-04 22:00:01|계좌생성|$0|
|2018-06-05 22:00:01|입급|$50|
|2018-06-05 09:00:01|출금|$10|
|2018-06-05 11:00:01|입금|$20|
|2018-06-06 03:00:01|입금|$115|
|2018-06-07 8:00:01|출금|$40|

#### 명령 및 쿼리 책임 분리(CQRS)
* 명령 및 쿼리 책임 분리(CQRS)는 종종 이벤트 소싱과 함께 사용 됩니다. CQRS는 두부분으로 구성됩니다.
  * 쓰기 파트는 상태 변경 명령을 수신해 기본 이벤트 저장소에 저장합니다. 하지만 엔티티 상태를 반환하지 않습니다.
  * 읽기 파트는 상태를 변경하지 않고 요청된 쿼리의 결과를 반환합니다.
    * 별개의 쿼리에 대한 상태 표현은 뷰로 저장되며 갱신 이벤트가 명령으로 수신된 후에 비동기식으로 다시 계산됩니다.
* CQRS 패턴은 소프트 웨어 시스템이 대량의 데이터를 스트리밍 방식으로 처리 할 수 있도록 해주고 동시에 현재 시스템 상태와 관련된 다양한 쿼리를 신속히 응답합니다. 

#### 충돌 없는 복제 데이터 타입(CRDT)
* 마이크로 서비스라 하더라도 커지면 커질수록 더 많은 데이터를 처리해야 합니다.
* 성능 및 확장성을 위해서 락이나 트랜젝션 일관성없이 여러 서비스 인스턴스에 동시에 데이터를 업데이트 하는 경우가 발생 할 수 있습니다. 
  * 이러한 접근 방식을 낙관적 복제(`optimistic replication`) 라고 합니다.
  * 나중에 발생할 불일치를 감수하면서 데이터 복제본을 병행해서 사용할 수 있습니다. 
  * 이러한 시나리오에서는 복제본이 병합될 때 충돌을 해결해야하며 사용자 입장에서는 일부 변경사항을 되돌려야 합니다. 
  * 그러나 병합 프로세스가 항상 성공할 수 있도록 하는 수학적 속성을 가진 데이터 구조도 있습니다.
  * 이러한 데이터 구조를 충돌 없는 복제 데이터 타입 이라고 합니다.

### 데이터 조회를 위한 동기식 모델 
* 리액티브 영속성의 이점과 문제점을 이해하기 위해서 동기식 방식의 데이터 베이스 액세스를 구현하는 방법을 알아 봅니다.

#### 데이터베이스 액세스를 위한 와이어 프로토콜
* 응용프로그램은 데이터 베이스 드라이버라고 하는 특수한 클라이언트 라이브러리를 사용해서 외부 데이터 베이스와 통신합니다. 
* 와이어 프로토콜은 데이터베이스 드라이버와 데이터 베이스 자체가 통신하는 방법을 정의합니다. 
* 대부분의 와이어 프로토콜은 언어에 독립적입니다.
* 와이어 프로토콜은 TCP/IP를 이용하도록 설계 되었고 TCP/IP는 슬라이딩 윈도우에 의해 구현된 흐름 제어를 통해서 배압을 지원 할 수 있는 비동기 프로토콜입니다. 
* 배압과 별개로 클라이언트와 데이터베이스간에 큰 데이터를 전달하기 위해서 완전히 다른 접근 방식을 가질 수 있습니다. 
  * 데이터 베이스 측에서 전체 결과 집합을 계산한 후에 쿼리가 끝나자 마자 데이터를 컨테이너에 넣고 컨테이너를 클라이언트에 전달 하는 방식
    * 이 방식은 배압을 고려하지 않고 데이터 베이스 측에 커다란 버퍼를 필요로 합니다.
    * 클라이언트는 전체 쿼리가 실행된 이후에만 데이터를 받을 수 있습니다. 
    * 구현 방식이 쉬우며 쿼리 실행 프로세스가 길지 않으며 업데이트 된 쿼리가 동시에 발생되는 경합이 줄어들 수 있습니다.
  * 클라이언트가 요청 할 때 청크(chunk)로 결과 집합을 보낼 수도 있습니다.
    * 쿼리는 완전히 실행될 수 있으며 결과는 버퍼에 저장 할 수 있습니다. 
    * 데이터베이스는 요청에 의해 청크가 채워지거나 클라이언트가 요구한 양의 데이터를 전달한 후에만 실행을 계속 할 수 있습니다. 
    * 메모리 사용량을 줄일 수 있고 쿼리가 실행중일때 첫번째 행을 반환할 수 있으며 논리적인 배압을 전파 가능하게 하고 쿼리를 취소할 수있도록 합니다.
  * 쿼리 실행중에 결과를 얻자마다 결과를 스트림으로 보내는 방법도 있습니다. 또한 클라이언트가 데이터 베이스에 배압을 전달 할 수도 있습니다. 
    * 이러한 접근 방식은 추가적인 버퍼가 필요로 하지 않으며 클라이언트는 빠르게 쿼리 결과의 첫번째 행을 수신 할 수 있습니다. 
    * 그러나 이러한 방식은 매우 수다스러운 통신과 빈번한 호출 시스템으로 네트워크와 CPU를 과도하게 사용 할 수 있습니다. 
* 일반적으로 데이터 베이스는 하나 이상의 접근 방법을 이용해서 와이어 프로토콜을 구현합니다.
* 예를 들어 MySQL은 데이터를 전체 또는 스트림으로 행 단위로 보낼 수 있습니다. 
* 반면에 PostgreSQL 데이터 베이스는 PostgreSQL 포털 이라는 개념으로 클라이언트가 수신할 수 있는 만큼 데이터행을 요청 할 수 있습니다. 
* 잘 설계된 데이터 배이스 와이어 프로토콜은 이미 리액티브의 모든 특성을 가지고 있다는 것을 알 수 있습니다. 

### JDBC(Java Database Connectivity)
* 1997년에 자바 플랫폼에서 데이터 액세서를 위한 표준화된 API를 제공합니다. 
* JDBC를 사용하면 여러 데이터 베이스를 동일한 응용 프로그램에서 사용 할 수 있습니다. 
  * 자격 증명을 통해서 연결을 만들고 SQL 문을 수행할 수 있습니다. 
  * 실행 결과로 Java.sql.ResultSet을 반환합니다.
* ResultSet은 호환성을 위해서 드라이버가 모든 행을 로드한 후에야 처리가 가능합니다. 
* 성능 부분에서는 JDBC는 SELECT이의 모든 쿼리에 대해서 일괄 처리를 허용 합니다. 
  * 이렇게 하면 더 적은 네트워크 비용으로 DB와 통신할 수 있습니다. 
* JDBC는 직접 사용하기에는 너무 저수준으로 취급 받고 있습니다.

#### 커넥션 관리
* 최근 애플리케이션은 JDBC에 직접 연결하지 않고 커넥션 풀을 사용합니다. 
  * 매번 커넥션을 수행하는 것은 비용이 많이 걸립니다.
* 자바 진영에서 HikariCP는 가장 빠른 커넥션 풀로 인정 받고 있습니다.

#### 리액티브 방식으로 관계형 데이터베이스에 접근하기 
* JDBC는 자바 진영에서 데이터 액세스를 위한 기본 API이기 때문에 그위에 구축된 모든 추상화 레이어들이 동작하는 기초가 됩니다.
* 리액티브 애플리케이션에서 사용할 언어 수준의 데이터 베이스 액세스 API가 필요합니다. 
* 불행이도 JDBC를 약간 변형해서 이를 달성할 수 있는 솔루션이 없습니다. 
* 블로킹 방식의 DB 접근
  * JDBC API -> 차단 방식의 드라이버(와이어 프로토콜) -> DB 
* 리액티브 방식의 DB 접근
  * Reactive JDBC API -> 리액티브 드라이버(와이어 프로토콜) -> DB

### 스프링 JDBC
* JDBC를 직접 사용하는 번거로움을 해결하기 위해서 스프링은 JDBC 모듈을 제공합니다. 
  * 쿼리를 실행하고 테이블의 각 행을 엔티티로 매핑해주는 몇가지 버전의 JdbcTemplate 클래스가 있습니다.
  * 자원 생성과 해제 및 커넥션 처리의 실수를 예방합니다. 
  * JdbcTemplate은 JDBC 예외를 캐치해서 org.springframework.dao로 변환합니다. 
```java
class Book {
  private int id;
  private String title;

  public Book() {}

  public Book(int id, String title){
    this.id = id;
    this.title = title;
  }
  // getter와 setter 
}

// 다음과 같이 JdbcTemplate와 BeanPropertyRowMappter를 사용해서 스프링 리포지토리를 만들 수 있습니다. 
@Repository
class BookJdbcRepository {
  @Autowired
  JdbcTemplate jdbcTemplate;

  public Book findById(int id){
    return jdbcTemplate.queryForObject(
      "SELECT * FROM book WHERE id=?",
      new Object[] {id},
      new BeanPropertyRowMappter<>(Book.class)
    );
  }
}

// 또는 도메인 엔티티를 변환하는 방법을 지정하기 위해서 mapper 클래스를 직접 만들 수도 있습니다/.
class BookMapper implements RowMapper<Book> {
  @Override
  public mapRow(ResultSet rs, int rowNum) throws SQLException {
    return new Book(rs.getInt("id"), rs.getString("title"));
  }
}

public List<Book> findAll() {
  return jdbcTemplate.query("SELECT * FROM book", new BookMapper());
}
```

### 스프링 데이터 JDBC
* 스프링 데이터 JDBC는 스프링 데이터의 새로운 모듈입니다. 
  * 이 모듈은 JDBC 기반의 리포지토리의 구현을 단순화 하는 것을 목표로 합니다.
  * 스프링 데이터 리포지토리는 도메인 주도 설계에서 영감을 얻었습니다.
  * 집계된 엔티티(Aggregate Root) 마다 하나의 리포지토리를 만드는 것이 좋습니다. 
```java
class Book {
  @id
  private int id;
  private String title;

  // 생성자 생략
  // getter와 setter 
}

// jdbcTemplate 따로 선언하지 않습니다. 
@Repository
public interface BookSpringDataJdbcRepository extends CrudRepositoty<Book, Integer>{

  // 결과가 도착 할 때까지 블로킹 됩니다.
  @Query("SELECT * FROM book WHERE LENGTH(title) = " + 
  "(SELECT MAX(LENGTH(title)) FROM book)")
  List<Book> findByLongestTitle();

  @Query("SELECT * FROM book WHERE LENGTH(title) = " + 
  "(SELECT MIN(LENGTH(title)) FROM book)")
  List<Book> findByShortestTitle();

  // 비동기모드로 수행합니다. 결과를 기다리는 동안 클라이언트 스레드는 블로킹 되지 않습니다.
  // JDBC가 블로킹 방식으로 동작하기 때문에 내부적으로 스레드는 락(lock)에 걸립니다.
  @Asyc
  @Query("SELECT * FROM book b WHERE b.title = :title")
  CompletableFuture<Book> findBookByTitleAsync(@Param("title") String title);
}
```

#### 스프링 데이터 JDBC를 리액티브 하게 만들기 
* 논블로킹 방식으로 통합하기 위한 R2DBC를 제공합니다. 