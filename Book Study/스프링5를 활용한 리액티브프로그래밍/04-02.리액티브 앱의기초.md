## 코드를 통해 스트림 만들기 
### 팩토리 메서드 - push와 create
* `push` 팩토리 메서드를 사용하면 단일 스레드 생성자를 적용해서 Flux 인턴스를 프로그래밍 방식으로 생성 
  * 이 방식은 배압과 cancel 걱정없이 비동기, 단일 스레드, 다중 값을 가지는 API에 적용하는데 유용
  * 구독자가 부하를 처리할 수 없는 경우에는 배압과 취소는 모두 큐를 이용해서 처리
```java
// push 메서드
Flux.push(emitter -> IntStream
    .range(2000, 3000)
    .forEach(emitter::next))
    .delayElements(Duration.ofMillis(1))
    .subscribe(e -> log.info("onNext : {}", e));
)

// create 메서드
Flux.create(emitter -> {
    emitter.onDispose(() -> log.info("Disposed"));
}).subscribe(e -> log.info("onNext: {}", e));
```

### 팩토리 메서드 - generate
* 이전 값을 기반으로 다음 내부 상태를 계산하고 onNext 신호를 다운 스트림 구독자에게 전송
* 초기값과 함수하나 필요
```java
Flux.generate(
    ()-> Tuples.of(0L, 1L),                         // 초기값 셋팅 
    (state, sink) -> {
        log.info("generated value : {}", state.getT2);
        sink.next(state.getT2());   // state의 두번째 값을 onNext 신호로 보냅니다. 
        long newValue = state.getT1() + state.getT2();
        return Tuples.of(state.getT2(), newValue);  // 피보나치 시퀀스 값을 기반으로 state 계산
    }
)
```

### 일회성 리소스를 리액티브 스트림에 배치
```java
public class Connection implements AutoCloseable {  // 내부 리소스를 스스로 관리
    private final Random rnd = new Random();

    public Iterable<String> getData() {
        if (rnd.nextInt(10) < 3){
            throw new RuntimeException("Communication error");
        }

        return Arrays.asList("Some", "data");
    }

    public void close(){
        log.info("IO Connection closed");
    }

    public static Connection newConnection() {
        log.info("IO Connection created");
        return new Connection();
    }
}

// 명령형 접근 방식 try-with-resource 문
try(Connection conn = Connection.newConnection()){
    conn.getData().forEach(
        data -> log.info("Received data : {}", data)
    );
} catch (Exception e){
    log.info("Error : {}", e.getMessage());
}

// 리액티브 코드 
// using 메서드를 사용해서 Connection의 인스턴스 라이프 사이클을 스트림 라이프 사이클에 매핑합니다. 
Flux<String> ioRequestResult = Flux.using(
    Connection::newConnection,  // 일회성 객체 만드는 법
    connection -> Flux.fromIterable(connection.getData())       // 데이터를 스트림으로 만드는 법
    Connection::close           // 일회성 객체 닫는법
);

ioRequestResults.subscribe(     // 데이터를 구독합니다. 
    data -> log.info("Received data: {}", data),
    e -> log.info("Error : {}", e.getMessage()),
    () -> log.info("Stream finished");
)
```

### usingWhen 팩토리를 사용해서 리액티브 트랜젝션 래핑
* usingWhen을 사용해서 수동으로 자원을 관리할 수 있습니다. 
```java
public class Transaction {
    private static final Random random = new Random();
    private final int id;

    public Transaction(int id) {
        this.id = id;
        log.info("[T : {}] created", id);
    }

    // defer 실제 구독이 발생할 때까지 대기 
    public static Mono<Transaction> beginTransaction() {
        return Mono.defer(()->
            Mono.just(new Transaction(random.nextInt(1000))));
    }

    public Flux<String> insertRows(Publisher<String> rows){
        return Flux.from(rows)
            .delayElements(Duration.ofMillis(100))
            .flatMap(r -> {
                if(random.nextInt(10) < 2) {
                    return Mono.error(new RuntimeException("Error:" + r));
                } else {
                    return Mono.just(r);
                }
            });
    }

    public Mono<Void> commit() {
        return Mono.defer(() -> {
            log.info("[T: {}] commit", id);
            if(random.nextBoolean()){
                return Mono.empty();
            } else{
                return Mono.error(new RuntimeException("Conflict"));
            }
        });
    }

    // usingWhen 연산자 사용
    // 리액티브한 방식으로 자원의 라이프 사이클을 관리 
    Flux.usingWhen(
        Transaction.beginTransaction(),                         
        transaction -> transaction.insertRows(Flux.just("A", "B", "C")),
        Transaction::commit,
        Transaction::rollback,
    ).subscribe(
        d -> log.info("onNext : {}", d),
        e -> log.info("onError : {}", e.getMessage()),
        () -> log.info("onComplete")
    );
}
```

### 에러 처리하기 
* 리액티브 스트림은 onError이 발생하면 스트림이 종료되었다고 생각하고 시퀀스를 중지합니다.
* 이 시점에서 다음 전략중 하나를 선택해서 대응할 수 있습니다.
  * onError신호에 대한 핸들러를 정의합니다.
  * onErrorReturn 연산자를 사용하면 예외 발생시 사전 정의된 정적 값 또는 예외로 계산된 값으로 대체합니다.
  * onErrorResume 연산자를 적용해 예외를 catch하고 대체 워크 플로를 실행합니다.
  * onErrorMap 연산자를 사용해서 catch하고 상황을 더 잘 나타내는 다른 예외를 발생시킵니다. 
  * 오류가 발생할 경우 다시 실행하는 워크플로를 정의할 수 있습니다.
    * retry 오류 시그널 발생시 다시 구독합니다. 
    * retryBackoff 연산자는 지수적인 백오프 알고리즘을 사용해서 대기 시간을 증가 시킵니다. 
* timeout 연산자를 사용하면 작업 대기 시간을 제한하고 TimeOutException을 발생시킵니다. 
```java
public Flux<String> recommendedBooks(String userId){
    // 구독 할 때 까지 연기
    return Flux.defer(() -> {
        if(random.nextInt(10) < 7 {
            return Flux.<String>error(new RuntimeException("Err"))
                .delaySequence(Duration.onMillis(100));
        }else{
            return Flux.just("Blue Mars", "The Expanse")
                .delyaSequence(Duration.ofMillis(50));
        }
    }).doOnSubscribe(s -> log.info("Request for {}", userId));
    // 구독이 시작되면 구독자를 기록합니다.
}


Flux.just("user-1")
    .flatMap(user ->{
        recommendedBooks(user)  // 추천을 요청합니다.
        .retryBackoff(5, Duration.ofMillis(100))    // 실패시 최대 5번까지 재시도합니다.
        .timeout(Duration.ofSeconds(3))             // 3초간 대기한 후 응답이 없으면
        .onErrorResume(e -> Flux.just("The Martian")))  // 에러를 처리하는 워크플로로 실행. 디폴트값 리턴
    .subscribe(
        b -> log.info("onNext: {}", b),
        e -> log.warn("onError: {}", e.getMessage()),
        () -> log.info("onComplete")
    );
```

### 배압 다루기
* 리액티브 스트림 스펙에서는 프로듀서와 컨슈머간의 의사소통에 배압이 필요합니다.
  * 컨슈머가 오버플로 발생 할 가능성이 있습니다. 
* 다음과 같은 방법을 배압을 처리할 수 있도록 스트림을 구성할 수 있습니다.
  * `onBackPressureBuffer` 연산자는 제한되지 않는 요구를 요청하고 결과를 다운스트림으로 푸시합니다. 
    * 다운스트림이 부하를 유지할 수 없는 경우 큐를 이용해서 버퍼링합니다.     
  * `onBackPressureDrop` 연산자는 제한되지 않은 요구(Inteager.MAX_VALUE)를 요청하고 데이터를 하위로 푸시합니다.
    * 다운 스트림의 처리 용량이 충분하지 않으면 일부 데이터가 삭제 됩니다. 
    * 사용자 정의 핸들러로 삭제된 원소를 처리할 수 있습니다.
  * `onBackPressureLast` 연산자는 `onBackPressureDrop`와 유사하게 작동합니다. 
    * 그러나 가장 최근에 수신된 원소를 기억합니다. 
  * `onBackPressureError` 연산자는 데이터를 다운 스트림을 푸시하는 동안 크기를 제한 하지 않고 요청하빈다. 
    * 다운 스트림 컨슈머가 처리를 계속 유지 할 수 없으면 에러를 발생합니다. 
* 속도를 제한하는 기술도 있습니다.
  * `limitRate(n)` 연산자는 다운 스트림 수요를 n보다 크지 않은 작은 규모로 나눕니다. 
    * 이러면 부적절한 규모 데이터 요청으로부터 섬세한 게시자를 보호 할 수 있습니다. 
  * `limitRequest(n)` 연산자는 다운 스트림 컨슈머의 수요를 제한합니다. 

### Hot 스트림과 cold 스트림
* 리액티브 게시자에 대해 이야기 할 때 게시자를 hot과 cold 두가지 유형으로 분류 할 수 있습니다.
* 콜드 퍼블리셔(cold publisher)는 구독자가 나타날 때마다 해당 구독자에 대해 모든 시퀀스 데이터가 생성되는 방식으로 동작합니다.
  * 또한 구독자 없이는 데이터가 생성되지 않습니다.
```java
Flux<String> coldPublisher = Flux.defer(()->{
    log.info("Generation new items");
    return Flux.just(UUID.randomUUID().toString());
});

log.info("No date was generated so far");
coldPublisher.subscribe(e -> log.info("onNext: {}", e));
coldPublisher.subscribe(e -> log.info("onNext: {}", e));
log.info("Data was generated twice two subsribers");

// 위의 퍼블리셔는 구독자가 나타날 때마다 새로운 시퀀스가 생성됩니다. 
// 대표적으로 HTTP 요청이 이런식으로 동작합니다. 
```
* 핫 퍼블리셔(hot publisher)의 데이터 생성은 구독자의 존재 여부에 의존하지 않습니다. 
* 핫 퍼블리셔는 첫번째 구독자가 구독하기 전에 원소를 만들어 낼 수 있습니다. 
* 또한 구독자가 나타나면 이전에 생성된 값을 보내지 않고 새로운 값만 보낼 수 있습니다. 
  * 예를 들어 핫 퍼블리셔는 가격이 변경되는 즉시 현재의 유가와 관련해 구독자에게 업데이트 브로드캐스트 할수 있습니다. 
  * 새로운 구독자가 오면 이후 업데이트만 전달 합니다.
  * 대부분의 핫 퍼블리셔는 Processor 인터페이스를 상속합니다. 
* just는 defer로 래핑해서 콜드 퍼블리셔로 전환 할 수 있습니다.
  
### 스트림 원소를 여러 곳으로 보내기
* 콜드 퍼블리셔를 리액티브 변환을 통해서 핫 퍼블리셔로 전환하는 방법
* ConnectableFlux를 이용하면 수요가 많은 데이터를 생성하고 다른 모든 가입자가 데이터를 처리 할 수 있도록 캐싱합니다.
```java
Flux<Integer> source = Flux.range(0, 3)
    .doOnSubscribe( s ->
        log.info("new subsciption for the cold publisher"));

ConnectableFlux<Integer> conn = source.publish();

conn.subscribe(e -> log.info("[Subscriber 1] onNext : {}", e))
conn.subscribe(e -> log.info("[Subscriber 2] onNext : {}", e))

log.info("all subscribers are ready, connection");
conn.connect();

/* 결과
all subscribers are ready, connection
new subsciption for the cold publisher
[Subscriber 1] onNext : 0
[Subscriber 2] onNext : 0
[Subscriber 1] onNext : 1
[Subscriber 2] onNext : 1
[Subscriber 1] onNext : 2
[Subscriber 2] onNext : 2
*/
```

### 스트림 내용 캐싱하기 
* `ConnectableFlux`를 사용하면 다양헌 데이터 캐싱 전략을 쉽게 구현할 수 있습니다. 
* 그러나 `cache` 연산자가 이미 존재하고 내부적으로 `ConnectableFlux`로 구현되어 있습니다. 
```java
Flux<Integer> source = Flux.range(0, 2)
    .doOnSubscribe(s ->
        log.info("new subscription for the cold publisher"));

// 1초 동안 cache연산자와 함께 콜드 퍼블리셔를 캐시합니다. 
Flux<Integer> cachedSource = source.cache(Duration.ofSeconds(1));

// 가입자 연결
cachedSource.subscribe(e -> log.info("[S 1] onNext: {}", e));
cachedSource.subscribe(e -> log.info("[S 2] onNext: {}", e));

// 캐시된 데이터가 만료 될 때까지 잠시 기다릅니다.
Thread.sleep(1200);

cachedSource.subscribe(e -> log.info("[S 3] onNext: {}", e));

/*
new subscription for the cold publisher
[S 1] onNext: 0
[S 1] onNext: 1
[S 2] onNext: 0
[S 2] onNext: 1
new subscription for the cold publisher
[S 3] onNext: 0
[S 3] onNext: 1
*/
```

### 스트림 내용 공유
* ConnectableFlux를 사용해서 여러 개의 구독자에 대한 이벤트를 멀티 캐스트합니다. 
* `share` 연산자을 사용하면 콜드 퍼블리셔를 핫 퍼블리셔로 변환할 수 있스니다.
  * `share` 연산자는 각 신규 구독자에게 이벤트를 전파하는 방식으로 작동합니다. 
```java
Flux<Integer> source = Flux.range(0, 5)
    .delayElements(Duration.ofMillis(100))
    .doOnSubscribe(s ->
        log.info("new subscription for the cold publisher"));

Flux<Integer> cachedSource = source.share();
cachedSource.subscribe(e -> log.info("[S 1] onNext: {}", e));
Thread.sleep(400);
cachedSource.subscribe(e -> log.info("[S 2] onNext: {}", e));
/* 결과
new subscription for the cold publisher
[S 1] onNext: 0
[S 1] onNext: 1
[S 1] onNext: 2
[S 1] onNext: 3
[S 2] onNext: 3
[S 1] onNext: 4
[S 2] onNext: 5
*/
```

## 시간 다루기
* `interval` 연산자로 주기적으로 이벤트를 생성
* `delayElements` 연산자로 원소를 지연시킬 수 있음
* `delaySequence` 연산자로 모든 신호를 지연 시킬 수 있습니다. 
* 밀리 단위 시간에 대해서 정확한 지연이 보장하지 않습니다. 
```java
Flux.range(0, 5)
    .delayElements(Duration.ofMillis(100))
    .elapsed()  // 이전 이벤트와 시간 간격을 측정합니다. 
    .subscribe(e -> log.info("Elapsed {} ms value : {}", e.getT1(), e.getT2()));

/* 결과
Elapsed 151 ms value : 0
Elapsed 105 ms value : 1
Elapsed 103 ms value : 2
Elapsed 102 ms value : 3
Elapsed 105 ms value : 4
*/
```

### 리액티브 스트림을 조합하고 변환하기
* `transform`연산자를 사용하면 리액티브 스트림에서 공통 부분을 별도의 객체로 추출 해서 재사용 할 수 있습니다.
  * 스트림 라이브 사이클의 결합 단계에서 스트림 동작을 한번만 변경합니다. 
  * 리액터에는 같은 일을 하는 composer 연산자도 있습니다. 
```java
// String 리액티브 스트림을 다른 리액티브 스트림으로 변환하면서 String을 생성합니다. 
Function<Flux<String>, Flux<String>> logUserInfo = 
    stream -> stream
        .index()
        .doOnNext(tp -> 
            log.info("[{}] user : {}", tp.getT1(), tp.getT2()))
        .map(Tuple2::getT2);

Flux.range(1000,3)
    .map(i -> "user-" + i)
    .transform(logUserInfo) // logUserInfo를 적용합니다.
    .subscribe(e -> log.info("onNext: {}", e));


Flux<String> publisher = Flux.just("1", "2")
    .compose(logUserInfo);
```

# 리액터 프로젝트 심화학습

## 리액티브 스트림의 수명주기
### 조립 단계 
* 스트림 수명 주기의 첫번째 부분은 조립 단계 입니다. 
* 리액터는 연쇄형 API를 제공하며 불변성을 제공합니다. 
  * 각각의 연산자는 새로운 객체를 생성합니다. 
* 리액티브 라이브러리에서 실행 흐름을 작성하는 프로세스를 조립이라고 합니다. 
* 스트림 수명 주기에서 조립 단계가 중요한 이유는 스트림 타입을 확인해서 연산자를 서로 바꿀 수 있습니다. 
* 조립 단계에서 스트림에 몇 가지 훅을 사용하면 디버깅이나 스트림 모니터링 중에 유용한 로깅 추적, 메트리 수집 또는 기타 중요한 기능를 사용가능
```java
// 조립 단계를 보여주는 빌더 API가 없는 경우 조립 방식
Flux<Integer> sourceFlux = new FluxArray(1, 20, 300, 4000);
Flux<String> mapFlux = new FluxMap(sourceFlux, String::valueOf);
Flux<String> filterFlux = new FluxFilter(mapFlux, s -> s.length() > 1);

// 의사 코드
FluxFilter(
    FluxMap(
        FluxArray(1, 20, 300, 4000)
    )
)
```

### 구독 단계
* 구독은 특정 Publisher를 구독할 때 발생합니다
```java
// 구독 소스
filteredFlux.subscribe(...);

// 의사 코드
filteredFlux.subscribe(Subscriber){
    mapFlux.subscribe(new FilterSubscriber(Subscriber)){
        arrayFlux.subscribe(new MapSubscriber(FilterSubscriber(Subscriber))){
            // 실제 여기서 데이터를 송신
        }
    }
}
    
// 의사 코드
ArraySubscriber(
    MapSubscriber(
        FilterSubscriber(
            Subscriber
        )
    )
)
```

### 런타임 단계 
* 스트림 실행의 마지막 단계인 런타임 단계입니다. 
* 게시자와 구독자간의 실제 신호가 교환 됩니다. 
* 참조
  * Subscription.request를 호출하면 요청 수요를 volatile 필드에 쓰기가 발생합니다. 

## 리액터에서 스레드 스케줄링 모델
### publishOn 연산자