## 모두를 위한 반응성
* CompletableStage를 이용하는 자바 코어 라이브러리와 RxJava같은 다양한 라이브러리가 있어서 선택이 가능합니다. 
  * 작업 처리에는 RxJava를 사용할 수 있고 복잡하지 않은 비동기식 응답-요청 상호 작용에는 CompletableStage를 사용할 수 있습니다. 
* 다양한 선택지는 시스템을 지나치게 복잡하게 만듭니다. 

## 풀방식과 푸시 방식 
* 리액티브 초기 단계에서 모든 라이브러리의 데이터 흐름은 구독자에게 푸시되는 방식입니다.
* Pull방식은 비효율적입니다. 
* 예제 소스를 통해서 설명합니다.
```java
// 1번째 방법(pull 모델)
// DB에 데이터를 매번 요청합니다.
// CompletableFuture 완료 시점 이벤트만 받을 수 있습니다.
void pull(String elementId, Queue<Item> queue, CompletableFuture resultFuture, int count){
    dbClient.getNextAfterId(elementId)
        .thenAccept(item -> {
            if(isValid(item)){
                queue.offer(item);

                // 해당 조건이 만족되기 전까지 계속 수행
                if(queue.size == count){
                    resultFuture.complete(queue);
                    return;
                }
            }
            // DB에 하나의 아이템을 요청함
            pull(item.getId(), queue, resultFuture, count);
        });
}

// 2번째 방법(pull 모델)
// DB에 데이터를 count만큼 가져와서 배치로 실행합니다. 
void pull(String elementId, Queue<Item> queue, CompletableFuture resultFuture, int count){
    // count 만큼 아이템을 가져와서 배치로 실행
    // batch라 하더라도 filter 조건의 만족 여부는 알수 없어서 몇번이 호출될지 알 수 없음
    dbClient.getNextAfterId(elementId, count)
        .thenAccept(items -> {
            for(var item : items){
                if(isValid(item)){
                    queue.offer(item);

                    // 해당 조건이 만족되기 전까지 계속 수행
                    if(queue.size == count){
                        resultFuture.complete(queue);
                        return;
                    }
                }
            }
            // DB에 하나의 아이템을 요청함
            pull(item.getId(), queue, resultFuture, count);
        });
}

// 3번째 방법(push 모델)
// Observable을 사용하면 구독을 통해서 스트림으로 데이터를 전달 받음
// 필터 조건이 완료 후에 구독을 취소하면 데이터 연결이 닫힘 
public Observable<Item> list(int count) {
    return dbClient.getStreamOfItems()
                    .filter(item->isValid(item))
                    .take(count);
}
```

## 흐름 제어
* push 모델을 채택한 가장 큰 이유는 요청하는 횟수를 최소화 하여 전체 처리 시간을 최적화합니다. 
* 반면에 푸시 모델만 사용하는 것은 기술적으로 한계가 있습니다. 
* 메시지 기반의 통신의 본질은 요청에 응답하는 것입니다. 
* 다양한 프로듀서와 컨슈머의 상황을 설명합니다. 

### 느린 프로듀서와 빠른 컨슈머
* 이러한 경우 컨슈머가 더 많은 데이터를 처리 할 수 있음에도 순수 푸시 모델에서는 메트릭 정보를 제공 할 수 없습니다.

### 빠른 프로듀서와 느린 컨슈머
* 다음과 같은 상황은 더 복잡합니다. 
* 처리되지 못한 원소들을 큐에 수집해야 합니다. 
#### 무제한 큐 
* 가장 확실한 해결책은 무제한 사이즈의 큐를 사용하는 것입니다.
* 무제한 큐의 장점은 메시지 전달이 확실해집니다. 
* 다만 메모리의 한도가 있기 때문에 프로그램의 복원력이 떨어집니다.
#### 크기가 제한됨 드롭 큐
* 오버 플로우를 방지하기 위해서 큐가 가득차면 신규로 유입되는 메시지를 무시하는 형태로 관리할 수 있습니다.
* 이방식을 채택할 수 있는 건 메시지의 중요도가 낮은 경우입니다. 
#### 크기가 제한됨 블로킹 큐
* 메시지가 중요한 경우에는 사용할 수 있는 방법입니다.
* 제한에 도달하면 메시지 유입을 차단 합니다. 
  * 다만 이 방식은 비동작을 무효화 합니다. 
  
* 일반적으로 순수한 푸시 모델은 다양한 부작용을 발생시킬 수 있습니다. 
  * 배압 제어 매커니즘으 중요성이 부각됩니다. 

## 리액티브 스트림의 기본 스펙
* 리액티브 스트림에는 Publisher, Subscriber, Subscription, Processor 인터페이스가 정의 됨
* Subscription의 request 함수 제공으로 순수 push 모델이 아닌 하이브리드 push-pull 모델로 진행됩니다. 
```java
package org.rectivestreams;

// 발행-구독 모델과 비슷합니다
// Publisher = Observable
public interface Publisher<T> {
    // 구독자를 등록하는 메서드
    void subscribe(Subscriber<? super T> s);
}

// Subscriber = Observer
public interface Subscriber<T> {
    // 구독의 성공 했음을 전달 받습니다.
    // Subscription를 인자로 받습니다. 
    void onSubscribe(Subscription s);
    // 객체 전달 
    void onNext(T t);
    // 에러 발생
    void onError(Throwable t);
    // 구독이 완료
    void onComplete();
}

// 구독을 취소할 수 있음
public interface Subscription {
    // Publisher 보내줘야하는 데이터의 사이즈를 전달합니다. 
    void request(long n);   
    // 구독을 취소합니다. 
    void cancel();          
}

public interface Processor<T, R> extends Subscriber<T>, Publisher<R>{
    
}
```
* 하이브리드 모델을 사용하는 예제 소스
```java
public class TaskFilterOperator<T> implements Publisher<T> {
    // .. 생략
    public void subscribe(Subscriber s) {
        source.subscribe(new TakeFilterInner<>(s, take, predicate));
    }

    static final class TaskFilterInner<T> implements Subscriber<T>, Subscription{
        // 생략 ..
        public void onSubscribe(Subscription current) {
            // 생략 ..
            current.request(task);
        }

        public void onNext(T element){
            // 생략 ..
            long r = requested;
            Subscriber<T> a = actual;
            Subscription s = current;

            if(remaining > 0 ){
                boolean isValid = predicate.test(element);
                boolean isEmpty = queue.isEmpty();

                if(isValid && r > 0 && isEmpty){
                    a.onNext(element);
                    remaining--;
                }
                else if(isValid && (r==0 || !isEmpty)){
                    queue.offer(element);
                    remaining--;
                }
                else if(!isValid){
                    filtered++;
                }
            }else{
                s.cancel();
                onComplete();
            }

            if(filtered > 0 && remaining / filtered < 2){
                s.request(take);
                filtered = 0;
            }
        }
    }
}
```

### 리액티브 스트림 동작해보기