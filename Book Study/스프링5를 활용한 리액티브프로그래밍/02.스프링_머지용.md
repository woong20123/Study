### 리액티스 프레임워크 RxJava
* RxJava 라이브러리는 Reactive Extensions(ReactiveX)의 자바 구현체 입니다.
* Reactive Extensions는 동기식 또는 비동기식 스트림과 관계없이 명령어로 데이터 스트림을 조작하는 도구입니다. 

### 관찰자 + 반복자 = 리액티브 스트림
* 기존의 관찰자 패턴에 데이터 스트림의 끝을 알리는 기능을 추가하는 아이디어 
* RxObserver는 관찰자 패턴의 Observer 인터페이스와 유사합니다.
* 리액티브 Observable 클래스는 관찰자 패턴의 주체와 일치합니다. 
  * Observable -> (onNext, onComplete, onError 호출) -> Observer
```java
// 이 인터페이스는 리액티브 스트림의 모든 컴포넌트 사이의 데이터의 흐름을 정의합니다. 
public interface RxObserver<T>{
    // 새로운 값이 통지 됩니다. 
    void onNext(T next);
    // 스트림의 끝을 알립니다. 
    void onComplete();
    // 에러를 알립니다.
    void onError(Exception e);
}
```
* `Subscriber` 추상 클래스는 Observer 인터페이스를 구현하고 이벤트를 소비합니다. 
* 런타임에 `Observable`과 `Subscriber`간의 관계는 구독에 의해서 제어됩니다.
#### RxJava의 이벤트 생성 규칙
* `Observable`은 0을 포함해 일정 갯수의 이벤트를 보낼 수 있습니다. 
  * 따라서 각 구독자에 대해서 onNext()를 호출한 후 onComplete() 또는 onError()을 호출합니다. (둘 동시 호출 X)
  * 또한 OnComplete()또는 OnError()가 호출된 이후에는 onNext()가 호출되지 않습니다. 

### 스트림의 생산과 소비
```java
Observable<String> observable = Observable.create(
    // 구독자가 구독할 때
    new Observable.OnSubscribe<String>() {
        @Override
        public void call(Subscriber<? super String> sub){
            // 문자열을 구독자에 전달
            sub.onNext("Hello, reactive world!");
            // 스트림의 끝을 알립니다. 
            sub.onCompleted();
        }
    }
)

// 자바 8 이후
Observable<String> observable = Observable.create(
    sub -> {
        sub.onNext("Hello, reactive world!");
        sub.onCompleted()
    }
);
// RxJava 1.2.7 부터는 Observable를 생성하는 방식은 더 이상 사용되지 않습니다.
// 이 방식은 배압(backpressure)를 지원하지 않습니다. 

// 구독자 관련 코드 구현 
Subscriber<String> subscriber = new Subscriber<String>() {
    @Override
    public void onNext(String s) {
        System.out.println(s);
    }

    @Override
    public void onCompleted(){
        System.out.println("Done!");
    }

    @Override
    public void onError(){
        System.err.println(e);
    }
}

// observable 인스턴스와 subscriber 인스턴스 연결
observable.subsribe(subscriber);

// Hello, reactive world!
// Done! 
// 출력 완료

// 람다 표현식으로 구현하면 다음과 같이 구현 할 수 있습니다.
Observable.create(
    sub -> {
        sub.onNext("Hello, reactive world!");
        sub.onCompleted();
    }
).subscribe(
    System.out::println,
    System.err::println,
    () -> System.out.println("Done!")
);

// Observable 생성하는 방법
Observable.just("1", "2", "3", "4");
Observable.from(new String[]{"A", "B", "C"});
Observable.from(Collections.emptyList());

Observable<String> hello = Observable.fromCallable(() -> "Hellow ");
Future<String> future = 
    Executors.newCachedThreadPool().submit(() -> "World");

Observable<String> world = Observable.from(future);
Observable.concat(hello, world, Observable.just("!"))
    .forEach(System.out::print);

//Subscriber는 오류 발생시 rx.exceptions.OnErrorNotImplementedException을 발생시킵니다. 
```

### 비동기 시퀀스 생성하기 
* RxJava는 하나의 이벤트 뿐만이 아니고 주기적인 비동기 이벤트 시퀀스 생성 가능
```java
// 비동기적으로 수행됩니다. 
Observable.interval(1, TimeUnit.SECOND)
    .subscribe(e -> System.out.println("Received: " + e));
Thread.sleep(5000);

/*
    Received : 0
    Received : 1
    Received : 2
    Received : 3
    Received : 4
*/
```

### Subscription 인터페이스
```java
// 해당 인터페이스를 통해서 구독 취소와 구독 여부를 확인 할 수 있습니다.
interface Subscription {
    void unsubscribe();
    boolean isUnsubscribed();
}
```

#### CountDawnLatch를 통한 이벤트 소비 
```java
    CountDownLatch externalSignal = ;

    Subscription subscription = Observable
            .interval(100, MILLISECONDS)
            .subscribe(System.out::println);
    
    externalSignal.await();
    // 스트림에 대한 구독 취소 
    subscription.unsubscribe();
```

### 스트림 변환과 마블 다이어그램
* RxJava의 모든 기능은 연산자에 의해 구현 된다고 할 수 있습니다. 연산자에 대해서 설명합니다.

### Map 연산자
* RxJava에서 가장 많이 사용하는 연산자입니다. 
* func 함수가 T를 R로 변환합니다. 
```java
<R> Observable<R> map(Func<T, R> func)
```
### Zip 연산자
* 두개의 병렬 스트림 값을 결합니다.
```java
Observable.zip(
    Observable.just("A", "B", "C")
    Observable.just("1", "2", "3"),
    (x, y) -> x + y
).forEach(System.out::println);

// A1, B2, C3
```

### RxJava 사용의 전제 조건 및 이점
```java
// 서비스를 검색하고 제한 갯수만큼 결과를 수집합니다. 
// 모든 데이터가 전달 될 때까지 차단됩니다.
public interface SearchEngine {
    List<URL> search(String query, int limit);
}

// 이터레이터를 사용해서 결과를 반복적으로 처리합니다.
// 이방식은 커서라고 하며 데이터 베이스에서 자주 사용합니다. 
// 다만 다음 데이터 반환을 기다릴 때까지 스레드가 차단됩니다.
public interface IterableSearchEngine {
    Iterable<URL> search(String query, int limit);
}

// 비동기 서비스가 되기 위해서 CompletableFuture를 사용합니다. 
// 전체를 반환하거나 아무것도 반환하지 않는 방식으로 동작합니다. 
public interface FutureSearchEngine {
    CompletableFuture<List<URL>> search(String query, int limit);
}

// RxJava를 사용하면 비동기 처리 및 이후에 수신하는 각 이벤트에 대응할 수 있습니다. 
// 개별 이벤트을 처리 할 수 있습니다. OnNext
public interface RxSearchEngine{
    Observable<URL> search(String query);
}
```

* 느린 Callable에 대응하기 위해서 subscriberOn(Scheduler) 연산자를 사용 할 수 있습니다.
* 스트림 처리가 시작되는 Scheduler(자바 ExecutorService에 해당)를 정의합니다. 
```java
// 이렇게 작업을 하기 위해서는 불변 객체를 사용해야합니다. 
String query = ...;
Observable.fromCallable(() -> doSlowSyncRequest(query))
    .subscribeOn(Schedulers.io())
    .subscribe(this::processResult);`
```

### RxJava를 이용해서 애플리케이션 다시 만들기