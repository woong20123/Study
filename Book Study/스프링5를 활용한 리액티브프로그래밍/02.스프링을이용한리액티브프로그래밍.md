### 관찰자(Observer) 패턴
* 관찰자 패턴은 관찰자 라고 불리는 자손의 리스트를 가지고 있는 주체(subject)가 필요합니다. 
* 주체는 일반적으로 자신의 메서드중 하나를 호출해 관찰자에게 상태 변경을 알립니다.
  * 관찰자 패턴은 MVC 패턴의 중요한 부분입니다. 
* 관찰자 패턴을 사용하면 런타임에 객체 사이에 일대다 의존성을 등록할 수 있습니다. 
  * 또한 구성 요소 구현 세부사항에 대해 알지 못한 채로 등록합니다.
* String 메시지를 수신해서 출력하는 두개의 간단한 Observer 예제
```java
// Observer 클래스 리스트
public class ConcreteObserverA implements Observer<String> {
    @Override
    public void observe(String event){
        System.out.println("Observer A : " + event);
    }
}

public class ConcreteObserverB implements Observer<String> {
    @Override
    public void observe(String event){
        System.out.println("Observer A : " + event);
    }
}

// subject 클래스
public class ConcreteSubject implements Subject<String> {
    private final Set<Observer<String>> observers = 
        new CopyOnWriteArraySet<>();   

    public void registerObject(Observer<String> observer){
        observers.add(observer);
    }

    public void unregisterObserver(Observer<String> observer){
        observer.remove(observer);
    }

    public void notifyObserver(String event) {
        observers.forEach(observer -> observer.observe(event));
    }
}
```
* observer에서 사용한 CopyOnWriteArraySet 스레드 안전성을 가지지만 효율적이지 않습니다.
* 또한 상당히 긴 이벤트를 처리하는 경우 스레드 풀을 사용해서 메시지를 병렬로 전달 할 수 있습니다. 
* 하지만 이러한 직접 개발한 솔루션에서는 비효율성 내재된 버그가 발생 할 수 있습니다. 

### @EventListener를 사용한 발행-구독 패턴
* 스프링 프레임워크 4.2부터는 이벤트 처리를 위한 @EventListener 애노테이션과 ApplicationEventPublisher 클래스를 제공합니다. 
* 발행-구독 패턴은 게시자와 구독자간의 간접 계층을 제공합니다.
  * 게시자
  * 이벤트 채널(메시지 브로커, 이벤트 버스)
  * 구독자
* 토픽 기반 시스템의 구독자는 관심 토픽에 게시된 모든 메시지를 수신합니다. 
* 스프링 프레임워크의 @EventListener 애노테이션은 토픽 기반 라우팅과 내용 기반 라우팅에 모두 사용 할 수 있습니다. 

### EventListener 활용한 응용 프로그램
* 리액티브 디자인에 따라서 애플리케이션을 만들어야 하기 때문에 고전적인 Pulling model은 사용할 수 없습니다.
* 요즘에는 서버에서 클라이언트로 비동기 메시지를 전달 할 수 있는 웹 소켓 및 SSE(Server-Send Events)와 같은 잘 정의된 프로토콜이 있습니다.

### 스프링 프로젝트 생성하기 
#### 비즈니스 로직 구현하기 
```java
// 예제에서는 도메인 모델은 Temperature 클래스이고 이벤트 객체로 사용합니다.
final class Temperature {
    private final double value;
}

@Component
public class TemperatureSensor {
    private final ApplicationEventPublisher publisher;          

    private final Random rnd = new Random();

    // 별도의 Schedule 관련 스레드를 생성합니다. 
    private final ScheduleExecutorService executer = 
        Executers.newSingleThreadScheduleExecuter();

    public TemperatureSensor(ApplicationEventPublisher publisher){
        this.publisher = publisher;
    }

    @PostConstruct
    // 빈이 생성될 때 호출 됩니다.
    public void startProcessing(){
        this.executor.schedule(this::probe, 1, SECONDS);
    }

    // 모든 로직은 해당 메서드에서 정의 됩니다. 
    private void probe(){
        double temperature = 16 + rnd.nextGaussion() * 10;
        publisher.publishEvent(new Temperature(temparature));
        this.executor.schedule(this::probe, rnd.nextInt(5000), MILLISECONDS);
    }
}
```

### 스프링 웹 MVC를 이용한 비동기 HTTP 통신 
* 스프링 웹 MVC 버전 4.2부터 `ResponseBodyEmitter`를 반환할 수 있씁니다. 
  * ResponseBodyEmitter는 메시지 컨버터에 의해 개별적으로 만들어진 여러 개의 오브젝트를 전달하는 용도로 사용할 수 있습니다.
* SseEmitter는 ResponseBodyEmitter를 상속했으며, SSEL 프로토콜 요구에 따라서 하나의 수신 요청에 대해 다수의 발신 메시지를 보낼 수 있습니다.
* 이를 사용하면 @Controller에서 반환 될 때 비동기적으로 보낼 수 있습니다. 
* 또한 서블릿 스레드를 차단하지 않으면서 큰 파일을 스트리밍해야하는 경우에 유용한 StreamingResponseBody도 있습니다. 

### SSE 엔트포인트 노출
* 다음으로 HTTP 통신을 위해서 @RestController를 구현한 예제를 보여줍니다.
```java
@RestController
public class TemperatureController {
    private final Set<SseEmitter> clients = 
        new CopyOnWriterArraySet<>();

    @RequestMapping(
        value = "/temperature-stream",
        method = RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request){
        // 해당 요청이오면 새로운 SseEmitter를 생성하고 클라이언트에 등록합니다.
        SseEmitter emitter = new SseEmitter();
        clients.add(emitter);

        // 타임아웃이나 complete가 호출되면 클라이언트에서 제거합니다. 
        emitter.onTimeout(() -> clients.remove(emitter));
        emiiter.onCompletion(() -> clients.remove(emitter));

        // 생성된 SseEmitter를 리턴합니다.
        return emitter;
    }

    // 비동기로 스프링으로 부터 메시지를 수신받습니다.(ApplicationEventPublisher의 호출로)
    @Async
    @EventListener
    public void handleMessage(Temperature temperature){
        List<SseEmitter> deadEmitter = new ArrayList<>();
        clients.forEach( emitter -> {
            try{
                emitter.send(temperture, MediaType.APPLICATION_JSON);
            }catch(Exception ignore){
                deadEmitters.add(emitter);
            }
        });
        clients.removeAll(deadEmitter);
    }
}
```

### 비동기 지원 설정하기
```java
// 비동기 호출이 가능하도록 설정 합니다. 
@EnableAsync
@SpringBootApplication
public class Application implements AsyncConfigurer {
    public static void main(String[] args){
        SpringApplication.run(Application.calss, args);
    }

    @Override
    publiic Executor getAsyncExecuter(){
        ThreadPoolTaskExecuter executer = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(5);       // 해당 값을 설정하지 않으면 큐의 크기가 커지지 않습니다. 유의
        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler(){
        // 여기서 비동기 실행해서 발생된 예외에 대한 처리를 구현 할 수 있습니다.
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```