## 리액티브 프로젝트의 간략한 역사
* 리액티브 스트림 스펙은 리액티브 라이브러리가 서로 호환할 수 있도록 Pull-Push 데이터 교환 모델을 도입해 배압문제 해결
* 리액티브 스트림 스펙은 API 및 규칙만 정의하고 일상적인 사용을 위한 라이브러리는 제공하지 않습니다.
* 여기서 리액티브 스트림 스펙중에 가장 인기있는 리액터 프로젝트를 다룹니다. 

### 리액터 프로젝트 버전 1.x
* 리액티브 스트림 스펙을 만들 때 XD 프로젝트(대용량 데이터 응용 프로그램 개발 단순화)와 같이 처리량이 많은 데이터 처리 프레임워크 필요
* 처음부터 비동기 논블로킹 처리를 지원하도록 설계되었고 리액터 패턴, 함수형 프로그래밍 및 리액티브 프로그래밍같은 메시지 처리를 적용합니다. 
* 리액터 프로젝트 버전 1.x의 예제코드
```java
// Environment 인스턴스는 특정 Dispatcher를 만들기 위한 실행 컨텍스트 입니다.
Environment env = new Environment();

// reactor 객체를 생성합니다. 
// RingBuffer 기반의 Dispatcher를 사용합니다. 
Reactor reactor = Reactors.reator() 
                  .env(env)
                  .dispatcher(Environment.RING_BUFFER)
                  .get();

// 채널 선택 및 이벤트 컨슈머를 선언하고 등록합니다. 
reactor.on($("channel"),
          event -> System.out.println(event.getData()));

// 예약된 작업의 형태로 이벤트 프로듀서를 구성합니다. 
// 이벤트를 주기적으로 보내기 위해서 SchduledExecutorService를 사용
Executors.newSingleThreadScheduleExecutor()
        .scheduleAtFixedRate(
          () -> reactor.notify("channel", Event.wrap("test")),
          0, 100, TimeUnit.MILLISECONDS
        );
```

### 리액터 프로젝트 버전 2.x
* 2버전의 리액터 디자인의 가장 큰 변화는 이벤트 버스 및 스트림 기능을 별도의 모듈을 추출하였습니다. 
* 새로운 리액터 스트림(Reactor Stream) 라이브러리가 리액티브 스트림 스펙을 완벽하게 준수합니다. 
  * 자바의 컬랙션 API와도 더욱 쉽게 통합합니다. 
```java
stream.
  .retry()                  // 재시도 연산자로 복원력을 부여합니다.
  .onOverflowBuffer()       // 배압을 관리 할 수 있습니다. 
  .onOverflowDrop()
  .dispatchOn(new RingBufferDispatcher("test")) // 메시지를 비동기으로 처리합니다.
```

### 리액터 프로젝트 3.x
* 이후 리액터 3.0 출시가 되었으며 자바 8을 기준으로 제공됩니다. 
* 라이브러리는 다음과 같이 배압 전파의 일반적인 모드를 모두 지원합니다. 
```java
// 푸시 전용 : 구독자가 효과적으로 무한한 숫자를 요청하는 경우 
subscription.request(Long.MAX_VALUE);

// 풀 전용 : 구독자가 이번 요소를 받은 후에만 다음 요소를 요청하는 경우 
subscription.request(1);

// 풀-푸시 혼합형 : 구독자가 수요를 실시간 제어 할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우 
```


## 리액티브 타입 - Flux와 Mono
* Publisher<T> 구현체로 Flux<T> 및 Mono<T>의 두가지가 있습니다. 
### Flux
* Flux는 0, 1 또는 여러 요소를 생성할 수 있는 일반적인 리액티브 스트림
```java
// 구독자는 
Flux.range(1, 100)  // 1 ~ 100의 정수를 생성
  .repeat()         // 소스 스트림이 끝난 후에 스트림을 다시 구독
  .collectList()    // 연산자를 통해서 모든 요소를 단일 리스트로 생성
  .block();         // 실제 구독을 기동하고 최종 결과가 도착 할 때까지 실행 중인 스레드를 차단함
```
### Mono
* 최대 하나의 요소를 생성할 수 있는 스트림을 정의 
* 버퍼 중복과 동기화 작업을 생략하기 때문에 효율적으로 사용 가능 
* 또한 Mono는 클라이언트에게 작업의 완료를 알리는 데 사용 가능(Mono<Void>)

* Mono와 Flux는 서로 쉽게 변환됩니다. 
* Flux<T>.collectList() -> Mono<List<T>>
* Mono<T>.flux() -> Flux<T>
```java
// mono -> Flux -> mono
Mono.from(Flux.from(mono))
```

## Flux와 Mono 시퀀스 만들기
```java
Flux<String> stream1 = Flux.just("Hello", "wolrd");
Flux<Integer> stream2 = Flux.fromArray(new Integer[]{1,2,3});
Flux<Integer> stream3 = Flux.fromIterable(Arrays.asList(9, 8, 7));

// 2010, 2011, 2012 ... 2019
Flux<Integer> stream4 = Flux.range(2010, 9);

// Mono는 비슷한 팩토리 메서드를 제공하지만 하나의 요소를 대상으로 합니다.
Mono<String> stream5 = Mono.just("One");
Mono<String> stream6 = Mono.justOrEmpty(null);
Mono<string> stream7 = Mono.justOrEmpty(Optional.empty());
```

### Mono로 Http요청이나 DB 쿼리와 같은 비동기 작업 래핑
```java
// httpRequest 요청을 비동기적으로 요청 합니다.
Mono<String> stream8 = Mono.fromCallable(() -> httpRequest());
// JAVA8 부터
Mono<String> stream8 = Mono.fromCallable(this::httpRequest);
```

### 빈스트림과 오류만 포함하는 스트림을 만드는 메서드
```java
Flux<String> empty = Flux.empty();
// naver 메서드는 완료 메시지와 데이터, 오류에 대해서도 신호를 보내지 않습니다.
Flux<String> never = Flux.navar();
// onError를 통해서 항상 오류를 전파하는 시퀀스입니다. 
Mono<String> error = Mono.error(new RuntimeException("Unknow id"));
```

### defer 구독하는 순간 행동을 결정하는 하는 시퀀스 생성
```java
// 이 코드는 실제 구독이 발생할 때까지 sessionID 검사를 연기함 
Mono<User> requestUserData(string sessionID){
   return Mono.defer(() -> isValidSession(sessionID) ? Mono.fromCallable(() -> requestUser(sessionId))
   : Mono.error(new RuntimeException("Invalid user session"))) ;
}

// 이 코드는 함수 호출시 sessionID 검사
Mono<User> requestUserData(string sessionID){
   return isValidSession(sessionID) ? Mono.fromCallable(() -> requestUser(sessionId))
   : Mono.error(new RuntimeException("Invalid user session");
}
```

## 리액티브 스트림 구독하기 
* Flux와 Mono를 구독 루틴을 훨씬 단순화하는 subscribe 메서드를 람다 기반으로 재정의 
```java
// 구독을 하는 가장 간단한 방법입니다.
// 모든 신호를 무시합니다. 
subscribe();

// dateConsumer는 onNext마다 호출됩니다. 
// OnError 및 OnComplete는 처리하지 않습니다. 
subscribe(Consumer<T> dataConsumer);


// onNext, OnError만 처리
// OnComplete는 처리하지 않습니다. 
subscribe(Consumer<T> dataConsumer,
           Consumer<Throwable> errorConsumer);

// onNext, OnError, OnComplete 처리
subscribe(Consumer<T> dataConsumer,
           Consumer<Throwable> errorConsumer,
           Runnable completeConsumer);
// onNext, OnError, OnComplete와 OnSubscription을 처리합니다.
// OnSubscription을 통해서 
subscribe(Consumer<T> dataConsumer,
           Consumer<Throwable> errorConsumer,
           Runnable completeConsumer,
           Consumer<Subscription> subscriptionConsumer);
          
// 시퀀스를 구독하는 가장 일반적인 방법입니다. 
subscribe(Subscriber<T> subscriber);
```
#### 예제 코드
```java

// 결과 : 1, 2, 3, 4
Flux.range(1, 100)
  .subscribe(
    data -> log.info("onNext : {}", data),
    err -> {},
    () -> log.info("onComplete"),
    subscription -> {
      // 4개의 데이터 요청 합니다. 
      subscription.request(4);
      // 구독을 취소합니다. 
      // 즉시 구독을 취소하므로 다른 요소가 생성되지 않습니다. 
      subscription.cancel();
    }
  )

// Disposable은 취소 목적으로도 사용 할 수 있습니다.

// interval메서드는 50밀리 세컨드 마다 이벤트를 생성 할 수 있습니다. 
Disposable disposable = Flux.interval(Duration.onMillis(50))
  // onNext 메서드만 구독합니다.
  .subscribe(
      data -> log.info("onNext : {}", data)
  );

Thread.sleep(200);    // 4개의 이벤트를 구독함
disposable.dispose(); // 내부적으로 구독을 취소하는 dispose를 호출합니다. 
```

### 사용자 정의 Subscriber 구현하기 
* 리액터 프로젝트에서 제공하는 BaseSubscriber 클래스를 상속하는 방법이 있습니다.
```java
// 이외에도 HookOnError, HoolOnCancel, HookOnComplete 등의 메서드를 정의할 수 있습니다.
class MySubscriber<T> extends BaseSubscriber<T> {

    public void hookOnSubscribe(Subscription subscription){
        log.info("initial request for 1 element"); request(1);
    }

    public void hookOnNext(T value){
        log.info("onNext : {}", value);
        log.info("requesting 1 more element");
        request(1);
    }
}
```

### 연산자를 이용해서 리액티브 시퀀스 변환하기 
* 리액티브 시퀀스를 이용해서 작업 할 때 스트림을 생성하고 소비하는 것 외에 스트림을 완벽하게 변환하고 조작 할 수 있습니다.
* 자세한 내용은 http://projectreactor.io/docs/core/release/reference/#which-operator 참조합니다.

### 리액티브 시퀀스의 원소 매핑하기
* Flux 및 Mono는 자바 스트림의 API의 map 연산자와 비슷한 동작을 하는 map연산자를 제공합니다. 
* 시퀀스의 유형이 변경되므로 map 연산자는 Flux<T>가 Flux<R>로 변환되며 Mono도 동일하게 동작합니다. 
```java
Flux.range(2018, 5)   // 2018, ... 2022
  .timestamp()        // Flux<Tuple2<Long, Integer>> 로 변환, 현재 타임스탬프 추가
  .index()            // Flus<Tuple2<Long, Tuple2<Long, Integer>>>로 변환, 인덱스 정보 추가
  .subscribe(e -> log.info("index : {}, ts : {}, value : {}",
    e.getT1(), Instant.ofEpochMilli(e.getT2().getT1()), e.getT2().getT2()
  ));
```

### 리액티브 시퀀스 필터링 하기 
* 리액터 프로젝트에는 다음과 같은 필터링을 위한 여러 종류의 연산자가 포함되어 있습니다. 
  * `filter`는 조건에 만족하는 요소만 통과 시킵니다.
  * `ignoreElements` 연산자는 Mono<T>를 반환하고 어떤 원소도 통과시키지 않습니다. 
    * 결과 시퀀스는 원본 시퀀스가 종료된 후 에 종료 됩니다. 
  * `take` 연산자로 유입되는 원소의 갯수를 제한 할 수 있습니다. 
  * `takeLast` 연산자는 스트림의 마지막 원소만 반환합니다.
  * `takeUntil` 연산자는 어떤 조건이 만족 될 때까지 원소를 전달합니다. 
  * `elementAt`은 시퀀스의 n번째 원소만 가져옵니다. 
  * `single` 연산자는 소스에서 단일 항목을 내보냅니다. 
    * 빈 소스에 대해서는 NoSuchElementException 오류를 발생
    * 복수의 요소를 가질 때는 IndexOutOfBoundsException을 발생 
  * `skip(duration)` 또는 `take(duration)` 양 뿐만 아니라 특정 시간까지 원소를 가져오거나 건너 뛸 수 있습니다.
  * `takeUntilOther(Publisher)`또는 `skipUntilOther(Publisher)`를 이용해서 특정 스트림에서 메시지가 도착 할 때 까지 원소를 건너 뛰거나 가져올 수 있습니다
```java
Mono<?> startCommand = ...
Mono<?> stopCommand = ...
Flux<UserEvent> streamOfData = ...

streamOfData
  .skipUntilOther(startCommand)
  .takeUntilOther(stopCommand)
  .subscribe(System.out::println);
```

### 리액티브 시퀀스 수집하기 
* 리스트의 모든 원소를 수집하고 결과를 Flux.collectList() 및 Flux.collectSortedList()를 사용해 Mono타입 스트림으로 처리 할 수 있음
```java
// 정렬된 숫자를 포함하는 하나의 컬랙션과 다음과 같은 출력이 생성
Flux.just(1, 6, 2, 8, 3, 1, 5, 1)
  .collectSortedList(Comparator.reverseOrder())
  .subscribe(System.out::println);
// 출력 : 8, 6, 5, 3, 2, 1, 1, 1
```
* `collectMap`연산자로 Map<K, T>로 변환
* `collectMultimap` 연사자로 Map<K, Collection<T>> 변환
* `Flux.collect(Collector)` 연산자로 이용해 java.until.stream.Collector를 상속한 모든 형태의 데이터 구조로 변환
* Flux와 Mono에는 입력 시퀀스의 루핑을 허용하는 repeat() 및 repeat(times) 메서드가 있음
* 스트림이 비어 있는 경우 기본 값을 반환하는 defaultIfEmpty(T) 메서드도 있음 
* `distinct`는 입력 시퀀스의 중복을 제외하고 전달합니다. 
  * 이 메서드는 원소를 추적하므로 신중하게 사용 필요(원소가 많은 경우)