# MongoDB 인덱스 

## 클러스터링 인덱스
* 3.6버전까지 클러스터링 인덱스를 지원하지 않습니다. 
* 특정 키를 기준으로 데이터를 저장하는 구조라서 별도의 랜덤 액세스 없이 데이터를 읽을 수 있음 

## 인덱스 내부 
* MongoDB는 전형적인 `B-Tree` 인덱스 내부 구조를 가집니다. 
* 프라이머리 인덱스와 세컨더리 인덱스간의 구조 차이는 없습니다.
  * 프라이머리 인덱스가 클러스터 인덱스가 아님 
### WiredTiger 스토리지 엔진
* 인덱스는 사용자가 정의한 필드 값을 `키`로 document의 저장 주소를 `값`으로 하는 엔트리로 구성됨
  * `Record-Id` 명칭으로 주소 값을 표현함 
* WiredTiger는 실제 주소가 아닌 논리적인 주소값을 사용함
  * 논리 주소를 사용하는 이점은 document의 크기가 커져서 데이터 파일 내에서 위치가 이동되도 `Record-Id` 변경하지 않아도 됨
  * 검색을 위해서 내부적으로 Record-Id값을 키로 가지는 클러스터링 인덱스를 가집니다. 
  * 실제 값을 찾기 위해서는 2번의 인덱스을 수행해야 함

## 로컬 인덱스
* MongoDB의 모든 인덱스(프라이머리와 세컨더리 인덱스 모두)는 샤드 단위로 로컬 데이터에 대한 인덱스를 관리한다. 
* 프라이머리나 유니크 인덱스는 샤드키를 반드시 포함하거나 응용 프로그램 단위에서 유니크함을 보장해야 함 

## 인덱스 키 엔트리 자료 구조
* mongodb의 인덱스는 데이터 파일과는 다르게 스키마(schema)를 가지고 있음
  * 인덱스는 BSON형태로 저장되지 않으며 레코드 형태로 저장됩니다. 

# B-Tree 인덱스 
## 구조 및 특성
* 단일 필드로 구성된 인덱스는 필드의 값만 레코드 형태로 저장됨
* 서브 도큐먼트를 가지는 필드로 구성된 인덱스는 서브 도큐먼트의 필드명이 인덱스에 같이 저장되어야 함
  * 인덱스는 압축을 하지 않기 때문에 인덱스의 크기를 증가 시킴

## B-Tree 인덱스 키 추가 및 삭제
### 인덱스 키 추가 작업
* 컬렉션에 document를 추가하는 비용이 1로 생각했을때 인덱스 하나당 1 ~ 1.5의 비용을 추가로 소모함
### 인덱스 키 삭제 
* 해당 키 값을 찾아서 삭제 마킹을 진행 
* 살제로 변경된 데이터를 디스크에 기록하는 것을 비동기로 처리됨
### 인덱스 키 변경
* 해당 키값을 삭제한다음 새로운 키 값을 추가하는 형식으로 진행됨
  
## B-Tree 인덱스 사용시 영향을 미치는 요소
* MongoDB도 디스크에 데이터를 저장하는 기본 단위를 Page또는 Block이라고 합니다.
* 인덱스의 키는 작을 수록 유리함
  * 인덱스의 키의 사이즈가 하나의 page에 담을 수 있을 갯수를 정의함
    * 예를 들어 32KB 페이지에 인덱스키(16byte) + 자식 노드 주소(12Byte)인 경우
    * 1170개의 자식 노드를 가질 수 있음
  * 하나의 페이지에 읽을 수 있는 노드가 많다는 건 디스크 I/O에 영향을 미침
## 읽어야 하는 레코드 건수
* mongo에서는 인덱스를 통해서 읽어야 할 레코드의 건수가 전체 컬렉션의 15 ~ 20%가 넘어서면 인덱스를 사용하지 않고 풀 스캔을 사용함
