# 샤딩(shareding)이란?
* 데이터를 여러서버에 분산해서 저장하고 처리할 수 있는 기술을 말함
* 컨피그(config) 서버는 파티션된 데이터 범위와 샤드 위치등의 메타 정보 저장용도
* 라우터(Router) 서버는 쿼리 수행의 프록시 역활을 담당
* 스케일 업 대신 스케일 아웃을 통해서 처리용량을 증가 시킵니다. 
  
## 샤딩의 종류
* 수직(Vertival) 샤딩은 주로 기능별로 컬렉션을 그룹핑해서 그룹별로 샤드를 할당하는 방식
  * 구현이 간단한 장점이 있지만 샤드 간의 부하 불균형 발생
* 수평(Horizontal) 샤딩은 하나의 컬렉션에 저장된 도큐먼트들을 영역별로 파티셔닝해서 1/N개씩 각 샤드가 나눠 가지는 방식
  * 수형 샤딩은 파티셔닝의 기준이 되는 필드의 선전이 매우 중요

## MongoDB 샤딩 아키텍쳐
### 샤드 클러스터의 쿼리 수행 절차
* 컨피그 서버는 샤드 클러스터에서 사용자가 생성한 데이터 베이스와 컬렉션 목록을 관리합니다. 
  * 샤딩이 활성화 된 데이터 베이스와 컬렉션의 정보만 관리함
* 컨피그 서버에서는 큰 컬렉션을 여러 조각으로 샤드로 분산하는데 이런 데이터 조각을 청크(`chunk`)라고 합니다.
* MongoDB 라우터로 쿼리 요청 과정
  * 사용자 쿼리가 참조하는 컬렉션의 청크 메타 정보를 컨피그 서버로부터 가져와서 라우터에 메모리에 캐시
  * 사용자 쿼리의 조건에서 샤딩키 조건 찾기
    * 쿼리 조건에 샤딩 키가 있다면 샤딩 키가 포함된 청크 정보를 기준으로 해당 샤드에만 쿼리 조회
    * 쿼리 조건에 샤딩 키가 없다면 모든 샤드 서버로 쿼리 요청
  * 쿼리를 전송한 대상의 샤드 서버로부터 결과가 도착하면 결과를 병합하여 쿼리 결과 반환
* 컨피그서버에서 청크의 메타 데이터를 가져오는 작업은 아래와 같은 상태에서만 발생합니다.
  * 청크 메타 정보를 가지고 있지 않습니다.
  * 청크 메타 정보가 너무 오래되서 맞지 않을 경우 수행

### 컨피그 서버 
* 라우터 서버의 config 데이터 베이스를 통해서 컨피그 서버의 정보를 확인 할 수 있음
* databases 컬렉션은 데이터 베이스의 목록을 관리합니다.
* collections 컬렉션은 샤드 클러스터가 가지고 있는 컬렉션 목록을 관리합니다.
* chuncks 컬렉션은 샤딩된 모든 청크를 관리합니다. 
* shareds 컬렉션은 샤드 클러스터에 등록된 모든 샤드 서버 정보를 레플리카 셋 단위로 관리합니다.
* mongos 컬렉션은 연결된 mongos에 대한 정보를 저장합니다.
  * 현재 실행 중인 mongos를 파악 하도록 각 라우터는 30초 단위로 모든 멤버와 핑을 주고 받습니다.
* settings 컬렉션은 청크의 밸런싱과 관련된 작업에 대한 설정이 저장합니다. 
  * `chunksize` 는 기본 청크 사이즈를 지정합니다. 기본값 64MB
  * `balancer`는 청크의 밸런싱을 활성화 할 것인지 결정하는 옵션입니다.
  * `autosplit`는 자동으로 청크의 크기 사이즈를 넘어서면 새로운 청크로 분리하는 작업을 자동으로 할것인지 여부 설정
* version 컬렉션에는 컨피그서버가 가지는 샤드 클러스터의 메타 데이터 전체에 대한 버전 정보가 저장됨
* lockpings 컬렉션에는 샤드 클러스터의 멤버와 연결 상태 유지 정보를 저장합니다. 
* locks 컬렉션에는 샤드 클러스터에서 발생하는 동기화 작업을 처리하기 위한 lock 객체를 관리합니다. 
* changelog 컬렉션에는 컨피그 서버의 메타 정보 변경을 유발한 이벤트에 대한 정보들을 로그로 관리합니다.

### 컨피그 서버의 복제 방식
* 3.4버전부터 replica set의 구성을 지원함
  * 아비터를 가질 수 없음
  * 지연된 멤버를 가질 수 없음
  * 최소 3개 이상의 멤버로 구성해야 함(권장)
  * Read Concern, Write Concern의 레벨을 'majority'로 설정 수행
    * 일시적인 장애로 롤백되는 데이터가 발생되지 않도록 합니다.

### 컨피그 서버의 가용성 및 쿼리 실행
* 라우터 서버는 기동시 컨피그 서버의 메타 정보를 일괄적으로 로드해서 캐시 메모리에 적재해 둡니다.
* 샤드 클러스터의 멤버 변화, 컬렉션의 생성 및 삭제, 청크의 분리나 이동시에만 컨피그 서버 데이터 변경 쿼리 수행
* 컨피그 서버가 운용되지 않는다면 발생되는 문제
  * 클러스터의 밸런스 작업은 피해야 함
  * 사용자 인증 정보를 관리하기 때문에 새로운 커넥션 추가 불가
  * 기존의 커넥션으로 쿼리는 수행 가능

### 라우터
* 라우터 서버는 사용자의 쿼리를 샤드 서버로 전달하고 쿼리 결과를 모아서 사용자에 반환하는 프록시 역활을 합니다. 
* 주요 역활
  * 사용자의 쿼리를 전달 할 샤드 서버 선정 및 쿼리 전송
  * 샤드 서버로부터 반환된 결과를 조합 및 사용자에게 반환
    * 결과를 전달받아서 그대로 전달하는 것뿐만이 아니라 비정상적인 데이터를 필터링함(청크 `마이그레이션` 발생 가능)
    * 정렬이나 LIMIT,SKIP같은 쿼리에 대해서 특수한 작업 수행 
  * 샤드간 청크 밸런싱 및 청크 스플릿 수행
* 데이터 정렬 및 제한 작업 수행 방식
  * 만약 정렬이 필요한 작업은 3.x 버전부터 프라이머리 샤드가 나머지 샤드들로부터 데이터를 전달 받고 정렬 후에 라우터에 전달함
  * LIMIT 옵션은 각 샤드들에게 옵션을 쿼리에 포함해서 전달해서 수행
  * SKIP 옵션은 각 샤드들에게 전달 할 수 없기 때문에 전체 데이터를 받아서 병합 한 다음 SKIP을 수행함

### 라우터의 쿼리 분산
* 쿼리에 샤딩 기준 키가 포함되는 여부에 따라서 타겟 쿼리나 브로드캐스트 쿼리가 실행됩니다.

#### 타겟 쿼리(Target Query)
* 샤드 키를 가진 쿼리는 샤드 값에 따라서 해당 데이터가 들어 있는 샤드 서버에만 요청을 전달합니다. 
* 샤드 키는 단일 키, 복합 키를 사용 할 수 있습니다.
* INSERT 문장은 항상 샤드 키를 포함하므로 항상 타켓 쿼리로 동작함

### 브로드캐스트 쿼리(Broadcast Query)
* Multi-Update 항상 브로드 캐스트 쿼리로 동작함
* UpdateMany(), DeleteMany()는 샤드 키를 모두 포함하는 경우에만 타켓쿼리로 동작

### 라우터 배포
* 라우터는 N개 이상의 클라이언트와 N개 이상의 샤드 서버와 커넥션을 연결합니다.
* 라우터 서버는 특별히 많은 자원을 사용하지 않기 때문에 다양한 배포방법이 고려됩니다.

#### 응용 프로그램 서버와 함께 라우터 배포
* 응용 프로그램 서버에 MongoDB 라우터를 같이 실행하는 방식이며 매뉴얼에서 권장하는 방법
* 응용 프로그램의 로컬의 라우터로만 접근해서 요청이 수행됩니다.
* 장점 
  * 고가용성을 지원하기 위해서 별다른 작업을 할 필요 없음
  * 응용 프로그램 서버와 라우터간의 네트워크 레이턴시 최소화 
* 단점 
  * 응용 프로그램 서버의 수에 비례해서 샤드 서버의 커넥션의 숫자가 늘어남
  * 라우터만 응답불능일 때 장애 대응 처리 
    * 응용 프로그램 서버에 유저들이 요청해서 지연 발생

#### 전용의 라우터 서버 배포
* 라우터의 전용 인스턴스가 할당되는 형태 
* 장점
  * 위의 예에 비해서 라우터의 수가 줄어들고 커넥션의 숫자가 줄어듬 
* 단점
  * 부하 분산의 문제 발생 가능성

### 커넥션 풀 관린
* 라우터는 클라이언트와 서버를 중계하는 역활을 하기 때문에 양쪽의 커넥션을 가지고 있습니다. 
#### 클라이언트 드라이버 - MongoDB 라우터
* 클라이언트에서 접속할 수 있는 라우터 목록을 모두 등록합니다. 
* 드라이버는 기본적으로 서버간의 부하 분산 및 페일 오버처리를 수행합니다. 
#### MongoDB 라우터 - 샤드 서버
* MongoDB 라우터는 내부적으로 클라이언트의 요청을 처리하기 위해서 cpu 코어만큼 `TaskExecutorPool`을 가집니다.
* `TaskExecutorPool`은 샤드 서버와 연결 정보를 가지는 `커넥션 풀`을 하나씩 가집니다. 
* `커넥션 풀`은 내부적으로 `서브-커넥션 풀`을 가지는데 샤드 서버 하나당 하나씩 생성됩니다. 
* 기본적으로 샤드 서버에 유지하는 커넥션은 1로 설정되며 요청이 많아 질수록 동적으로 증가합니다. 
  * 커넥션이 너무 작은 경우 갑작스런 요청으로 인해서 갑자기 커넥션이 증가하면서 부하가 발생할 수 있음
  * 옵션 변경
    * ShardingTaskExecutorPoolHostTimeoutMS :180000
    * ShardingTaskExecutorPoolMaxSize = 20
    * ShardingTaskExecutorPoolMinSize = 10
* 동적으로 증가한 커넥션은 더 이상 사용을 하지 않으면 커넥션을 끊어버립니다.


### 샤딩 알고리즘
* MongoDB는 데이터 분산처리에 강점을 가집니다. 
* 샤딩 알고리즘은 3가지를 지원함
  * 레인지 샤딩, 해시 샤딩, 태그 기반의 샤딩

#### 청크
* MongoDB 샤드 클러스터에서 각 컬렉션은 샤드 키를 기준으로 쪼개져서 여러 사드에 분산되어 관리됨
* 잘개 쪼개진 컬렉션의 조각을 청크라고 함
* mongoDB에서는 청크는 물리적인 의미를 가지지 않는 논리적 개념입니다.
  * 청크 단위로 파일이 생성되지 않고 데이터 파일에 섞여 배치됨
  * HBase에서는 청크 단위로 데이터가 배치됨
* 위와 같은 이유로 샤드간의 청크 갯수의 불균형이 발생하면 실제 INSERT,DELETE 작업이 이루어집니다.

#### 레인지 샤딩
* 샤드 키의 값을 기준으로 범위로 나눕니다. 
* 장점 
  * 범위 검색 범위를 타겟 쿼리로 실행 할 수 있음
* 단점
  * 데이터가 균형있게 분산되지 않을 가능성이 높습니다. 
  * 하나의 샤드 키 값은 하나의 청크에만 포함될 수 있어서 점보 청크가 발생할 가능성 있음
* 가능하면 해시 샤딩을 사용하고 해시 샤딩을 사용할 수 없을때 고려해본다.

#### 해시샤딩
* MongoDB는 MD5 해시 함수를 통해서 해시키를 생성합니다.
  * 앞쪽의 64비트의 값만 사용합니다.
* 제약사항
  * 범위 검색은 브로드캐스트 쿼리 실행
  * 샤드 키 필드에 해시 인덱스 생성 
  * 단일 필드에 대해서만 해시 인덱스 생성 가능
  * 부동 소수점 필드는 소수점 이하를 버리고 해시 함수 수행
  * 2의 53승보다 큰 부동 소수점 해시 인덱스 지원 안함
* 장점  
  * 연속된 값으로 인한 데이터 불균형을 해소함

#### 지역기반 샤딩
* 레인지 샤딩이나 해시 샤딩이 적용된 상태에서 적용 할 수 있음
* 생성된 목적은 국가나 지역 기반으로 데이터의 저장소를 분리하기 위함
* 일반적으로 레인지 샤딩에 값을 특정 tag를 붙여서 관리함

#### 각 샤드 서버의부하 분산
* 


