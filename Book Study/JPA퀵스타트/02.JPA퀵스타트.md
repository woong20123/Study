## 엔터프라이즈 자바빈즈(EJB)
* EJB는 기업 환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델 
* EJB는 애플리케이션 업무 로직을 가지고 있는 서버 어플리케이션입니다.
  
### EJB의 종류
* 세션 빈(Session Bean) : DB 연동 필요 없음
* 엔티티 빈(Entity Bean) : 
  * 데이터베이스를 관리하는 객체
  * Insert(삽입), Update(수정), Delete(삭제), Select(조회)
  * DB 쿼리는 자동으로 생성되고 개발자는 고급 업무에 집중 할 수 있음
  * DB가 수정되면 코드 수정 없이 다시 배포
* 메시지 구동 빈(Message-driven Bean) 
  * JMS로 Bean을 날려줌

### EJB의 종류
* ORM의 시초는 EJB의 엔티티 빈입니다. 
* EJB의 엔티티 빈은 느린 성능과 구현의 복잡함으로 개발자들에게 외면 받음 
* JPA(Java Persistence API)라는 새로운 스펙을 발표 
  * java의 기본 표준

## JPA 퀵스타트
* JPA는 JDBC와 동일한 데이터 베이스 연동을 지원합니다. 
  * JDBC는 인터페이스를 제공하고 각 DB 드라이버는(Oracle, Mysql, H2)는 구현을 담당합니다. 
* JPA(javax.persistence) 인터페이스
  * Hibernate, EclipseLink, DateNucleus가 각각 구현을 담당합니다.

## VO 클래스
* JDBC에서 테이블의 컬럼과 매핑되는 값을 같는 자바빈 클래스를 말함
  
### 엔티티 클래스 작성과 테이블 매핑
* JPA에서 테이블과 매핑되는 자바 클래스를 엔티티 클래스라고 합니다.
* JPA를 사용할 때 가장 먼저 엔티티 클래스를 작성합니다. (기본의 VO 클래스와 동일한 개념)
```java
@Data
// 필수 @Entity가 설정된 클래스는 엔티티 클래스라고 하며 name속성으로 엔티티 이름을 지정할 수 잇음
@Entity
// 옵션 @Table 엔티티와 매핑할 테이블을 지정합니다. 기본적으로 엔티티 이름과 동일한 이름으로 테이블이 매핑되나 name값을 지정하면 테이블 지정가능
@Table(name="S_EMP")
public class Employee {

    // 테이블의 기본 키와 매핑되는 식별자 변수를 매핑합니다.
    @Id
    private Long id;

    private String name;

    private String mailId;

    @Column(name = "START_DATE")
    private Date startDate;

    private String title;

    @Column(name= "DEPT_NAME")
    private String deptName;

    private Double salary;
    
    @Column(name = "COMMISSION_PCT")
    private Double commissionPct;
}
```

### JPA 메인 설정 파일 작성 
* `src/main/resources/` 폴더를 추가하고 META-INF 폴더 생성한 후 `persistence.xml`이라는 파일을 작성
* 클래스 패스에 등록된 엔티티 클래스는 JPA가 자동으로 인식하기 때문에 반드시 등록하지 않아도 됩니다. 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.1" xmlns="http://xmlns.jcp.org/xml/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
            http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">

    <!-- 영속성 유닛 설정 -->
    <persistence-unit name="Chapter02">
        <!-- 엔티티 클래스 등록 -->
        <class>com.rubypaper.biz.domain.Employee</class>

        <!-- JPA 프로퍼티 설정 -->
        <properties>
            <!-- 데이터 소스 관련 설정-->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver" />
            <property name="javax.persistence.jdbc.user" value="sa" />
            <property name="javax.persistence.jdbc.password" value="" />
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test" />

            <!-- JPA 구현체 관련 설정 
            hibernate.dialect는 H2Dialect설정해서 h2에 최적화된 sql을 생성합니다. 
            hibernate.hbm2ddl.auto는 엔티티 클래스를 매핑할 테이블과 관련된 설정 
            -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" />
            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.hbm2ddl.auto" value="create" />
        </properties>
    </persistence-unit>
</persistence>
```

### JPA로 데이터 저장하기
```java
public static void main(String[] args){
    // persistence.xml에서 "Chapter02" 속성을 찾아서 객체를 생성 
    EntityManagerFactory emf = 
        Persistence.createEntityManagerFactory("Chapter02");

    EntityManager em = emf.createEntityManager();

    EntityTransaction tx = em.getTransaction();

    try{
        Employee employee = new Employee();
        employee.setId(1L);
        employee.setName("둘리");
        employee.setMailId("gurum");
        employee.setStartDate(new Date());
        employee.setTitle("과장");
        employee.setDeptName("총무부");
        employee.setSalary(2500.00);
        employee.setCommissionPct(12.50);

        tx.begin();
        // 직원 등록
        // persist 구문은 트랜잭션 안에서 실행 되어야 합니다. 
        // 등록/수정/삭제 작업은 반드시 트랜잭션 안에서 수행되어야 합니다. 
        em.persist(employee);

        // 트랜잭션 종료(COMMIT)
        tx.commit();
    } catch(Exception e){
        e.printStackTrace();

        // 트랜잭션 종료(ROLLBACK)
        tx.rollback();
    } finally {
        em.close();
        emf.close();
    }
}
```

## JPA 메인 설정파일 
### 영속성 설정 파일
* 다음은 `EntityManager` 객체를 획득하는 과정을 그림을 표현 합니다.
  * persistence.xml 로딩 -> Persistence 생성 -> EntityMangerFactory -> EntityManager
  * persistence.xml에서 Persistence Unit을 설정
    * `<persistence-unit name="Chapter02">`
```java
    EntityManagerFactory emf = 
        Persistence.createEntityManagerFactory("Chapter02");
    EntityManager em = emf.createEntityManager();
```
### 엔티티 클래스 등록
* @Entity 어노테이션이 설정된 클래스를 등록해주면 됩니다. 
* JPA는 클래스 패스상의 엔티티 클래스를 자동으로 등록해줍니다. 
```xml
    <persistence-unit name="Chapter02">
        <!-- 엔티티 클래스 등록 -->
        <class>com.rubypaper.biz.domain.Employee</class>
```

### 데이터 소스 설정
* 특정 데이터 베이스와 연결하기 위한 데이터 소스를 설정합니다.
* 데이터 소스를 기반으로 커넥션을 획득하고 관리합니다.
  * javax.persistence.jdbc.driver : JDBC 드라이버 클래스
  * javax.persistence.jdbc.user : 데이터베이스의 아이디
  * javax.persistence.jdbc.password : 데이터베이스의 비밀번호
  * javax.persistence.jdbc.url : JDBC URL 정보 
```xml
        <!-- JPA 프로퍼티 설정 -->
        <properties>
            <!-- 데이터 소스 관련 설정-->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver" />
            <property name="javax.persistence.jdbc.user" value="sa" />
            <property name="javax.persistence.jdbc.password" value="" />
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:t
```
### Dialect 클래스 설정 
* JPA가 특정 데이터베이스의 최적화된 SQL을 생성할 수 있는 것은 영속성 유닛의 다이얼렉트(Dialect) 클래스 덕분입니다.
* 데이터 베이스별 Dialect 클래스
  * PostgreSQL : org.hibernate.dialect.PostgreDialect
  * MySql : org.hibernate.dialect.MySQLDialect
  * Microsoft SQL Server : org.hibernate.dialect.SQLServerDialect
```xml
<property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" />
```

### SQL 속성 관련 
* hibernate.show_sql : 하이버네이트가 생성한 SQL을 콘솔에 출력합니다.
* hibernate.format_sql : 하이버네이트가 생성한 SQL을 출력할 떄 들여쓰기를 포함한 보기 좋은 포맷으로 출력합니다. 
* hibernate.id.new_generator_mappings : JPA 스펙에 맞는 새로운 키 생성 전략을 사용하도록 합니다. 
* hibernate.hbm2ddl.auto : 테이블 생성 및 변경, 삭제 같은 DDL 구문을 자동으로 처리할지 지정합니다.
  * create 
    * 어플리케이션을 실행시 다음과 같은 동작을 수행
    * DROP -> CREATE
  * create-drop
    * DROP -> CREATE -> DROP
  * update
    * 기존에 사용중인 테이블이 있으면 생성하지 않고 재사용합니다.

## 엔티티 매핑 설정하기 
* 테이블의 관계를 엔티티 관계로 매핑하는 것이 JPA에서는 연관 관계 매칭이라고 합니다. 

### @Entity와 @Id 어노테이션 
* @Entity는 생략할 수 없는 필수 어노테이션 입니다. 
* @Entity가 선언된 객체만 엔티티로 인지하고 사용 할 수 있습니다. 
* @Entity가 설정된 클래스는 다른 엔티티과 구분되는 이름을 가져야 합니다.
```java
// name을 설정하지 않으면 @Entity는 "Employee"를 이름으로 가집니다.
// JPQL(JPA Query Language)를 작성할 때 클래스 이름과 동일한 엔티티 이름 사용
// String spql = " SELECT e FROM Employee e";
@Entity
public class Employee {
    @Id
    private Long id;
```
### @Table 어노테이션 
* JPA는 기본적으로 엔티티 이름과 동일한 테이블을 매핑합니다. 