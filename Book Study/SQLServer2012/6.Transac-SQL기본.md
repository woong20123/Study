### ANY/ALL/SOME, 하위쿼리(서브 쿼리)
* 서브 쿼리의 결과 값이 복수 일때 `ANY/ALL/SOME`을 사용 할 수 있습니다.
  * ANY는 결과중에 하나라도 만족하면 됩니다.(OR) 
  * ALL은 결과 여러개를 모두 만족해야합니다.(AND)
```sql
SELECT name, height FROM userTbl
-- 서브쿼리의 결과값이 복수 일때 ANY 사용
WHERE height >= ANY(SELECT height FROM userTbl WHERE addr = '경남')
```


## GROUP BY, HAVING, 집계함수
* 결과 데이터를 집계(aggregate)할 때 사용 됩니다. 
* 특정 컬럼을 GroupBy로 묶고 집계 함수로 연산합니다. 
```sql
USE sqlDB;
SELECT userID, amount FROM buyTbl ORDER BY userID;
-- userID로 그룹을 묶고 amount를 SUM으로 합산합니다.
SELECT userID AS [사용자아이디], SUM(amount) as [총구매갯수] FROM butTbl GROUP BY userID;

-- CAST나 CONVERT를 사용해서 정수를 실수형으로 변환.
SELECT AVG(CAST(amount AS DECIMAL(10, 6))) AS [평균구매개수] FROM buyTbl;
```
### 집계함수

|함수명|설명|
|:--|:--|
|AVG()|평균을 구합니다.|
|MIN()|최소를 구합니다.|
|MAX()|최대를 구합니다.|
|COUNT()|행의 갯수 구합니다.|
|COUN_BIG()|COUNT와 같지만 bigintg형.|
|STDEV()|표준편차를 구합니다.|
|VAR()|분산을 구합니다.|

## Having절
* 집계 함수에 대해서만 조건을 제한하는 역활을 합니다. 
* HAVING 절은 GROUP BY 절 다음에 나와야 합니다. 
```sql
SELECT userID AS [사용자], SUM(price * amount) AS [총구매액]
FROM buyTbl
-- WHERE SUM(price*amount) > 1000 => WHERE 사용 불가
GROUP BY userID
HAVING SUM(price*amount) > 1000;
```

## ROLLUP() / GROUPING_ID() / CUBE() 함수
* GROUP BY 와 `ROLLUP`을 같이 사용하면 총합을 추가합니다.
* GROUP BY로 지정된 컬럼은 NULL로 설정됩니다. 
* `GROUPING_ID`를 사용하면 추가행 여부를 0, 1로 확인 할 수 있습니다.
```sql
SELECT groupName, SUM(price * amount) AS [비용],
GROUPING_ID(groupName) AS [추가행여부]
FROM buyTbl
GROUP BY ROLLUP(groupName);
```

## T-SQL 의 분류
### DML
* DML(Data Manipulation Language - 데이터 조작 언어)은 데이터를 조작하는데 사용합니다. 
* SELECT, INSERT, UPDATE, DELETE
* 트랜젝션이 발생하는 SQL도 DML입니다. 
### DDL
* DDL(Data Definition Language - 데이터 정의 언어)는 테이블, 뷰, 인덱스같은 데이터 베이스 개체를 생성, 삭제, 변경하는 역활을 합니다. 
* CREATE, DROP, ALTER 등이 있습니다. 
* DDL는 트랜젝션을 발생시키지 않습니다. 즉시 실행 됩니다. 

## DCL
* DCL(Data Control Language)은 사용자에게 어떤 권한을 부여하거나 빼앗을 때 사용하는 구문입니다ㅏ. 
* GRANT / REVOKE / DENY 가 있습니다. 

## INSERT
### IDENTITY
* 데이터 속성이 `IDENTITY`로 지정되어 있다면 해당열이 없다고 생각하고 INSERT 구문을 추가할 수 있습니다. 
* 자동으로 1부터 증가하는 값을 지정합니다. 
```sql
CREATE TABLE testTbl2
( id int IDENTITY 
-- 생략)
```
### SEQUENCE
* 2012부터 IDENTITY와 같은 효과는 내는 시퀀스 개체를 사용 할 수 있습니다. 
```sql
-- 1부터 시작하고 1씩 증가하는 시퀀스
CREATE SEQUENCE idSEQ START WITH 1 INCREMENT BY 1;

-- NEXT VALUE FOR 시퀀스 이름
INSERT INFO testTbl3 VALUES (NEXT VALUE FOR idSEQ, '강동원', 27, DEFAULT);
```