# 문서정리

### 간단한 DAO만들기
* User 클래스 실습 
  * 자바빈을 지원하는 형태의 클래스를 생성합니다. 

* DAO의 분리
  * 분리와 확장을 고려한 설계가 존재 해야 한다.
  * 변화는 일반적으로 한가지 관심에 대해서 발생합니다. 
    * 예를 들어 DB 접속용 암호를 변경한다면?
    * 트랜잭션 기숭을 다른것으로 변경된다면?
  * 이러한 한가지의 관심을 한 군데로 집중한다면 관리가 편리해질 것이다. 
* 예제 UserDao의 관심사항
  1. DB와의 연결을 위한 커네션을 어떻게 가져올것인가?
     * DB는 어떤것을 사용하고 드라이버는 어떤 것을 사용할 것인지 등등
  2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행 시키는 것
     1. SQL 문자에 전달받은 변수를 바인딩 방법
  3. 작업이 완료된 후에 리소스를 시스템에 반환하는 작업

* 개선 방법
  * 리펙토링 방법중 하나인 메서드 추출 기법으로 중복되는 코드를 제거합니다.

## 원칙과 패턴
### 객체 지향 설계 원칙(SOLID)
* SRP(The Single Responsibility Principle) : 단일 책임 원칙
* OCP(OCP Open-Closed Principle) : 개발 폐쇄 원칙
  * 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야한다. 
    * 예를 들어 UserDao는 DB 연결 방법과 같은 기능을 확장하는데는 열려 있어야 한다.
    * UserDao의 영향을 주지 않고 기능 확장이 되어야 하며 핵심 기능에 영향을 주지 않습니다.
* LSP(The Liskov Substitution Principle) : 리스코브 치환 원칙
* ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙
* DIP(The Dependency Inversion Principle) : 의존 관계 역전 원칙
* http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
* 도서 
  * Java 프로그래머를 위한 UML 실전에서는 이것만 쓴다. : 밥 마틴
  * 소프트 웨어 개발의 지혜 : 원칙, 디자인 패턴, 실천 방법 : 밥 마팅
### 높은 응집도와 낮은 결합도
#### 높은 응집도
> 높은 응집도란 변화가 일어 날 때 모듈에서 변하는 부분이 크다는 것을 뜻하며
책임과 관심사를 기준으로 오브젝트나 모듈이 구현되어 있는 것을 뜻합니다.  

#### 낮은 결합도
> 낮은 결합도는 책임과 관심사가 다른 오브젝트와 모듈은 느슨하게 연결된 형태를 유지하는 것을 뜻합니다
결합도란 "하나의 오브젝트가 변경될 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도"입니다. 
  
예제의 DAO 객체는 DB 연결에 대한 기능을 DB connection을 인터페이스 클래스로 분리하고 생성책임을 DAO 외부에서 결정하도록 구현해서 낮은 결합도를 지원합니다. 

DAO 객체는 사용자의 데이터를 처리하는 기능을 지원하고 ConnectionMake는 자신의 기능에 충실하도록 지원합니다.  
  
## 제어의 역전(IoC)
### 팩토리
> 객체의 생성 방법을 결정하는 오브젝트를 팩토리라고 부릅니다. 
팩토리를 사용하면 컴포넌트 객체들과 설계 관점의 객체들 구분할 수 있습니다. 
### 제어권의 이전을 통한 제어관계 역전
#### 일반적인 프로그램의 흐름
1. main() 메소드에서 프로그램 시작
2. 사용할 오브젝트 결정하고 생성합니다. 
3. 오브젝트의 메소드를 호출해서 프로그램의 흐름을 제어합니다.  
> 즉 사용자 입장에서 모든 종류의 작업을 제어합니다. 

#### 제어의 역전이란?
> IoC에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도 생성하지도 않습니다.
>  자신이 어떻게 만들어지고 어떠헥 사용되는지 알 수 없으며 모든 제어 권한을 자신이 아닌 다른 대상에게 위임합니다. 

일반적인 Java 프로그램은 main() 메서드를 통해서 오브젝트가 생성되고 실행됩니다. 
하지만 서블릿을 개발해서 서버에 배포 할 수는 있지만 그 실행을 개발자가 직접 제어 할 수 있는 방법이 없기 때문에 서블릿에서는 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스 오브젝트를 만들고 그 안의 메소드르 호출합니다. 

## 스프링의 IOC
스프링은  IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있습니다. 
스프링의 핵심을 담당하는 건 바로 빈 팩토리 또는 애플리케이션 컨텍스트라고 불립니다. 
### 애플리케이션 컨텍스트 와 설정 정보
#### 빈(bean)
> 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 "빈" 이라고 부릅니다. 
> 스프링은 빈에 IoC를 적용합니다. 

#### 빈 팩토리
> 빈의 생성과 관계 설정의 제어를 담당하는 IoC 오브젝트를 말합니다. 

#### 어플리케이션 컨텍스트 
> Ioc 방식에 따라 만들어진 일봉의 빈 팩토리를 말하며 애플리케이션 전반에 걸처 모든 구성 요소의 제어 작업을 담당하는 IoC엔진의 의미로 쓰임
> 별도의 정보를 참고해서 빈의 생성, 관계 설정등의 제어 작업을 촐괄합니다. 

#### DaoFactory를 사용하는 애플리케이션 컨텍스트
@Configuration, @Bean 애노테이션을 추가해서 설정할 수 있습니다.

애노테이션 설정 예제
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DaoFactory {
	@Bean
	public UserDao userDao() {
		UserDao dao = new UserDao(connectionMaker());
		return dao;
	}

	@Bean
	public ConnectionMaker connectionMaker() {
		ConnectionMaker connectionMaker = new DConnectionMaker();
		return connectionMaker;
	}
}
```
애플리케이션 컨텍스트 사용 예제
```java
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    // getBean(함수명, 클래스) 함수명을 파라미터로 가지는 이유는 다양한 구성 정보를 가질 수 있는 장점이 있습니다.
    UserDao dao = context.getBean("userDao", UserDao.class);
```
#### 어플리케이션 컨텍스트 동작 방식 
![app_context_running_method](./img/1_app_context_running_method.png)
> 어플리케이션 컨텍스트에 DaoFactory를 어떻게 사용되고 있는지를 그림으로 표현해줍니다. 
> 어플리케이션 컨텍스트는 등록된 설정정보에서 @Bean이 붙은 메소드를 가져와서
Bean 목록을 만듭니다. 

#### 어플리케이션 컨텍스트 장점
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없습니다. 
  * 



## 용어 정리
* DAO 
  * Data Access Object라고 합니다.
  * DB를 사용해서 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
* 자바빈
  * 자바빈(JavaBean)은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말합니다. 
  * 자바가 웹 기반으로 바뀌면서 두가지 관례로 만들어진 오브젝트를 가르킵니다. 
    * 디폴스 생성자 
      * 자바빈은 파라미터가 없는 디폴트 생성자를 가져야 합니다. 
      * 툴이나 프레임 워크에서는 리플렉션을 이용해서 오브젝트를 생성합니다. 
    * 프로퍼티
      * 자바 빈이 노출하는 이름을 가진 속성을 프로퍼티라고 합니다 
      * 프로퍼티는 set함수와 get함수를 지원해야합니다. 
* 리펙토링
  * 기존의 코드를 외부의 동작방식에는 변화없이 내부의 구조를 변경해서 재구성 하는 작업이나 기술을 말합니다. 
### 프레임워크에서 IoC
> 프레임워크는 라이브러리의 차이점은 라이브러리는 애플리케이션의 흐름제어를 직접하지만 
> 반대로 프레임워크는 반대로 애플리케이션 코드가 프레임워크에의 사용됩니다. 
> 일반적으로 프레임워크 위에 개발한 클래스를 등록해두고 프레임워크가 흐름을 주도합니다. 


