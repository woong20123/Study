#### 자바에서는 javax.sql.DataSource를 사용해서 연결합니다. 
#### 실제 시스템에서는 히카리CP 같은 적절한 연결 풀을 사용해야 합니다. 

## 데이터 소스 설정 
### 애플리케이션에서 데이터 베이스에 접속해야 한다. 
* 의존성 추가
  * spring-boot-starter-jdbc
  * spring-jdbc, spring-tx 관련 의존성 포함 및 기본 연결 풀은 히카리CP

### 내장 데이터 소스 사용 방법
#### 스트링 부트 H2나 HSQLDB또는 더비를 발견하면 발견한 내장 데이터 베이스의
#### 내장 연결 풀 구현체를 사용해서 기동합니다. 
#### 테스트 코드나 데모, 시연을 준비할 때 유용합니다. 
* 의존성 추가 
```xml
<dependency>
    <groupId>org.apache.derby</groupId>
    <artifactId>derby</artifactId>
    <scope>runtime</scope>
</dependency>
```

* 소스 코드
```java
@Component
class TableLister implements ApplicationRunner{
	private final Logger logger = LoggerFactory.getLogger(getClass());
	
	private final DataSource dataSource;
	
	TableLister(DataSource dataSource){
		this.dataSource = dataSource;
	}
	
	@Override
	public void run(ApplicationArguments args)throws Exception{
		try (var con = dataSource.getConnection()){
			var rs = con.getMetaData().getTables(null, null, "%", null);
			while(rs.next()) {
				logger.info("{}", rs.getString(3));
			}
		}
	}
}
```

### 외장 데이터베이스 사용
#### 데이터 베이스에 연결하려면 JDBC 드라이버가 필요합니다. 
#### Mysql을 사용한다면 Mysql의 JDBC 드라이버가 필요합니다. 
* 의존성 추가 
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```
* 아래의 속성을 application.properties에 설정합니다. 
  * spring.datasource.url
  * spring.datasource.username
  * spring.datasource.password 
```ini
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://vitess-alpha.ncsoft.com:31199/pbn_test2
spring.datasource.username=pbn
spring.datasource.password=pbn!2345
spring.datasource.initialize=true
```
#### JNDI로부터 데이터 소스 생성하기 
* JNDI(Java Naming and Directory Interface)란 
  * 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견하고 참고 하기 위한 자바 API
    * 자바 애플리케이션을 외부 디렉터리 서비스에 연결 
    * 자바 애블릿이 호스팅 웹 컨테이너가 제공하는 구성정보 참고
* 설정 예제
```ini
spring.datasource.jndi-name=java:jdbc/customers
```
#### 연결 풀 설정
* 기본 연결 풀 히카리 CP
  
|속성|설명|
|:--:|:--:|
|spring.datasource.hikari.<br>connection-timeout|클라이언트가 풀에 접속 할 때 대기하는 최대시간<br>기본값은 30초(30000밀리초)다|
|spring.datasource.hikari.<br>leak-detection-threshold|연결 객체가 고갈되기전 메시지 출력|
|spring.datasource.hikari.<br>idle-timeout|연결 풀의 연결 객체가 대기 상태로 변경될 때까지 기다리는 시간<br>기본 값은 10분(600000밀리초)|
|spring.datasource.hikari.<br>validation-timeout|연결 객체가 살아 있는지 검증할 때 까지 기다리는 시간 밀리초<br>기본 값은 5초(5000밀리초)|
|spring.datasource.hikari.maximum-pool-size| 풀에 보관할 최대 연결 갯수 기본값 10개|
|spring.datasource.hikari.minimun-idle| 풀에 유지 할 최소 대기 연결 객체 수 기본값 10개|

#### 스트링 부트에서 데이터 베이스 초기화 
* 데이터 베이스에 sql 파일을 통해서 스키마 생성과 데이터 삽입을 제공합니다. 
* schema-<데이터베이스플랫폼이름>.sql과 data-<데이터베이스플랫폼이름>.sql를 사용해서 특정 데이터 베이스에 특화된 초기 데이터를 설정할 수 있습니다. 
#### 플라이웨이(Flyway)로 데이터 베이스 초기화 
* 플라이웨이란 데이터 베이스 형상 및 버전 관리 도구
* 데이터 스키마의 변경 사항을 체계적으로 관리한다. 
* 의존성 추가 
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```
* 통합 스크립트 위치
  * src/main/resource/db/migration
  * 이름의 명명 규칙은 V<순서>_<이름>.sql 입니다.
  * 한번 실행되면 스크립트를 더 이상 수정할 수 없습니다. 
  * 예제 V1_first.sql
```sql
CREATE TABLE customer(
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    UNIQUE(name)
);

INSERT INTO customer(name, email) VALUES
('Marten Deinum', 'marten.deinum@conspect.nl'),
('Josh Long', 'jlong@pivotal.com'),
('John Doe', 'john.doe@island.io');
```
* 속성 정보

|속성|설명|
|:--:|:--:|
|spring.flyway.enabled|플라이웨이를 사용할 것인지 여부<br>기본값 true|
|spring.flyway.location|통합 작업 스크립트 위치<br>classpath:db/migration|
|spring.flyway.url|데이터베이스 통합 작업을 진행 할 JDBC 주소<br>기본값 데이터 소스 설정 값|
|spring.flyway.user|플라이웨이 자제 설정시 유저이름|
|spring.flyway.password|플라이웨이 자제 설정시 비밀번호|

## JdbcTemplate
### 예제 구현
```java
@Component
class CustomerLister implements ApplicationRunner {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    private final JdbcTemplate jdbc;

    CustomerLister(JdbcTemplate jdbc){
        this.jdbc = jdbc;
    }

    @Override
    public void run(ApplicationArguments agrs){
        var query = "SELECT id, name, email FROM customer";
        jdbc.query(query, rs -> {
            logger.info("Customer [id={}, name={}, email={}]",
                rs.getLong(1), rs.getString(2), rs.getString(3));
        });
    }
}
```
## JPA
#### 스프링 부트는 하이버 네이트를 자동으로 감지해서 JPA관련 필요한 클래스를 생성
### 의존성 추가 
* spring-boot-starter-data-jpa

### 일반적인 JPA Repository 클래스 사용하기 
* 엔티티를 표현하는 클래스에 애노테이션을 추가해 구분
* 엔티티에 @Entity 애노테이션을 달아줍니다. 
* Entity 클래스
```java
public class Customer{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id

    @Column(nullable = false)
    private final String name;

    @Column(nullable = false)
    private final String email;

    Customer(){
        this(null, null)
    }
    // 일부 생략
}
```
* CustomerRepository 클래스
```java
package 생략;
import org.springframework.stereotype.Repository;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import java.util.List;

@Repository
class JpaCustomerRepository implements CustomerRepository{
    @PersistenceContext
    private EntityManager em;

    @Override
    public List<Customer> findAll(){
        var query = em.createQuery("SELECT c FROM Customer c", Customer.class);
        return query.getResultList();
    }

    @Override
    public Customer findById(long id){
        return em.find(Customer.class, id);
    }

    @Override
    public Customer save(Customer customer){
        em.persist(customer);
        return customer;
    }
}
```
* 속성
  
|속성|설명|
|:--:|:--:|
|spring.jpa.database|JPA를 적용할 대상 데이터 베이스<br>기본값 자동 탐지|
|spring.jpa.database-platform|JPA를 적용할 데이터 베이스 이름<br>기본값 자동 탐지|
|spring.jpa.generate-ddl|시작시 스키마를 초기화 할것인지 여부<br>기본값은 false|
|spring.jpa.show-sql|SQL 구문을 로그에 표시할 것인지 여부<br>기본값은 false|
|spring.jpa.open-in-view|OpenEntityManagerInViewInterceptor를 등록할지 여부<br>Entity를 요청 처리 스레드에 바인딩한다.<br>기본값 true|
|spring.jpa.hibernate.ddl-auto|hibernate.hbm2ddl.auto 속성을 설정<br>기본값은 none|
|spring.jpa.hibernate.use-new-id-generator-mappings|hibernate.id.new_generator_mappings속성 설정<br>기본값은 true|
|spring.jpa.hibernate.naming.implicit-strategy|논리적인 네이밍 룰을 처리하는 전략 클래스<br>기본값은 SpringImplicitNameingStrategy|
|spring.jpa.mapping-resources|자바 클래스 대신 XML형식의 엔티티를 매칭 파일을 지정|
|spring.jpa.properties.*|JPA 제공자 관련 설정|

### JPA Repository로 스프링 데이터를 사용
* 자체적인 Repository 클래스를 만드는 일은 지루하고 반복적
* 스프링 JPA를 사용하면 손쉽게 사용할 수 있습니다.
* CrudRepository 인터페이스를 확장해서 사용합니다. 
```java
public interface CustomerRepository extends CrudRepository<Customer, Long>{}
```
* findAll, findById, save등의 메소드를 추가만 하면 된다. 

## 다른 패키지의 엔티티 추가하기 
#### 기본적으로 스프링 부트는 컴포넌트와 리포지토리, 엔티티를 @SpringBootApplication 애노테이션이 붙은 클래스가 존재하는 패키지를 탐색합니다. 
#### 별도의 패키지로 둔 상태로 탐색할 수 있게 만들어야 할 때는 @EntityScan 애노테이션을 사용합니다 .

```java
package com.example.demo.sub;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.Objects;

@Entity
public class Order{
    @Id
    private long id;
    private String number;

    // 생략
}
```
#### 해당 패키지는 com.example.demo.sub에 만들었기 때문에 com.example.demo 패키지에 #### @SpringBootApplication 애노테이션이 있다면 검색을 할 수 없습니다. 
```java
@SpringBootApplication
@EntityScan({
    "com.example.demo.sub"
})
```

## JPA 기반 테스트 
### 스프링 부트는 내장 데이터 베이스를 제공해서 JPA 테스트를 쉽게 작성하도록 지원합니다다
### H2를 사용해서 지원합니다.
* 의존성
```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>
```
* CustomerRepository를 사용하는 테스트 클래스 추가 
```java
@RunWith(SpringRunner.class)
@DataJpaTest
@TestPropertySource(properties = "spring.flyway.enable=false")
public class CustomerRepositoryTest{
    @Autowired
    private CustemerRepository repository;

    @Autowired
    private TestEntityManager testEntityManager;
}
```

* 테스트 코드 작성 
```java
@Test
public void insertNewCustomer(){
    assertThat(repository.findAll()).isEmpty();

    Customer customer = repository.save(new Customer(-1, "T. Testing", "t.testing@test123.tst"));

    assertThat(customer.getId()).isGraterThan(-1L);
    assertThat(customer.getName()).isEqualTo("T. Testing");
    assertThat(customer.getEmail()).isEqualTo("t.testing@test123.tst");

    assertThat(repositoy.findById(customer.getId())).isEqualTo(customer);
}
```