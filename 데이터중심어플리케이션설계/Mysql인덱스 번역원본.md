# 번역내용
## MYSQL 인덱스를 사용하는 방법
#### 인덱스는 특정 열 값이 있는 행을 빠르게 찾는 데 사용됩니다.
#### 인덱스가 없으면 Mysql은 첫번째 행으로 시작한 다음 전체 테이블을 읽어 관련 행을 찾아야 합니다.
#### 테이블이 클수록 비용이 많이 듭니다. 
#### 만약에 쿼리안의 컬럼에 대한 인덱스를 가진다면 MYSQL은 모든 데이터를 보지 않고도 데이터 파일 중간에서 찾을 위치를 신속하게 결정할 수 있습니다. 
#### 이 방식은 모든 행을 순차적으로 읽는 것보다 훨씬 빠릅니다. 
#### **대부분의 MYSQL 인덱스는 B-tree에 저장됩니다.**
#### 예외 : 공간 데이터 유형의 인덱스는 R-트리를 사용합니다. 
#### 메모리 테이블은 hash index를 지원합니다. 
#### InnoDB는 Fulltext 인덱스에 대해 반전된 목록을 사용합니다. 
#### 일반적으로 인덱스는 다음 설명 된대로 사용됩니다. 
#### MySQL은 다음 작업에 인덱스를 사용합니다. 
* Where 절과 일치하는 행을 빠르게 찾기 위해서 
* 고려하고 있는 대상에서 행을 제거합니다. 여러 인덱스중에 선택할 수 있는 경우에 MYSQL은 가장 적은 수의 row를 찾는 인덱스를 사용합니다. (the selective index)
* 만약 다중 컬럼 인덱스를 가진다면 인덱스의 가장 왼쪽의 컬럼은 옵티마이저가 행을 조회하는 데 사용할 수 있습니다.
  * 만약에 (col1, col2, col3)같이 3개의 인덱스를 가진다면 (col1), (col1, col2), (col1,col2,col3)의 검색기능을 색인화합니다. 
* 조인을 수행 할 때 다른 테이블에서 행을 검색합니다.
  * MYSQL은 동일한 유형의 크기로 선언된 열에 대한 인덱스를 보다 효율적으로 사용합니다. 
  * VARCHAR와 CHAR는 동일한 크기로 선언되면 동일한 것으로 간주됩니다. 
    * 예를 들어서 VARCHAR(10)과 CHAR(10)은 동일하지만 VARCHAR(10)과 CHAR(15)는 다릅니다.
  * binary가 아닌 문자열 간의 비교를 위해서 두열은 모두 동일한 집합을 사용해야 합니다. 
    * 예를 들어서 utf8과 latin1열을 비교하면 인덱스 사용이 불가능합니다. 
  * 값의 변환없이 직접 비교 할 수 없는 경우 서로 다른열을 비교하면 인덱스를 사용할수 없을수도 있습니다. 
    * 숫자열의 1과 문자열 값의 '1', ' 1', '000001'안의 숫자 값과 비교할 수 있습니다.
    * 이것은 문자 컬럼에 대한 인덱스 사용을 배제합니다. 
* 특정한 인덱스된 컬럼 key_col에 대한 MIN(), MAX() 값을 찾습니다.
  * 인덱스 안의 key_col가 발생되기 전에 모든 key 부분에서 Key_path_N = 상수 wherew절을 사용하는지 여부를 전처리기에 의해서 최적화 됩니다. 
  * 이 경우에 MYSQL은 MIN()또는 MAX()표현 식에 대한 단일키 조회를 수행하고 상수로 바꿉니다. 
  * 모든 표현식이 상수로 대체 되면 쿼리가 한번에 반환됩니다. 
```sql
SELECT MIN(key_part2),MAX(key_part2)
  FROM tbl_name WHERE key_part1=10;
```

* 사용 가능한 인덱스의 가장 왼쪽 접두사에서 정렬 또는 그룹화가 수행 된 경우 테이블을 정렬하거나 그룹화 합니다.(예를 들어 ORDER BY key_part1, key_part2)
  * 만약에 모든 키 부분에 DESC를 가 있으면 키를 역순으로 읽습니다. 
  * [ ORDER BY Optimization](https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html)

* 경우에 따라서 데이터 행을 참조하지않고 값으 검색하도록 쿼리를 최적화 할 수 있습니다. 
  * 쿼리에 필요한 모든 결과를 제공하는 인덱스를 커버링 인덱스라고 합니다. 
  * 만약에 쿼리가 일부 인덱스에 포함된 열만 테이블에서 사용하는 경우 빠른 속도를 위해 인덱스 트리에서 선택한 값을 검색할 수 있습니다. 
#### 인덱스는 대부분 또는 모든 행을 처리하는  큰 테이블이나 작은 테이블을 위한 쿼리의 경우 덜 중요합니다.
#### 쿼리가 대부분의 행에 액세스 해야 하는 경우 인덱스를 통해서 작업하는 것보다 순차적으로 읽는 것이 더 빠릅니다. 
#### 순차 읽기는 쿼리에 모든 행이 필요하지 않더라도 디스크 검색을 최소화 합니다. 
*  [Section 8.2.1.23, “Avoiding Full Table Scans” ](https://dev.mysql.com/doc/refman/8.0/en/table-scan-avoidance.html)

---
## Primary key 최적화
#### primary key는 가장 중요한 쿼리에서 사용하는 열또는 열 집합을 나타냅니다. 
#### 빠른 쿼리 성능을 위해서 관련된 인덱스입니다. 
#### NOT NULL 최적화는 NULL 값을 포함 할 수 없기 때문에 쿼리 성능이 향상됩니다. 
#### InnoDB 스토리지 엔진을 사용하면 테이블 데이터를 물리적으로 구성되어 primary key 컬럼을 기반으로 초고속 조회 및 정렬을 수행합니다. 
#### 만약 테이블이 크고 중요하지만 primary 키로 사용할 명백한 컬럼이나 컬럼집합이 없다면 기본 키로 사용할 자동 증가 값이 있는 별도의 컬럼을 만들 수 있습니다.
#### 이러한 고유 ID는 foreign key를 사용하여 테이블을 조인 할 때 다른 테이블의 해당 행에 대한 포인터 역활을 할 수 있습니다.
---
## SPATIAL 인덱스 최적화 
#### MYSQL은 NOT NULL인 geometry 값 컬럼을 기반으로 SPATIAL 인덱스를 생성을 허용합니다. 
---
## Foreign Key 최적화 
#### 테이블에 많은 컬럼이 있고 다양한 컬럼의 조합을 쿼리하는 경우 
#### 자주 사용하지 않는 데이터를 각각 몇 개의 열이 있는 별도의 테이블로 분할 하고
#### main 테이블에서 숫자 열 ID를 복제해서 다시 연결하는 것이 효율적일 수 있습니다.(정규화)
#### 이렇게하면 각 작은 테이블은 데이터를 빠르게 조회하기 위한 primary 키를 가질 수 있고 조인 작업을 사용해서 필요한 열 집합만 쿼리 할 수 있습니다. 
#### 데이터가 분산되는 방식에 따라서 관련된 컬럼들이 디스크에 함께 저장되기 때문에 쿼리들은 I/O와 캐시 메모리를 적게 사용할 수 있습니다.
#### (성능을 극대화 하기 위해 쿼리는 디스크에서 가능한 적은 데이터 블록을 읽으려고 합니다. 적은 수의 컬럼으로 구성된 테이블은 각 데이터 블록에 더 많은 행을 넣을 수 있습니다.)
---
## Column Indexes
#### 가장 일반적인 유형의 인덱스에는 단일 열이 포함되면 해당 컬럼의 값 복사본을 데이터 구조에 저장하여 해당 열 값이 있는 행을 빠르게 조회 할 수 있습니다. 
#### B-tree 데이터 구조를 사용하면 인덱스가 WHERE절에서 =, >, <, BETWEEN, IN등과 같은 연산자에 해당하는 특정 값, 범위 값, 값 집합을 빠르게 찾을 수 있습니다. 
#### 테이블 당 최대 인덱스의 수와 최대 인덱스 길이는 스토리지 엔진 별로 정의 됩니다. 
* innoDB 제한
  * 최대 1017개의 컬럼을 가질 수 있습니다. 
  * 최대 64개의 secondary 인덱스를 가질 수 있음
  * DYNAMIC, COMPRESSED 행 format을 가지는 테이블의 인덱스 키의 접두사 제한 길이는 3072byte입니다.
  * REDUNDANT 또는 COMPACT 행 format을 사용하는 테이블은 767byte의 인덱스 키의 접두사 제한 길이을 가집니다. 
    * 만약 utf8mb4 문자 셋은 각 문자당 최대 4byte를 가정하면 VARCHAR또는 TEXT 컬럼의 191자 이상이라면 제한에 걸릴 수 있습니다. 
  * MYSQL 인스턴스의 페이지 크기를 줄이면 크기에 맞춰서 인덱스 키의 접두사 제한 길이가 비례적으로 낮아집니다. 
  * 해당 제한 full-column 인덱스 키에도 적용됩니다. 
  * multi 컬럼 인덱스는 최대 16개의 컬럼을 허용합니다. 
#### 모든 스토리지 엔진은 테이블당 최소 16개의 인덱스와 256byte의 인덱스 길이을 지원합니다.
#### 대부분의 스토리지 엔진에는 더 높은 제한이 있습니다. 
### Index Prefixes
#### 문자열 컬럼에 대한 인덱스 정의에 col_name(N)을 사용하면 열의 처음 N개의 문자만 사용하는 인덱스를 만들수 있습니다. 
#### 이러한 방식으로 열값을 접두사만 인덱싱하면 인덱스 파일을 훨씬 더 작게 만들 수 있습니다. 
#### BLOB또는 TEXT 열을 인덱실 할 때 인덱스의 접두사 길이를 지정해야합니다. 
* Note 접두사 제한은 바이트로 표현되고 실제 사용할 때는 문자열 유형의 문자 셋에 따라서 길이를 다르게 측정해야합니다. 
#### 검색 용어가 인덱스 접두사가 길이를 초과하면 인덱스를 사용해서 일치하지 않은 행을 제외한 후 남은 행들을 검사해서 일치 여부를 검사합니다. 

### FULLTEXT(전문 검색) 인덱스
#### FULLTEXT 인덱스는 전체 텍스트 검색에 사용됩니다. 
#### InnoDB 및 MYISam 스토리지 엔진만 FULLTEXT 인덱스를 지원하고 CHAR, VARCHAR, TEXT 컬럼에만 지원합니다. 
#### 인덱싱은 항상 전체 열에서 발생하며 컬럼 접두사 인덱싱은 지원되지 않습니다. 
#### 단일 InnoDB 테이블에 대한 특정 종류의 FULLTEXT 쿼리에 최적화가 적용됩니다.
#### 이러한 특성을 가진 쿼리는 특히 효율적입니다. 
* ocument ID또는 Document ID와 검색 순위만 반환하는 FULLTEXT 쿼리
* 매칭되는 row를 score의 내림차순으로 정렬하고 LIMITE 절을 적용해서 상위 N개의 일치하는 행을 가져오는 FULLTEXT 쿼리 
  * 이 최적화를 적용하려면 WHERE 절이 없어야 하며 내림차순으로 된 단일 ORDER BY절만 있어야 합니다.
* 추가 WHERE 절이 없이 검색어와 일치하는 행의 COUNT(*)값만 검색하는 FULLTEXT 쿼리
  * 어떠한 비교 연산자 없이 MATCH(text) AGAINST('other_text')이어야 합니다. 
#### 쿼리를 위해 full-text 표현식이 포함된 경우 MYSQL은 쿼리 실행 의 최적화 단계에서 해당 식을 평가합니다. 
#### optimizer는 full-text 표현식만 보고 추정하지 않고 실제로 실행 계획을 만드는 과정에서 평가합니다. 
---
# 찾아보기
* Mysql공간 데이터 유형이란
  * 2차원의 공간 개념의 값
  * MYSQL은 POINT, LINE, POLYGON, GEOMETRY 형식의 데이터 타입을 지원합니다. 
  * GEOMETRY 형식은 POINT, LINE, POLYGON의 상위 타입으로 모든 타입을 저장할 수 있습니다.
* R-Tree무엇인가?
  * MBR(Minimum Bounding Rectangle)이라는 개념을 알고 있어야함
  * MBR을 기반으로 사각형들의 포함 관계를 기준으로 B-tree를 구현한 형태의 인덱스 
* 커버링 인덱스란?
  * 쿼리가 요구하는 모든 컬럼을 포함하는 인덱스 
  * 인덱스 값을 포인터로 사용해서 전체 테이블 행을 찾는 대신 인덱스 구조체에서 값을 리턴해서 디스크 I/O를 절약합니다. 
  * InnoDB는 이 최적화 기술을 MyISAM보다 더 많이 인덱스에 적용 할 수 있습니다. 
  * 왜냐하면 InnoDB의 secondary 인덱스에는 primary key 컬럼이 포함됩니다. 
  * InnoDB는 테이블에 변경에 의한 트랜젝션이 종료될 때까지 이 기술을 적용할 수 없습니다. 
  * 커버링 인덱스에 적합한 쿼리가 주어지면 어떠한 컬럼 인덱스 또는 복합 컬럼 인덱스도 수행 가능합니다. 
  * 가능한 경우 최적화 기술을 활용하도록 인덱스 및 쿼리를 설계 하십시오 
* column index
  * 하나의 컬럼을 가진 인덱스 
* composite index 
  * 여러개의 컬럼을 가진 인덱스 
* primary key
  * 테이블의 모든 행을 고유하게 식별할 수 있는 열 집합
  * 따라서 unique index이어야 하고 null 값을 포함할 수 없습니다. 
  * innoDB는 모든 테이블에 이러한 인덱스가 있어야 합니다.(cluster index라고 부름)
  * innoDB는 기본 키의 열 값을 기반으로 테이블 스토리지를 구성합니다. 
  * primary 키를 선택할 때는 다른 소스로 부터 파생되는 값에 의존하는 대신 임의 값을 사용하는 것이 좋습니다.
* secondary index
  * 테이블 열의 부분집합을 나타내는 InnoDB 인덱스 유형입니다. 
  * InnoDB 테이블은 0개 이상의 secondary index를 가질 수 있습니다. 
  * secondary index는 인덱싱된 컬럼의 값만 필요한 쿼리를 위해서 사용할 수 있습니다. 
  * 더 복잡한 쿼리의 경우 테이블에서 관련 행을 식별 하는 데 사용할 수 있으며 cluster index를 사용해서 검색합니다. 
  * secondary index의 생성과 삭제는 이전에는 InnoDB 테이블안에 모든 데이터를 복사하는 비용을 수반했습니다.
  * fast index creation 기능은 InnoDb secondary 인덱스위해 create 및 drop문을 훨씬 빠르게 만듭니다.
## fractal-tree
### fractal-tree 인덱싱
* fractal-tree 인덱싱은 여러 특허로 보호되고 있는 TokuDB 및 TukuMX의 기반 기술입니다. 
* 다른 데이터베이스 엔진에서 사용되는 기존 B-트리 데이터 구조를 강화하고 최신 하드웨어 및 데이터 세트의 성능을 최적화합니다. 
### 배경  
* B-트리 데이터 구조는 대규모 데이터 블록을 위해서 발명되었지만 오늘날 성능은 I/O 대역폭에 의해서 제한됩니다.
* 이는 production 데이터 베이스의  크기가 일반적으로 사용 가능한 주 메모리를 초과하기 때문입니다. 
* 그 결과로 트리의 대부분의 leave들은 RAM이 아닌 디스크에 저장되고 메인 메모리에 없는 leave에 데이터를 넣으려면 I/O작업이 필요합니다. 
* 빅 데이터에 대한 스토리지 요구 사항이 증가함에 따라서 RAM을 늘리는 것은 너무 비싸기 때문에 디스크 I/O를 최적화 하는 것이 중요합니다. 
### 버퍼
* B-Tree와 마찬가지로 fractal tree 인덱스는 트리 데이터 구조입니다. 
* 그러나 피벗 외에도 프렉탈 트리 인덱스의 각 내부 노드에는 버퍼도 포함됩니다. 
* 이러한 버퍼는 삽입을 임시로 저장하는데 사용되고 버퍼가 가득 차면 자식 노드로 flush됩니다. 
* 이렇게 하면 I/O당 작은 write가 아닌 디스크에 leave들에 메시지가 도달 할 때 I/O 작업이 많은 유용한 작업을 수행 할 수 있도록 보장합니다. 
* 데이터 읽기는 데이터 일관성 측면에서 버퍼의 영향을 받지 않습니다 .
* fractal tree 인덱스 구조를 사용해서 데이터 베이스를 쿼리하는 것은 B-tree의 경우 동일한 알고리즘 복잡성을 포함합니다. 
* 쿼리는 버퍼의 모든 메시지(insert, delete, update)를 통과하는 root에서 leaf로의 경로를 따르기 때문에 데이터 손실이 없습니다.
* 따라서 쿼리는 변경 사항이 리프에 아직 전파 되지 않은 경우에도 데이터의 현재상태를 알수 있습니다. 
* 각 메시지는 leaf가 아닌 노드 메시지 버퍼에 저장 될 때 고유한 메시지 시퀀스 번호(MSN)로 스템프되고 MSN은 fractal tree에서 고유한 값을 가집니다. 
* MSN은 메시지 순서를 유지하고 상위 노드에 의해 버퍼링 된 메시지에 의해 leaf 노드가 업데이트 될 때 leaf 노드가 업데이트 될때 메시지가 leaf 노드에 한번만 적용되도록 합니다. 
* 버퍼도 디스크에 직렬화 되므로 충돌이나 정전이 발생해도 내부 노드의 메시지가 손실되지 않습니다. 
* 체크 포인트 이후 및 충돌이전에 쓰기 발생한 경우 복구는 로그를 통해서 재 수행됩니다. 

## InnoDB FULL TEXT인덱스
* FULLTEXT 인덱스는 텍스트 기반 열에 생성되어 해당 열에 포함된 데이터에 대한 쿼리 및 DML 작업의 속도를 높이고 불용어로 정의된 모든 단어를 생략합니다. 
* FULLTEXT 인덱스는 CREATE TABLE문의 일부로 정의되거나 ALTER TABLE또는 CREATE INDEX를 사용해서 기존 테이블에 추가됩니다.
* 전체 텍스트 검색은 MATCH AGAINST 구문을 사용해서 수행됩니다. 
### InnoDB Full-Text 인덱스 디자인
* InnoDB FULLTEXT 인덱스에는 역 인덱스 디자인이 있습니다. 
* 역 인덱스는 단어 목록을 저장하고 각 단어에 대해 해당 단어가 나타내는 문서 목록을 저장합니다. 
* 근접 검색을 지원하기 위해 각 단어에 대한 위치 정보도 바이트 오프셋으로 저장됩니다. 
### InnoDB Full-Text 인덱스 테이블
* 


## 번역주소 
* https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html
* https://www.percona.com/doc/percona-tokudb/ft-index.html
* https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html