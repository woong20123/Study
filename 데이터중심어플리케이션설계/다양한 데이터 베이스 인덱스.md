# MYSQL

## MYSQL의 INDEX 사용 방식
### 인덱스 내부 구조
* 대부분의 MYSQL 인덱스는 B-trees를 사용합니다. 
* SPATIAL 인덱스의 경우 R-tree를 사용하며 메모리 테이블은 hash 인덱스를 사용합니다. 

### MYSQL에서 인덱스 사용 목적
* Where절과 일치하는 행을 빠르게 검색
* Join을 수행시 다른 테이블의 행을 검색
* 인덱스된 컬럼의 MIN(), MAX() 찾기
* sort또는 group화합니다. 
* covering index(커버링 인덱스)
  * 경우에 따라서는 데이터 행을 참조하지 않고 값을 추출합니다.
  
#### 주의 할점 대부분 행에 엑세스 한다면 인덱스보다는  순차읽기가 더 빠릅니다.

## Partitioning Key

## Primary key
* 가장 중요한 쿼리에서 사용되는 컬럼 및 컬럼 집합으로 선정합니다. 
* 빠른 쿼리 성능을 위한 인덱스이며 NOT NULL 최적화 및 UNIQUE가 적용됩니다. 
* InnoDB 엔진을 사용하면 primary key를 기반으로 데이터들이 물리적으로 구성되어 초고속 조회가 가능합니다. 
* 일반적으로 primary key는 cluster key입니다. 


### Primary key를 생성하지 않으면
* 만약에 테이블에 PRIMARY KEY를 지정하지 않으면 NOT NULL이면서 첫번째 UNIQUE 인덱스를 찾아 클러스터 인덱스로 사용합니다. 
* 만약에 UNIQUE 키도 존재하지 않는다면 내부적으로 숨겨진 클러스터형 인덱스 생성합니다.
  * 숨겨진 클러스터형 인덱스는 사용할 수 없습니다. 
  
## Secondary 인덱스
* 클러스터 인덱스를 제외한 모든 인덱스를 Secondary 인덱스라고 합니다. 
* Secondary 인덱스는 레코드는 (Secondary 인덱스 컬럼 + Primary 인덱스 컬럼으로 구성)
  * Primary 인덱스 컬럼을 통해서 데이터 페이지에 접근합니다.
* Secondary 인덱스에 primary 인덱스가 포함되기 때문에 primary 인덱스의 사이즈가 커지면 많은 공간을 사용하므로 primary 인덱스는 작을수록 효율적입니다. 
* [링크 사이트](https://jungwoong.tistory.com/34?category=1073468)
  

## Covering index
* 쿼리가 요구하는 모든 컬럼을 포함하는 인덱스 
* 인덱스 page에서 모든 데이터를 가져올 수 있다면 데이터 page를 참조하지 않고 결과를 리턴할 수 있습니다.
* 특히 InnoDB의 secondary 인덱스의 경우 primary key를 포함하기 때문에 더욱 유용
```sql
-- 테이블 생성
CREATE TABLE `demo`.`coveringIndex` (
  `A` INT NOT NULL,
  `B` INT NULL,
  `C` INT NULL,
  `D` INT NULL,
  `E` INT NULL,
  `F` INT NULL,
  PRIMARY KEY (`A`),
  UNIQUE INDEX `SECOND` (`B` ASC, `C` ASC) )
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8;

-- A, B, C는 인덱스 page에 포함되는 구조이기 때문에 covering index 가능
SELECT A, B, C
FROM `demo`.`coveringIndex`
WHERE B = 1 and C = 10
```

## Spatial index
* Spatial data인 2차원 데이터를 인덱싱하고 검색하는 인덱스입니다. 
* R-Tree 인덱스를 통해서 구현됩니다. 

### Spatial data
* mysql은 기하학적 도형의 정보를 저장할 수 있습니다.
* POINT, LINE, POLYGON, GEOMETRY 타입을 가지며 GEOMETRY은 POINT, LINE, POLYGON의 상위 타입으로 모든 타입을 저장할 수 있습니다.
```sql
POINT(15 20)
LINESTRING(0 0, 10 10, 20 25, 50 60)
POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))
MULTIPOINT(0 0, 20 20, 60 60)
```
### R-tree 알고리즘
* MBR(minimun Bounding Rectangle)의 포함 관계를 B-Tree형태로 구현한 인덱스입니다. 
* [R-tree 관련 설명 사이트](https://12bme.tistory.com/143)

## Index prefix
* 작업 필요

## FULLTEXT 인덱스
* 작업 필요

## Fractal-Tree 인덱스
* TokuTek사에서 개발한 알고리즘(특허로 보호됨)
### 개발된 배경
* B-tree는 대규모 데이터 블록을 위해 개발되었지만 디스크 I/O에 의해서 제한됨
  * 그 이유는 대용량의 데이터 베이스의 크기가 RAM으로 감당할수 없으므로 대부분의 leave들을 사용하려면 I/O가 발생 
### 개선 방안
* B-Tree와 마찬가지로 fractal-Tree도 트리 구조이지만 각 내부 노드에는 버퍼가 존재합니다.
* 버퍼는 insert를 임시로 저장하며 buffer가 가득차면 자식 노드로 flush함
* 이렇게 한다면 디스크의 leave들에 메시지가 도달 할 때 I/O당 작은 write가 아니라 유용한 많은 작업들을 수행하도록 보장합니다. 
* 버퍼는 디스크에 직렬화 되므로 충돌이나 정전이 발생해도 메시지 손실이 발생하지 않습니다.
* 만약 복구 작업이 필요하면 로그를 통해서 복구 할 수 있습니다.
* 참고 사이트
  * https://www.percona.com/doc/percona-tokudb/ft-index.html
  * https://gywn.net/2014/05/fractal-index-in-tokudb/


#### [링크 사이트](https://medium.com/@hmj2088/mysql-tokudb-rocksdb-and-innodb-ae90bda34cea)

## InnoDB의 제한 사항
* 테이블은 최대 1017개의 컬럼을 가질 수 있습니다. 
* 최대 64개의 secondary index를 가질 수 있습니다. 
* 페이지의 크기에 따라서 인덱스 키의 접두사 제한이 달라집니다. 
* 최소 table space의 크기는 10MB보다 약간 큽니다.

|page size|index prefix|tablespace size|
|:--:|:--:|:--:|
|4kb|768byte|16TB|
|8kb|1536byte|32TB|
|16kb|3072byte|64TB|
|32kb|3072byte|128TB|
|64kb|3072byte|256TB|


* multi-컬럼 인덱스는 최대 16개의 컬럼을 허용합니다. 
#### table space란 하나 또는 여러개의 데이터 파일로 구성된 논리적인 데이터 저장구조

#### 참조 사이트
* https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html
* https://www.percona.com/doc/percona-tokudb/ft-index.html


# 레디스

# MongoDB

# 카산드라
## 카산드라 데이터 모델링 특징
* 쿼리 기반 데이터 모델링 
  * ex) 어떤 쿼리가 필요하면 그것에 최적화된 테이블을 생성
* 읽기를 빠르게 하기 위해서 비정규화를 통해 데이터를 중복적재 합니다.
* 카산드라는 조인을 지원하지 않으므로 필요한 데이터는 한 테이블에 구성되어야 합니다. 

## 파티션(partition)
* 카산드라는 노드 클러스터에 데이터를 저장하는 분산 데이터 베이스입니다.
* 파티션 키를 해싱 처리하여 스토리지 노드에 데이터를 분산시킵니다. 
* 파티션 키를 통해서 해시 테이블로 분산된 데이터를 빠르게 접근 할 수 있습니다. 
* 쿼리를 작성할 때 파티션이 적게 사용 될 수록 응답시간이 빨라집니다. 

## 파티션 키(partition key) 및 클러스터링 키(clustering key) 생성 방식
* partition key는 primary key의 첫번째 필드로부터 생성됩니다. 
* primary key의 나머지 필드는 clustering키가 됩니다. 
```sql
CREATE TABLE t (
   id int,
   c text,
   k int,
   v text,
   PRIMARY KEY (id, c)
);
```
* 예를 들면 위의 예제 테이블의 경우 id 필드는 partition key가 되고 c 필드는 clustering key가 됩니다. 
* 만약에 PRIMARY KEY(id) 였다면  id 필드는 partition key이고 clustering key는 없습니다.
  * partition key만 필수 조건입니다. 
* 앞서 설명한 것과 같이 partition key의 역활은 해싱 처리를 통한 클러스터의 노드들에 데이터를 분산시키는데 사용 됩니다.
* clustering key는 파티션안에서 데이터를 정렬 시키는데 사용되는 값입니다. 
```sql
CREATE TABLE t2 (
   id1 int,
   id2 int,
   c1 text,
   c2 text
   k int,
   v text,
   PRIMARY KEY ((id1,id2),c1,c2)
);
```
* 위의 예제 테이블 처럼 partition key도 복합 키(id1, id2 필드)로 구성될 수 있습니다. 
* id1, id2 필드는 partition key가 되고 c1, c2 필드는 clustering key가 됩니다. 

## 데이터 모델링의 목표
* primary key와 partition key를 선택하는 것은 클러스터에 데이터를 균등하게 분산하기 위해서 중요합니다.
* 쿼리를 위해서 읽어야 하는 파티션의 수를 최소한으로 유지하는 것이 중요합니다.
  * 이유 
    * 서로 다른 파티션은 다른 노드에 있을 수 있고 만약 그렇다면 각 노드들에게 Request 해야 하는 비용이 발생 
    * 파티션이 동일한 노드에 있더라도 더 적은 파티션이 효율적임

## 관계형 데이터 모델과 비교 
* 카산드라는 join을 지원하지 않습니다.
* 카산드라 데이터 중복에 대해서 비정규화를 통해 중복적으로 데이터 적재합니다.
* 카산드라는 쿼리 기반으로 테이터 모델을 설계합니다.
* 만약에 카산드라가 엔티티간의 복잡성을 완전히 통합하지 못한다면 Client Side Join을 수행할 수있습니다.
  * Client Side Join란 간단히 클라이언트에서 여러개의 쿼리를 요청해서 조합하는 것을 말합니다. 
  * 이런 상황이라면 디자인에 대한 재설계가 중요 할듯

||관계형 데이터|카산드라|
|:--:|:--:|:--:|
|Join|사용가능|사용불가|
|무결성|있음|없음|
|디자인 설계|테이블 관계 기반|쿼리 기반 |
|데이터중복|정규화|비정규화|

## 데이터 모델링 고려사항 
* 파티션 설계시 고려사항
  * 파티션안의 Value는 10만개 이하로 유지
  * 디스크 공간을 100MB 이하로 유지
* 어쩔 수 없이 설계상 카산드라는 중복 데이터를 사용할 수 있지만 최소한으로 유지하려고 노력 해야 합니다. 
* LWT는 성능에 영향을 미칠 수 있으므로 LWT를 사용하는 쿼리는 최소로 유지해야합니다. 
  * LWT는 if절을 지원하는 update, insert 구문
  * Compare and Set이라고 불림
  * CAS(Compare and Set) coordinator들간의 통신작업으로 작업시간이 4배정도 증가합니다. 


## 데이터 모델링 예제
```c
struct {
  int id,
  string name,
  int frequecy,
  DATE date,
  string publisher
}
```
* 예를 들어 위의 그림과 같이 Magazine이라는 데이터 구조로 구성된 데이터 셋트가 있습니다. 
* 만약 사용자가 magazine의 이름과 발생빈도(frequency)를 나열하기 위한 Q1 쿼리가 필요합니다. 
* Q1 쿼리를 기반으로 필요한 데이터를 구성해서 magazine_name이라는 테이블을 만듭니다. 
* id를 partition key를 가진 테이블입니다.
```sql
CREATE TABLE magazine_name(
  id int PRIMATRY KEY, 
  name text, 
  frequency text
  );
```
* 또 다른 쿼리인 Q2는 publisher 별로 모든 magazine의 이름과 발생 빈도를 나열해야 합니다. 
* Q2를 기반으로 publisher를 partition key로 가지고 id를 clustering key를 가진 테이블을 생성합니다. 
```sql
CREATE TABLE magazine_pulisher (
  publisher text, 
  id int, 
  name text, 
  frequency int, 
  PRIMARY KEY(publisher, id) WITH CLUSTERING ORDER BY(id DESC)
  );
```
* 쿼리 기반으로 최적화 하기 위해서 비정규화를 중복된 데이터 적재가 발생합니다. 

# Materialized View
* 4.0부터 지원합니다. 
* 기 능
  * 단일 테이블에 대해서 여러 쿼리를 구현할 수 잇습니다. 
  * 기본 테이블을 기준으로 새로운 primary key와 새로운 요소로 작성된 테이블입니다. 
  * 기본 테이블의 데이터가 변경되면 MV에 데이터가 자동으로 적용됩니다. 

## 참조 
* https://cassandra.apache.org/doc/latest/data_modeling/intro.html