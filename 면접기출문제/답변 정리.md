## rvalue vs universal reference
* 명시적인 객체에 대해서 이동 연산자(`&&`)가 붙으면 rvalue 참조를 뜻함
  * 일반적으로 std::move를 통해서 인자가 전달 됩니다. 
* 명시적이지 않은 객체에 이동 연산자가 붙으면 universal 참조 뜻함
  * 참조 축약이 동작합니다. 
  * 일반적으로 std::forword를 통해서 전달 합니다. 

## std::move
* 캐스팅만 수행하며 전달 되는 인자의 참조를 제거한 후 rvalue 참조로 변환합니다. 
* const가 붙은 객체는 rvalue로 변환 할 수 없습니다. 
  * const 때문에 이동 생성자가 채택되지 못하고 복사 생성자가 선택됩니다. 
```c++
template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

// FUNCTION TEMPLATE move
// remove_reference_t를 통해서 전달 받은 타입의 레퍼런스를 제거 -> &&로 캐스팅
template <class _Ty>
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```

## std::forward
* 전달 받은 인자의 원래 참조타입으로 전달합니다. 
* 사용 이유는 함수를 통해서 rvalue reference를 전달 할 때 전달 용 rvalue 참조 파라미터도 lvalue이기 때문입니다.

## auto
* auto를 통해서 타입을 추론 할 때 const, volatole, 참조가 삭제 되는 것에 유의 해야합니다. cv-qualifiers
* `auto &&` 형태로 선언하면 보편 참조로 추론 됩니다.

##  decltype(declared type)
* 명시된 대상의 타입을 산출합니다. 
  * decltype(대상) : 대상을 객체로 인식합니다.
  * decltype((대상)) : 표현식으로 인식합니다.
```c++
struct A
{
public:
    int a;
};

{    
    const A x;
    decltype(x.a) AxEntity = 10;
    // decltype(x.a) => int로 추론
    AxEntity = 100;

    decltype((x.a)) AxExpression = 10;
    // decltype((x.a)) => const int로 추론
    AxExpression = 100;
}

// c++ 11에서의 decltype 구현
template<typename T1, typename T2>
auto TemplatePlus(T1&& right, T2&& left) -> decltype(right + left)
{
    return right + left;
}

// c++ 14에서의 decltype 구현
template<typename T1, typename T2>
decltype(auto) TemplatePlus(T1&& right, T2&& left)
{
    return right + left;
}

// visual studio 2019에서는 이렇게 선언해도 수행가능
template<typename T1, typename T2>
auto TemplatePlus(T1&& right, T2&& left)
{
    return right + left;
}
```

## constexpr
* 컴파일 타임에서 값이 계산됩니다. 
* constexpr 함수의 리턴 값이 constexpr 속성을 가지려면 리터럴 타입이어야 합니다.
  * 컴파일 타임에 연산하기 때문에 실행 속도 및 메모리 사용량이 줄어 듭니다. 
  * constexpr 함수는 특이하게 동작하는데 인자 값에 따라서 컴파일 타임, 런타임 동작이 달라집니다. 
* constexpr 변수는 컴파일 타임에 초기화 되어야 하빈다. 
* constexpt의 이점은 읽기 전용 메모리 배치 되기 때문에 더욱 효율적인 수행이 가능합니다. 

## string_view
* string_view를 사용하면 원본에 대해서 안전하게 사용 할 수 있습니다. 
* 문자열에 대한 포인터와 사이즈 값만 가지고 있습니다. 

## mutex
* 윈도우에서 mutex는 윈도우7이상부터는 SRWLock, 이하에서는 크리티컬 섹션(유저모드)으로 구현되어 있습니다.
### std::mutex
* 이미 소유한 스레드에서 중복으로 호출시 exception 발생
* 복사를 지원하지 않음
  
### std::recursive_mutex
* 이미 소유한 스레드에서 중복으로 호출 가능, 획득한 만큼 해제 필요

### std::timed_mutex
* condition_variable를 통해서 특정시간을 지정해서 lock을 설정할 수 있습니다. 

### std::shared_mutex
* srwLock과 같이 읽기 작업, 쓰기 작업에 대한 접근 방식을 제공합니다. 
* 하나의 스레드는 오직 하나의 타입의 lock만 획득 가능
  * shared : 여러 스레드들이 동일한 mutex 소유권을 공유합니다. 
    * shared로 lock을 획득 한 상태에서는 다른 shared들이 접근 가능
  * exclusive : 오직 하나의 스레드에서만 소유권을 가집니다. 
    * exclusive로 lock을 획득한 상태에서 다른 곳에서 접근 불가

## Lock
* lock 관련 클래스는 mutex를 쉽게 사용 할 수 있도록 지원합니다. 
### lock_guard
* RAII(Resource Acquisition is initialization) 스타일의 mutex wrapper 클래스입니다.
* non-copyable 클래스입니다. 
* BasicLockable 인터페이스를 지원하는 어떤 클래스도 사용 가능합니다. 

### unique_lock, shared_lock
* shared_mutex를 exclusive하게 lock을 획득 하려면 unique_lock 사용
* shared_mutex를 shared 하게 lock을 획득하려명 shared_lock 
#### 획득 옵션 
* defer_lock_t : 뮤텍스를 저장하고 락을 시도하지 않습니다 .
* try_to_lock_t : 락을 시도하니다. 실패 하면 바로 리턴
* adopt_lock_t : 이미 호출 한 스레드가 락을 소유 했다고 가정하빈다. 

## 동시에 여러개의 lock을 획득하는법
* deadlock을 회피하기 위해서 입력된 인자 순서대로 락을 획득합니다.
```c++
void transfer(bank_account &from, bank_account &to, int amount)
{
    // lock both mutexes without deadlock
    std::lock(from.m, to.m);
    // make sure both already-locked mutexes are unlocked at the end of scope
    std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);
 
// equivalent approach:
//    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
//    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);
//    std::lock(lock1, lock2);
 
    from.balance -= amount;
    to.balance += amount;
}
```

## condition_variable(조건 변수)
* condition_variable는 다른 스레드가 공유 변수를 수정하고 condition_variable로 통지 할때까지 대기하는데 사용됩니다. 
* 뮤텍스와 연동되어서 스레드에 안전하게 동작합니다. 
* std::condition_variable은 오직 `std::unique_lock<std::mutex>`하고만 함께 사용할 수 있습니다. 
```c++
std::mutex				m_;
std::condition_variable		cv_;
std::queue<std::string>		con_;

// queue에 데이터를 추가하고 대기하고 있는 스레드들에게 알림을 통지합니다. 
void Push(const std::string& obj) {
    {
        std::unique_lock<std::mutex> sl(m_);
        con_.push(obj);
    }

    // 대기중인 하나의 스레드 알림 통지
    cv_.notify_one();
    // 대기중인 모든 스레드 알림 통지
    // cv_.notify_all();
}

// queue에서 데이터를 추출하고, queue가 비어 있다면 condition_variable을 통해서 대기 합니다.                            
bool Pop(std::string& obj) {
    std::unique_lock<std::mutex> ul(m_);
    if (con_.empty())
    {
        cv_.wait(ul, [] {return !con_.empty(); });
    }

    obj = con_.front(); con_.pop();
    return true;
}
```

## 중괄호 초기화
* 광범위하게 적용할 수 있는 초기화 구문입니다. 
* 중괄호 초기화는 std::initializer_list 매개변수 생성자와 부합

## 불변객체 및 const 함수 - 스레드 안정성
* const 객체는 스레드에 안전하다고 가정하고 구현하는 것이 바람직합니다. 

## LockFree
* CAS(CompareAndSwap) 연산자를 통해서 반복적인 요청을 통해서 작업을 수행합니다.
  * 원자적인 단위의 작업만 가능합니다.
  * c++ atomic을 통해서 지원 합니다. 
  * window에서는 InterLocked API를 통해서 지원합니다. 
    * CPU 플랫폼마다 다르지만 x86 cpu에서는 하드웨어 시그널을 통해서 다른 cpu가 동일 메모리에 접근하지 못하도록 합니다.
    * 동시에 InterLocked 내부 수행 도중에 인터럽트가 발생하지 않도록 합니다. 
    * 유저 모드에서 동작합니다.
* ABA 문제
  * CAS 값이 동일한지만 판단 할 수 있습니다. 
  * Pool을 통해서 객체가 재활용 될 때 문제가 될 수 있습니다. 

## 특수 멤버 함수 자동 작성 조건
* 특수 멤버 함수들 기본생성자, 소멸자, 복사 생성자, 복사 배정 연산자, 이동생성자, 이동 배정 연산자
* 이동 연산자들은 소멸자, 복사 연산들이 명시적으로 선언되지 않은 클래스에 대해서만 자동 작성됩니다. 
* 이동연산이 정의되어 있으면 자동 복사 생성자, 복사 대입연산자가 생성되지 않습니다. 
* `= default`를 붙여서 기본 연산자를 배정하는 방법도 있습니다. 

## std::unique_ptr
* 포인터를 고유하게 관리합니다. 
* 복사는 불가, 이동은 가능합니다. 
## std::shared_ptr
* 참조 카운팅을 사용해서 포인터를 공유합니다. 
* make_shared를 사용해서 생성하는 것이 안전하며 효율이 좋습니다.
  * 할당 자우너과 ControlBlock을 같은 페이지에서 관리
* 참조 카운팅은 스레드에 안전해야 하기 때문에 interLock 함수를 사용합니다. 
  * 값 복사로 함수에 전달시 비용이 증가 합니다. 
## std::weak_ptr
* shared_ptr의 참조 카운트에 영향을 받지 않은 스마트 포인터
* 직접적으로 자원에 대한 사용을 할 수 없습니다. 
* 할당 받은 자원에 대해서 lock()이라는 함수를 통해서 shared_ptr로 변환할 수 있습니다. 
  * 만약 자원이 이미 해제 되었다면 null을 리턴합니다. 
* 위와 같은 방식으로 안정성을 보장합니다. 
  
## std::async
* 주어진 함수를 비동기로 수행하는 함수 템플릿 
* 기존에 작성된 함수를 간단하게 스레드로 수행할 수 있음
* 일반적인 구현은 스레드 풀 사용
* std::launch 옵션을 줄 수 있음
  * std::launch::async
    * 비동기로 수행하라고 알립니다. 
  * std::launch::deferred 
    * std::launch::deferred만 있다면 동기로 수행
    * 지연된 실행으로 요청합니다. future에서 get을 호출 할 때
  * launch 옵션을 주지 않는다면
    * std::launch::async | std::launch::deferred 
* std::async의 반환값
  * std::future
  * 소멸자에서 get() 호출 해서 대기 
  * 사용자가 명시적으로 get()을 호출하지 않아도 스레드 종료를 대기함
  * 반환 값을 받지 않은 경우
    * 반환값을 나오는 임시 객체가 파괴될때 소멸자에서 get() 호출
    * 스레드가 종료 될 때 까지아래 로직들이 실행되지 않음
  * async로 반환되는 future만 해당 방식을 가짐 
## std::transform
* java의 map 구문과 비슷합니다. 
* 전달받은 iterator를 func을 통해서 수행한 뒤에 Dest에 추가합니다. 
```c++
template<class _InIt,
	class _OutIt,
	class _Fn> inline
	_OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func)
	{	// transform [_First, _Last) with _Func
	_Adl_verify_range(_First, _Last);
	auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	for (; _UFirst != _ULast; ++_UFirst, (void)++_UDest)
		{
		*_UDest = _Func(*_UFirst);
		}

	_Seek_wrapped(_Dest, _UDest);
	return (_Dest);
	}
```
## std::accumulate
* java의 reduce 구문과 비슷합니다. 
* 함수 객체를 넘기지 않는다면 PLUS 형태로 동작합니다. 세번째 인수는 초기 값입니다. 
* 네번째 함수 객체를 넘기면 함수 객체를 통해서 연산 할 수 있습니다. 
```c++
std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int sum = std::accumulate(v.begin(), v.end(), 0); // 55

std::string s = std::accumulate(std::next(v.begin()), v.end(), std::to_string(v[0]), // start with first element
                                    dash_fold); // 1-2-3-4-5-6-7-8-9-10

template<class _InIt,
	class _Ty,
	class _Fn>
	_NODISCARD inline _Ty accumulate(const _InIt _First, const _InIt _Last, _Ty _Val, _Fn _Reduce_op)
	{	// return noncommutative and nonassociative reduction of _Val and all in [_First, _Last), using _Reduce_op
	_Adl_verify_range(_First, _Last);
	auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		_Val = _Reduce_op(_Val, *_UFirst);
		}

	return (_Val);
	}

template<class _InIt,
	class _Ty>
	_NODISCARD inline _Ty accumulate(const _InIt _First, const _InIt _Last, _Ty _Val)
	{	// return noncommutative and nonassociative reduction of _Val and all in [_First, _Last)
	return (_STD accumulate(_First, _Last, _Val, plus<>()));
	}
```

## SFINAE
* SFINAE(substitution-failure-is-not-an-error)는 템플릿에서 치환 실패는 오류가 아님이라는 법칙을 말합니다. 
  * 함수 오버로드 후보 집합을 만들 때 그 중에는 템플릿 매개 변수에 자료형이나 값이 대입된 경우가 있을 수 있다. 
  * 이 대체 과정에서 발생한 오류가 C++ 표준이 허용하는 것이라면, 컴파일러는 컴파일 오류를 보고하지 않고, 후보 집합에서 그 후보를 제외한다.
  * 만약 하나 이상의 후보가 남고 오버로드 결정(Overload Resolution)에 성공한다면, 호출이 정상적으로 이루어진다.
* 많은 개발자들이 이러한 점을 이용해서 컴파일 시에 활용할 수 있는 검사 기법을 만들어냈다
* https://ko.wikipedia.org/wiki/SFINAE
```c++
struct Test {
  typedef int foo;
};

template <typename T>
void f(typename T::foo) {}  // 정의 1

template <typename T>
void f(T) {}  // 정의 2

int main() {
  f<Test>(10);  // 정의 1을 호출한다.
  f<int>(10);   // SFINAE 덕분에
                // int::foo가 없으므로 오류 없이 정의 2를 호출한다.
}
```

## 덤프 파일 분석
* 크래쉬 발생시 dump 파일 생성하도록 구성 필요
* visual studio로 분석시 원본 소스코드, exe파일, pdb파일 필요
  * exe 파일에는 소스코드 및 데이터 정보가 포함되어 있음
  * pdb파일(기호파일)은 프로그램 데이터 베이스라고 하며 함수 이름, 변수 이름, 소스 파일, 소스 행 번호등등의 정보 포함되어 있습니다. 
* 덤프 파일 종류
  * 전체 User-Mode 덤프
    * 프로세스의 전제 메모리 공간을 재구성한느 유용한 기타 정보가 포함됩니다. 
  * 미니 덤프